<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>springcloud | 茶白的博客</title><meta name="author" content="茶白"><meta name="copyright" content="茶白"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="springcloud什么是微服务In short, the microservice architectural style , is an approach to developing a single application as a suite of small services, each running in its own process and communicating with">
<meta property="og:type" content="article">
<meta property="og:title" content="springcloud">
<meta property="og:url" content="https://chabai000.github.io/posts/41300/index.html">
<meta property="og:site_name" content="茶白的博客">
<meta property="og:description" content="springcloud什么是微服务In short, the microservice architectural style , is an approach to developing a single application as a suite of small services, each running in its own process and communicating with">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chabai000.github.io/UpPictures/UpCover/springcloud.png">
<meta property="article:published_time" content="2022-04-10T09:57:37.000Z">
<meta property="article:modified_time" content="2024-09-05T13:42:13.984Z">
<meta property="article:author" content="茶白">
<meta property="article:tag" content="微服务">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chabai000.github.io/UpPictures/UpCover/springcloud.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chabai000.github.io/posts/41300/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 茶白","link":"链接: ","source":"来源: 茶白的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'springcloud',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-05 21:42:13'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><style type="text/css">.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{left:-66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{left:0!important}</style><meta name="generator" content="Hexo 7.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/UpPictures/UpCover/springcloud.png')"><nav id="nav"><span id="blog-info"><a href="/" title="茶白的博客"><span class="site-name">茶白的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">springcloud</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-10T09:57:37.000Z" title="发表于 2022-04-10 17:57:37">2022-04-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-05T13:42:13.984Z" title="更新于 2024-09-05 21:42:13">2024-09-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">45.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>167分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="springcloud"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="springcloud"><a href="#springcloud" class="headerlink" title="springcloud"></a>springcloud</h1><h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>In short, the microservice architectural style , is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.</p>
<p><strong>提炼：</strong></p>
<ul>
<li>微服务是一种架构风格</li>
<li>基于原来单个应用开发出一系列微小服务</li>
<li>每个服务运行在自己的计算机进程内，也就是可独立部署和升级</li>
<li>服务之间使用轻量级HTTP rest交互</li>
<li>每个服务基于项目中的业务进行拆分</li>
<li>这些服务都是基于分布式管理</li>
<li>去中心化，服务自治。服务可以使用不同的语言、不同的存储技术</li>
</ul>
<p><strong>官方定义</strong>:基于单个应用围绕业务进行拆分,拆分出的每个服务独立项目,他们独立部署运行在自己的进程里,基于分布式的管理</p>
<p><strong>通俗定义</strong>:微服务是一种架构，这种架构是将单个的整体应用程序分割成更小的项目关联的独立的服务。一个服务通常实现一组独立的特性或功能，包含自己的业务逻辑和适配器。各个微服务之间的关联通过暴露api来实现。这些独立的微服务不需要部署在同一个虚拟机，同一个系统和同一个应用服务器中。</p>
<p><strong>集群 cluster：</strong>同一种软件服务的多个服务节点共同为系统提供服务过程 称之为该软件服务集群</p>
<p><strong>分布式 distribute:</strong>  不同的软件集群共同为一个系统提供服务 这个系统称之为分布式系统</p>
<h2 id="为什么微服务？"><a href="#为什么微服务？" class="headerlink" title="为什么微服务？"></a>为什么微服务？</h2><h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410183538363.png" alt="image-20240410183538363"></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>单一架构模式在项目初期很小的时候开发方便，测试方便，部署方便，运行良好。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>应用随着时间的推进，加入的功能越来越多，最终会变得巨大，一个项目中很有可能数百万行的代码，互相之间繁琐的jar包。</li>
<li>久而久之，开发效率低，代码维护困难</li>
<li>还有一个如果想整体应用采用新的技术，新的框架或者语言，那是不可能的。</li>
<li>任意模块的漏洞或者错误都会影响这个应用，降低系统的可靠性</li>
</ul>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410183556101.png" alt="image-20240410183556101"></p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>将服务拆分成多个单一职责的小的服务，进行单独部署，服务之间通过网络进行通信</li>
<li>每个服务应该有自己单独的管理团队，<strong>高度自治</strong></li>
<li>服务各自有自己单独的职责，服务之间松耦合，避免因一个模块的问题导致服务崩溃</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>开发人员要处理分布式系统的复杂性</li>
<li>多服务运维难度，随着服务的增加，运维的压力也在增大</li>
<li><strong>服务治理 和 服务监控 关键</strong></li>
</ul>
<p><strong>微服务是一种经过良好架构设计的分布式架构方案，&#x3D;&#x3D;&#x3D;&gt;springcloud: 一个工具 里边有各种各样组件 这些组件能帮我们解决上述问题</strong></p>
<h4 id="微服务架构特征"><a href="#微服务架构特征" class="headerlink" title="微服务架构特征"></a>微服务架构特征</h4><ul>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发</li>
<li>面向服务：微服务对外暴露业务接口</li>
<li>自治：团队独立、技术独立、数据独立、部署独立</li>
<li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li>
</ul>
<h3 id="架构的演变"><a href="#架构的演变" class="headerlink" title="架构的演变"></a>架构的演变</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410213244352.png" alt="image-20240410213244352"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1. 单一架构  All In One Application</span></span><br><span class="line"><span class="bullet">-</span> 起初当网站流量很小时，将所有功能都写在一个应用里面，对整个应用进行部署，以减少部署节点和成本。对于这个架构简化增删改查的工作量的   数据访问框架(ORM)是关键。</span><br><span class="line"><span class="bullet">-</span> 所有的代码都写在一起 JSP+Mysql+Tomcat 所有东西都写在jsp页面里 </span><br><span class="line"><span class="bullet">-</span> ORM是关键 如何解决对象关系映射 ==》框架 Hibernate JPA Mybatis</span><br><span class="line"><span class="section"># 2. 垂直架构 分层开发 Vertical Application</span></span><br><span class="line"><span class="bullet">-</span> 随着访问量的逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。此时，   用于加速前端页面开发的web框架（MVC）是关键。</span><br><span class="line"><span class="bullet">-</span> MVC关键 控制器是关键 ===》struts struts2 springmvc springboot</span><br><span class="line"><span class="section"># 3. 分布式服务架构 Distributed Service</span></span><br><span class="line"><span class="bullet">-</span> 当垂直应用越来越多，应用之间的交互不可避免，将核心业务抽取出来。作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时提高业务复用及整合的分布式服务框架（RPC）是关键。</span><br><span class="line"><span class="bullet">-</span> tomcat集群 mysql集群 redis集群组成分布式</span><br><span class="line"><span class="bullet">-</span> RPC关键 远程过程调用 作用：服务间通信一种手段</span><br><span class="line"><span class="bullet">-</span> RPC传输效率远高于http OSI七层 物理层（高） 数据链路层 网络层 传输层（RPC）会话层 表示层 应用层（http）</span><br><span class="line"><span class="section"># 4. 流动计算架构即微服务架构 Elastic Computing</span></span><br><span class="line"><span class="bullet">-</span> 在分布式架构下，当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量。   提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA Service Oriented Architecture)是关键。</span><br><span class="line"><span class="bullet">-</span> 把一个系统基于业务进行一个个服务拆分 每个服务拆分出来到时候都是一个集群部署 </span><br><span class="line"><span class="bullet">-</span> 服务的治理和监控是关键</span><br></pre></td></tr></table></figure>

<h3 id="微服务的解决方案"><a href="#微服务的解决方案" class="headerlink" title="微服务的解决方案"></a>微服务的解决方案</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 国内阿里系</span></span><br><span class="line"><span class="bullet">-</span> springboot + dubbo +zookeeper 最早期 由于dubbo长时间停更失去了机遇</span><br><span class="line"><span class="section"># spring cloud 技术栈</span></span><br><span class="line"><span class="bullet">1.</span> spring cloud netflix 最早期一栈式解决方案  16-17 netflix后来闭源             组件</span><br><span class="line">基于美国Netflix公司开源的组件进行封装,提供了微服务一栈式的解决方案。</span><br><span class="line"><span class="bullet">2.</span> spring cloud spring 自己封装微服务解决方案 spring团队吸收netflix后自己推出的   自己组件 + 继续使用netflix组件</span><br><span class="line">目前spring官方趋势正在逐渐吸收Netflix组件的精华,并在此基础进行二次封装优化,打造spring专有的解决方案</span><br><span class="line"><span class="bullet">3.</span> spring cloud alibaba 阿里巴巴解决方案     基于spring cloud netflix         自己组件 + 继续使用spring,netflix组件</span><br><span class="line">在Spring cloud netflix基础上封装了阿里巴巴的微服务解决方案。</span><br><span class="line"><span class="section"># 如何选择？</span></span><br><span class="line"><span class="bullet">-</span> 我们三个组件都用用各自技术最优秀的组件去构建项目</span><br><span class="line"><span class="bullet">-</span> 我们要能区分哪些组件是netflix,spring,alibaba的</span><br><span class="line"><span class="bullet">-</span> 我们暂时只学习netflix,spring的</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Cloud引言"><a href="#Spring-Cloud引言" class="headerlink" title="Spring Cloud引言"></a>Spring Cloud引言</h2><h3 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h3><p><strong>Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems</strong> (e.g<code>configuration management</code> ,<code>service discovery</code>, <code>circuit breakers</code>, <code>intelligent routing</code>, <code>micro-proxy</code>, <code>control bus</code>).Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns. —[摘自官网]</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 翻译</span></span><br><span class="line">springcloud为开发人员提供了在分布式系统中快速构建些通用模式的工具(例如配置管理、服务发现、断路器、智能路由、微代理、控制总线)。分布式系统的协调导致了锅炉板模式，使用springcloud开发人员可以快速地建立实现这些模式的服务和应用程序。</span><br><span class="line"><span class="section"># 通俗理解</span></span><br><span class="line">springcloud是一个含概多个子项目的开发工具集,集合了众多的开源框架,他利用了Spring Boot开发的便利性实现了很多功能,如服务注册,服务注册发现,负载均衡等.SpringCloud在整合过程中主要是针对Netflix(奈飞)开源组件的封装.SpringCloud的出现真正的简化了分布式架构的开发</span><br><span class="line">NetFlix是美国的一个在线视频网站，微服务业的翅楚，他是公认的大规模生产级微服务的杰出实践者,NetFlix的开源组件已经在他大规模分布式微服务环 境中经过多年的生产实战验证，因此Spring Cloud中很多组件都是基于NetFlix</span><br><span class="line"></span><br><span class="line">简单定义：springcloud含有众多微服务工具集 提供了一系列组件(服务注册 发现 负载均衡 路由组件 统一配置管理) 去解决我们微服务遇到的每一个问题 帮助我们快速构建一套分布式应用</span><br><span class="line"></span><br><span class="line">注：每个组件都是一个单独的项目 springcloud是一个由众多独立组件(子项目)组成的大型综合项目</span><br></pre></td></tr></table></figure>

<h3 id="核心架构及其组件"><a href="#核心架构及其组件" class="headerlink" title="核心架构及其组件"></a>核心架构及其组件</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240411000411299.png" alt="image-20240411000411299"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.核心组件说明</span></span><br><span class="line"><span class="bullet">-</span> eurekaserver、consul、nacos  	 服务注册中心组件</span><br><span class="line"><span class="bullet">-</span> rabbion &amp; openfeign  			  服务负载均衡 和 服务调用组件</span><br><span class="line"><span class="bullet">-</span> hystrix &amp; hystrix dashboard     服务断路器  和  服务监控组件</span><br><span class="line"><span class="bullet">-</span> zuul、gateway 					 服务网关组件</span><br><span class="line"><span class="bullet">-</span> config 						  统一配置中心组件</span><br><span class="line"><span class="bullet">-</span> bus                             消息总线组件</span><br><span class="line"><span class="section"># 这些核心组件接下来我们会一个个学习 最后基于我们的学习过的组件搭建一个大型微服务项目</span></span><br></pre></td></tr></table></figure>

<h3 id="springcloud命名和springboot版本选择"><a href="#springcloud命名和springboot版本选择" class="headerlink" title="springcloud命名和springboot版本选择"></a>springcloud命名和springboot版本选择</h3><p>springcloud是利用了springboot的便利性 每一个微服务都是springboot应用 故和springboot的版本有极大的关联关系 必须要严格一致 不然是跑不起来的。</p>
<p><strong>springcloud命名</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># springcloud命名</span></span><br><span class="line"><span class="bullet">-</span> 最开始不是选择数字命名</span><br><span class="line">springcloud是一个由众多独立组件(子项目)组成的大型综合项目，原则每个子项目上有不同的发布节奏，都维护自己发布版本号，为了更好的管理springcloud的版本，通过一个资源清单B0M(Bi11 of Materials) ,为避免与子项目的发布号混滑，所以没有采用版本号的方式。而是通过命名的方式。这些名字是按字母顺序排列的。如伦敦地铁站的名称(“天使&quot;是第一个版本，“布里斯顿”是第二个版本，“卡姆查”是第三个版本)。当单个项目的点发布累积 到一个临界量，或者其中个项目中有一 个关键缺陷需要每个人都可以使用时， 发布序列将推出名称以“. SRX&quot;结尾的“服务发布&quot;， 其中&quot;X&quot;是一个数字。</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.伦敦地铁站名称[了解] A-Z</span></span><br><span class="line">Ange1、Brixton. Canden、Dalston. Edgware. F inchley、Greenwrich. Hoxton</span><br><span class="line"></span><br><span class="line"><span class="section"># Hoxton是最后一个非数字版本 最新命名2023.0.1</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410233742303.png" alt="image-20240410233742303"></p>
<p><strong>springcloud和springboot版本对应关系</strong>  官网可看</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 版本选择官方建议 https://spring.io/projects/spring-cloud#overview</span></span><br><span class="line"><span class="bullet">-</span> Angel 										版本基于springboot1.2.x版本构建与1.3版本不兼容</span><br><span class="line"><span class="bullet">-</span> Brixton										版本基于springboot1.3.x版本构建与1.2版本不兼容</span><br><span class="line"><span class="code">	`2017年Brixton and Angel release官方宣布报废</span></span><br><span class="line"><span class="code">- Camden      							版本基于springboot1.4.x版本构建并在1.5版本通过测试</span></span><br><span class="line"><span class="code">	`2018年Camden release官方宣布报废</span></span><br><span class="line"><span class="code">- Dalston、Edgware 				 版本基于springboot1.5.x版本构建目前不能再springboot2.0.x版本中使用</span></span><br><span class="line"><span class="code">	`Dalston(达尔斯顿)将于2018年12月官方宣布报废。Edgware将遵循Spring Boot 1.5.x的生命周期结束。</span></span><br><span class="line"><span class="code">- Finchley 									版本基于springboot2.0.x版本进行构建,不能兼容1.x版本</span></span><br><span class="line"><span class="code">- Greenwich									版本基于springboot2.1.x版本进行构建,不能兼容1.x版本</span></span><br><span class="line"><span class="code">- Hoxton  我们这里用的版本					   版本基于springboot2.2.x版本进行构建</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410234102737.png" alt="image-20240410234102737"></p>
<h2 id="提供者与消费者"><a href="#提供者与消费者" class="headerlink" title="提供者与消费者"></a>提供者与消费者</h2><blockquote>
<p>服务提供者：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）<br>服务消费者：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p>
</blockquote>
<h3 id="服务调用关系"><a href="#服务调用关系" class="headerlink" title="服务调用关系"></a>服务调用关系</h3><p>服务提供者：暴露接口给其它微服务调用<br>服务消费者：调用其它微服务提供的接口<br>提供者与消费者角色其实是相对的<br>一个服务可以同时是服务提供者和服务消费者</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">springboot&amp;springcloud</span><br><span class="line">版本：</span><br><span class="line">springcloud Hoxton.SR6(1-10)</span><br><span class="line">springboot 2.2.5版本</span><br><span class="line">jdk1.8即jdk8</span><br><span class="line">maven 3.x </span><br><span class="line">idea 2018</span><br></pre></td></tr></table></figure>

<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 创建springcloud<span class="emphasis">_parent ----springcloud父项目包括springboot+springcloud父项目</span></span><br><span class="line"><span class="emphasis">   采用maven聚合方式全局搭建一个所谓的springcloud父项目 为了统一管理springboot和springcloud版本号</span></span><br><span class="line"><span class="emphasis">2. 在父项目中继承springboot父项目</span></span><br><span class="line"><span class="emphasis">     &lt;!--继承springboot的父项目--&gt;</span></span><br><span class="line"><span class="emphasis">     <span class="language-xml"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">         <span class="language-xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span></span>org.springframework.boot<span class="language-xml"><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">         <span class="language-xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span>spring-boot-starter-parent<span class="language-xml"><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">         <span class="language-xml"><span class="tag">&lt;<span class="name">version</span>&gt;</span></span>2.2.5.RELEASE<span class="language-xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">     <span class="language-xml"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">3. 维护springcloud依赖</span></span><br><span class="line"><span class="emphasis">    &lt;!--自定义properties属性--&gt;</span></span><br><span class="line"><span class="emphasis">    <span class="language-xml"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">        &lt;!--定义springcloud使用版本号--&gt;</span></span><br><span class="line"><span class="emphasis">        <span class="language-xml"><span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span></span>Hoxton.SR6<span class="language-xml"><span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">    <span class="language-xml"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">    </span></span><br><span class="line"><span class="emphasis">    &lt;!--维护版本--&gt;</span></span><br><span class="line"><span class="emphasis">    <span class="language-xml"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">        <span class="language-xml"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">             &lt;!--维护springcloud版本,并不会引入具体依赖--&gt;</span></span><br><span class="line"><span class="emphasis">            <span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">                <span class="language-xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span></span>org.springframework.cloud<span class="language-xml"><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">                <span class="language-xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span>spring-cloud-dependencies<span class="language-xml"><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">                <span class="language-xml"><span class="tag">&lt;<span class="name">version</span>&gt;</span></span>$&#123;spring-cloud.version&#125;<span class="language-xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span> &lt;!--此处是引用故我们上边要定义出来--&gt;</span></span><br><span class="line"><span class="emphasis">                &lt;!--</span></span><br><span class="line"><span class="emphasis">                spring-cloud-dependencies也是一个父项目，一个项目只能有一个父项目我们上边已引 故只能用这种方式再次引入</span></span><br><span class="line"><span class="emphasis">                --&gt;</span></span><br><span class="line"><span class="emphasis">                <span class="language-xml"><span class="tag">&lt;<span class="name">type</span>&gt;</span></span>pom<span class="language-xml"><span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">                <span class="language-xml"><span class="tag">&lt;<span class="name">scope</span>&gt;</span></span>import<span class="language-xml"><span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">            <span class="language-xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">        <span class="language-xml"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">    <span class="language-xml"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span> </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建一个普通的maven项目，删除src   作为父模块管理维护依赖  同时检查项目结构里项目和模块sdk jdk 和maven上的java版本以及maven配置仓库</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410183707213.png" alt="image-20240410183707213"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410183719596.png" alt="image-20240410183719596"></p>
<blockquote>
<p>pom.xml</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.blb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--继承springboot的父项目--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--自定义properties属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义springcloud使用版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR6<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">     <span class="comment">&lt;!--维护版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--全局管理springcloud版本,并不会引入具体依赖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="服务注册中心组件"><a href="#服务注册中心组件" class="headerlink" title="服务注册中心组件"></a>服务注册中心组件</h2><blockquote>
<p>服务的管理者 不完成任何业务功能 纯作服务注册中心</p>
</blockquote>
<p>所谓服务注册中心就是在整个的微服务架构中单独提出一个服务，这个服务不完成系统的任何的业务功能，仅仅用来完成对整个微服务系统的服务注册，服务发现，服务健康状态的监控和管理功能，以及服务元数据信息存储</p>
<p>元数据信息存储:即记录集群每台主机的ip 和 端口</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240411151423751.png" alt="image-20240411151423751"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.服务注册中心</span></span><br><span class="line"><span class="bullet">-</span> 可以对所有的微服务的信息进行存储，如微服务的名称、IP、端口等</span><br><span class="line"><span class="bullet">-</span> 可以在进行服务调用时通过服务发现查询可用的微服务列表及网络地址进行服务调用</span><br><span class="line"><span class="bullet">-</span> 可以对所有的微服务进行心跳检测，如发现某实例长时间无法访问，就会从服务注册表移除该实例。</span><br></pre></td></tr></table></figure>

<p>服务注册中心可以说是微服务架构中的通讯录，它记录了服务和服务地址的映射关系，在分布式架构中，服务会注册到这里，当服务需要调用其他服务时，就到这里找到服务地址进行调用。</p>
<h3 id="常用的服务注册中心"><a href="#常用的服务注册中心" class="headerlink" title="常用的服务注册中心"></a>常用的服务注册中心</h3><p>springcloud支持的多种服务注册中心<code>Eureka(netflix)</code>、<code>Consul(java)</code>、<code>Zookeeper(Go)</code>、以及阿里巴巴推出<code>Nacos</code>。这些注册中心在本质上都是用来管理服务的注册和发现以及服务状态的检查的。</p>
<h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><blockquote>
<p>neflix的组件</p>
</blockquote>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Eureka是Netflix开发的服务发现框架，本身是一个基于REST的服务。SpringCloud将它集成在其子项目spring-cloud-netflix中， 以实现SpringCloud的服务注册和发现功能。<br>Eureka包含两个组件：Eureka Server和Eureka Client。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240411153038810.png" alt="image-20240411153038810"></p>
<p><strong>eureka的作用</strong></p>
<p>服务提供者启动时向eureka注册自己的信息<br>eureka保存这些信息<br>消费者根据服务名称向eureka拉取提供者信息</p>
<p>服务消费者利用负载均衡算法，从服务列表中挑选一个</p>
<p>服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状态<br>eureka会更新记录服务列表信息，心跳不正常会被剔除<br>消费者就可以拉取到最新的信息</p>
<h4 id="开发Eureka-Server服务注册中心"><a href="#开发Eureka-Server服务注册中心" class="headerlink" title="开发Eureka Server服务注册中心"></a>开发Eureka Server服务注册中心</h4><blockquote>
<p>学习springcloud组件三步：引依赖、写配置、加注解</p>
</blockquote>
<p><strong>在父项目下创建springboot项目  springcloud_01eureka_server</strong>    不完成任何业务功能 纯作服务注册中心</p>
<p><strong>引入springboot依赖</strong> springcloud_01eureka_server&#x2F;pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>引入springboot配置文件</strong></p>
<p><strong>写入口类测试springboot是否可以启动</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chabai;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 刘晔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：若报错则可能是jdk版本太高不支持调低即可</p>
<hr>
<p>以上是一个纯springboot项目构建过程,想要让它作为一个eureka server需经过以下配置</p>
<hr>
<p><strong>引入eureka server依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入eureka server依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>写配置文件</strong> springcloud_01eureka_server&#x2F;src&#x2F;resources&#x2F;application.properties</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#eureka server端口号 默认是8761</span></span><br><span class="line"><span class="string">server.port=8761</span></span><br><span class="line"><span class="comment">#eureka server服务注册中心地址 暴露服务地址 给客户端注册</span></span><br><span class="line"><span class="string">eureka.client.service-url.defaultZone=http://localhost:8761/eureka</span></span><br></pre></td></tr></table></figure>

<p><strong>在入口类加入注解 开启Eureka Server</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.blb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span><span class="comment">//开启当前应用是一个服务注册中心</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class,args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8761/</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240411171446838.png" alt="image-20240411171446838"></p>
<p><strong>问题</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240411171957538.png" alt="image-20240411171957538"></p>
<p><strong>通过配置解决</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定服务名称，注意服务名不能出现下划线 默认服务名不区分大小写，推荐大写 服务名称至关重要 必须唯一</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">eurekaserver </span></span><br><span class="line"><span class="attr">eureka.client.fetch-registry</span>=<span class="string">false		   # 关闭eureka.client立即注册</span></span><br><span class="line"><span class="attr">eureka.client.register-with-eureka</span>=<span class="string">false   # 是否将自己注册到注册中心 让当前应用仅仅是服务注册中心</span></span><br></pre></td></tr></table></figure>

<h4 id="Eureka-Client开发"><a href="#Eureka-Client开发" class="headerlink" title="Eureka Client开发"></a>Eureka Client开发</h4><p>Eureka Client就是基于业务拆分出来的一个个微服务，站在Eureka Server角度服务即是微服务又是客户端</p>
<p><strong>在父项目下创建springboot项目  order_client</strong>  要见名知意  以订单服务为例</p>
<p><strong>引入springboot依赖</strong> pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入springboot--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>**引入springboot配置文件 指定微服务端口 指定微服务名 ** application.properties</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.port=<span class="number">8888</span>									   #指定微服务端口</span><br><span class="line">spring.application.name=ORDERCLIENT					   #指定微服务名称唯一标识</span><br></pre></td></tr></table></figure>

<p><strong>写入口类测试springboot是否可以启动</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chabai;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 刘晔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderClientApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderClientApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>引入引入eureka client依赖</strong> </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入eureka client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>继续写配置 指定服务注册地址（其实前边配置也可放到这块来写）</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka   #eureka注册中心地址</span><br></pre></td></tr></table></figure>

<p><strong>在入口类加入注解 开启eureka客户端</strong>  <strong>启动之前的8761的服务注册中心,再启动eureka客户端服务</strong> </p>
<p>作为客户端 必须保证服务端是正常开启的 我们才能正常注册客户端到服务注册中心</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chabai;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> <span class="comment">//让当前微服务作为一个eureka serve客户端 进行微服务注册</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaClientApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaClientApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>开启服务端此时并没有服务注册</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240411180032690.png" alt="image-20240411180032690"></p>
<p><strong>开启客户端查看eureka server的服务注册情况</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240411175929233.png" alt="image-20240411175929233"></p>
<h4 id="eureka自我保护机制"><a href="#eureka自我保护机制" class="headerlink" title="eureka自我保护机制"></a>eureka自我保护机制</h4><p><strong>自我保护机制</strong>  </p>
<p>默认是开启自我保护的，但是只有网路通信故障等原因时才触发则它们将进入自我保护模式。这样做是为了确保灾难性网络事件不会清除 eureka 注册表数据，并将其传播到下游的所有客户端。</p>
<p><strong>怎么判断网络正常与否</strong></p>
<p>通过心跳机制，判断期望心跳数（ 理想心跳数）和实际心跳数<br>如果上一分钟心跳数 &lt; 期望心跳数的85%,此时我认为网络有波动，是不正常的， 就会触发自我保护机制<br>如果上一分钟心跳数 &gt;&#x3D; 期望心跳数的85%,此时我认为网络是正常的，不会触发自我保护；</p>
<p><strong>自我保护机制触发现象</strong>   </p>
<p>管理界面如下提示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240411181154814.png" alt="image-20240411181154814"></p>
<p>在自我保护模式下，eureka 服务器将停止逐出所有实例，直到：</p>
<ol>
<li>注册中心会一直检测网络情况，当发现网络正常时，就会自动退出自我保护，这时不正常的客户端就会被剔除，或者</li>
<li>自我保护被禁用（见下文）</li>
</ol>
<p><strong>配置中关闭了自我保护之后</strong>，客户端每30s续约一次，服务端每60s扫描一次超过90s还没有续约的客户端，超时就会立即剔除。</p>
<p>在eureka server端禁用自我保护</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eureka.server.enable-self-preservation=<span class="literal">false</span>  #关闭自我保护</span><br><span class="line">eureka.server.eviction-interval-timer-in-ms=<span class="number">60</span>*<span class="number">1000</span> #默认<span class="number">1</span>分钟  </span><br></pre></td></tr></table></figure>

<p>eureka client配置自我保护阈值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eureka.instance.lease-expiration-duration-in-seconds=<span class="number">90</span> #用来修改eureka server默认接受心跳的最大时间 默认是90s</span><br><span class="line">eureka.instance.lease-renewal-interval-in-seconds=<span class="number">30</span>    #指定客户端多久向eureka server发送一次心跳 默认是30s</span><br></pre></td></tr></table></figure>

<p><strong>自我保护机制开或关选择</strong></p>
<p>开发环境下，我们我们启动的服务数量较少而且会经常修改重启。如果开启自我保护机制，很容易触发Eureka客户端心跳占比低于85%的情况。使得Eureka不会剔除我们的服务，从而在我们访问的时候，会访问到可能已经失效的服务，导致请求失败，影响我们的开发。</p>
<p>在生产环境下，我们启动的服务多且不会反复启动修改。环境也相对稳定，影响服务正常运行的人为情况较少。适合开启自我保护机制，让Eureka进行管理。</p>
<p><strong>自我保护机制好处</strong></p>
<p>Eureka服务端为了防止Eureka客户端本身是可以正常访问的，但是由于网路通信故障等原因，造成Eureka服务端失去于客户端的连接，从而形成的不可用。</p>
<p>因为网络通信是可能恢复的，但是Eureka客户端只会在启动时才去服务端注册。如果因为网络的原因而剔除了客户端，将造成客户端无法再注册到服务端。</p>
<h4 id="eureka停止更新"><a href="#eureka停止更新" class="headerlink" title="eureka停止更新"></a>eureka停止更新</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># https://github.com/Netflix/eureka/wiki </span></span><br><span class="line"><span class="bullet">-</span> 在1.x版本项目还是很活跃 用的话推荐用1.x版本  但是不在建议用了 </span><br><span class="line"><span class="bullet">-</span> 在2.x版本中停止维护 </span><br></pre></td></tr></table></figure>

<h4 id="管理界面客户端ip-端口显示"><a href="#管理界面客户端ip-端口显示" class="headerlink" title="管理界面客户端ip+端口显示"></a>管理界面客户端ip+端口显示</h4><p>默认是主机名+服务名+端口</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 略</span></span><br></pre></td></tr></table></figure>

<h4 id="Eureka集群搭建"><a href="#Eureka集群搭建" class="headerlink" title="Eureka集群搭建"></a>Eureka集群搭建</h4><h5 id="Eureka-Server集群"><a href="#Eureka-Server集群" class="headerlink" title="Eureka Server集群"></a>Eureka Server集群</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 完全集群</span></span><br><span class="line">a.创建3个springboot项目</span><br><span class="line">b.都引入eureka server依赖</span><br><span class="line">c.服务端都配置文件application.properties 注：一台机器跑三个节点端口号不能相同</span><br><span class="line">  配置文件如下：</span><br><span class="line">  nodel1:</span><br><span class="line"><span class="code">    server.port=8761</span></span><br><span class="line"><span class="code">    spring.application.name=eurekaserver</span></span><br><span class="line"><span class="code">    eureka.client.service-url.defaultZone=http://localhost:8762/eureka,http://localhost:8763/eureka</span></span><br><span class="line"><span class="code">    eureka.client.register-with-eureka=false          #不再将自己同时作为客户端进行注册  </span></span><br><span class="line"><span class="code">    eureka.client.fetch-registry=false				  #关闭作为客户端时从eureka server获取服务信息</span></span><br><span class="line"><span class="code">  nodel2:</span></span><br><span class="line"><span class="code">    server.port=8762</span></span><br><span class="line"><span class="code">    spring.application.name=eurekaserver</span></span><br><span class="line"><span class="code">    eureka.client.service-url.defaultZone=http://localhost:8761/eureka,http://localhost:8763/eureka</span></span><br><span class="line"><span class="code">    eureka.client.register-with-eureka=false          #不再将自己同时作为客户端进行注册  </span></span><br><span class="line"><span class="code">    eureka.client.fetch-registry=false				  #关闭作为客户端时从eureka server获取服务信息</span></span><br><span class="line"><span class="code">  nodel3:</span></span><br><span class="line"><span class="code">    server.port=8763</span></span><br><span class="line"><span class="code">    spring.application.name=eurekaserver</span></span><br><span class="line"><span class="code">    eureka.client.service-url.defaultZone=http://localhost:8761/eureka,http://localhost:8762/eureka</span></span><br><span class="line"><span class="code">    eureka.client.register-with-eureka=false          #不再将自己同时作为客户端进行注册  </span></span><br><span class="line"><span class="code">    eureka.client.fetch-registry=false				  #关闭作为客户端时从eureka server获取服务信息</span></span><br><span class="line"><span class="code">d.在每个项目入口类加入 @EnableEurekaServer</span></span><br><span class="line"><span class="code"># 也可利用ided简单创建</span></span><br><span class="line"><span class="code"># 验证集群是否搭建成功</span></span><br><span class="line"><span class="code">集群数据要保持一致 我只要向一个服务端注册 其它属于集群的服务端 都有这个注册的客户端 则集群搭建成功</span></span><br><span class="line"><span class="code">但是我们不推荐这样只写一个注册中心地址 防止一个注册中心down掉 而无法向剩余正常注册中心注册 但可用这个测试服务端集群搭建是否成功</span></span><br><span class="line"><span class="code">客户端配置如下：</span></span><br><span class="line"><span class="code">    server.port=8888												#服务端口号</span></span><br><span class="line"><span class="code">    spring.application.name=eurekaclient8888						#服务名称唯一标识</span></span><br><span class="line"><span class="code">    eureka.client.service-url.defaultZone=</span></span><br><span class="line"><span class="code">    http://localhost:8761/eureka,http://localhost:8762/eureka,http://localhost:8763/eureka #向多个注册中心同时注册                                   </span></span><br></pre></td></tr></table></figure>

<h5 id="Eureka-Client集群"><a href="#Eureka-Client集群" class="headerlink" title="Eureka Client集群"></a>Eureka Client集群</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 客户端服务集群即微服务集群 对于微服务我们所有代码配置都相同 只有部署到机器的端口不一样 </span></span><br><span class="line">`注同一服务的集群：我们只需保证服务名一致，端口不一样即可</span><br><span class="line">server.port=8888                                                #服务端口号</span><br><span class="line">spring.application.name=eurekaclient8888						#服务名称唯一标识</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka,http://localhost:8762/eureka,http://localhost:8763/eureka #eureka注册中心地址</span><br><span class="line"></span><br><span class="line">server.port=8889												#服务端口号</span><br><span class="line">spring.application.name=eurekaclient8888						#服务名称唯一标识</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka,http://localhost:8762/eureka,http://localhost:8763/eureka #eureka注册中心地址</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410184031696.png" alt="image-20240410184031696"></p>
<h5 id="idea提供的简单搭建方法"><a href="#idea提供的简单搭建方法" class="headerlink" title="idea提供的简单搭建方法"></a>idea提供的简单搭建方法</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412145035975.png" alt="image-20240412145035975"></p>
<h4 id="Eureka缺点"><a href="#Eureka缺点" class="headerlink" title="Eureka缺点"></a>Eureka缺点</h4><p>每次开发微服务 使用eureka 服务注册中心需要我们自己每次通过代码形式开发</p>
<h3 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h3><h4 id="引言和安装"><a href="#引言和安装" class="headerlink" title="引言和安装"></a>引言和安装</h4><p><strong>简介</strong></p>
<blockquote>
<p>不是netflix spring alibaba的组件 属于google  </p>
</blockquote>
<p>consul是一个可以提供服务发现，健康检查，多数据中心，Key&#x2F;Value存储等功能的分布式服务框架，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，使用起来也较为简单。Consul用Golang实现，因此具有天然可移植性(支持Linux、Windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署。</p>
<p>作用:管理微服务中所有服务注册 发现 管理服务元数据信息存储(服务名 地址列表)  心跳健康检查</p>
<p><strong>Consul安装</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.consul.io/downloads">Consul下载网址  </a>    在指定目录解压即可，注意目录不要包含中文</p>
<h4 id="启动consul服务注册中心"><a href="#启动consul服务注册中心" class="headerlink" title="启动consul服务注册中心"></a>启动consul服务注册中心</h4><p><strong>启动 Consul</strong></p>
<p>启动服务注册中心，在consul安装目录下打开cmd 配置好环境变量后可不在安装目录启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -dev #也可-server 我们测试用-dev单节点即可 集群的话再用-server</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410184317358.png" alt="image-20240410184317358"></p>
<p><strong>访问 Consul 管理界面 Consul必须启动</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8500   默认端口8500</span></span><br></pre></td></tr></table></figure>

<p><strong>管理界面基本介绍</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dc1: 数据中心名称  datacenter 默认为:dc1 指定数据中心名称启动 consul agent -dev -datacenter-xx</span><br><span class="line">services: 当前consul服务中心注册服务列表 默认:client和server同时启动自己注册自己 会出现一个consul</span><br><span class="line">nodes: 用来查看consul集群节点</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240411221142809.png" alt="image-20240411221142809"></p>
<h4 id="开发consul-客户端即微服务"><a href="#开发consul-客户端即微服务" class="headerlink" title="开发consul 客户端即微服务"></a>开发consul 客户端即微服务</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 创建独立springboot应用 consul<span class="emphasis">_client</span></span><br><span class="line"><span class="emphasis">2. 引入spring-boot-starter-web依赖</span></span><br><span class="line"><span class="emphasis">    <span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">        <span class="language-xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span></span>org.springframework.boot<span class="language-xml"><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">        <span class="language-xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span>spring-boot-starter-web<span class="language-xml"><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">    <span class="language-xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">3. 引入springboot配置文件 application.properties</span></span><br><span class="line"><span class="emphasis">   #配置服务端口号和服务名</span></span><br><span class="line"><span class="emphasis">   server.port=8082</span></span><br><span class="line"><span class="emphasis">   spring.application.name=CONSULCLIENT</span></span><br><span class="line"><span class="emphasis">4. 写入口类测试springboot是否可以启动</span></span><br><span class="line"><span class="emphasis">    package com.chabai;</span></span><br><span class="line"><span class="emphasis">    import org.springframework.boot.SpringApplication;</span></span><br><span class="line"><span class="emphasis">    import org.springframework.boot.autoconfigure.SpringBootApplication;</span></span><br><span class="line"><span class="emphasis">    @SpringBootApplication//代表这是一个springboot入口应用</span></span><br><span class="line"><span class="emphasis">    public class ConsulClientApplication &#123;</span></span><br><span class="line"><span class="emphasis">        public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="emphasis">            SpringApplication.run(ConsulClientApplication.class,args);</span></span><br><span class="line"><span class="emphasis">        &#125;</span></span><br><span class="line"><span class="emphasis">    &#125;</span></span><br><span class="line"><span class="emphasis">5. 引入consul客户端依赖 作用：能把当前服务注册到指定的consul服务注册中心</span></span><br><span class="line"><span class="emphasis">    &lt;!--引入consul客户端依赖 discovery：服务注册和发现--&gt;</span></span><br><span class="line"><span class="emphasis">    <span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">        <span class="language-xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span></span>org.springframework.cloud<span class="language-xml"><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">        <span class="language-xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span>spring-cloud-starter-consul-discovery<span class="language-xml"><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">    <span class="language-xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">6. 再次写配置文件</span></span><br><span class="line"><span class="emphasis">    #配置服务端口号和服务名</span></span><br><span class="line"><span class="emphasis">    server.port=8082</span></span><br><span class="line"><span class="emphasis">    spring.application.name=CONSULCLIENT</span></span><br><span class="line"><span class="emphasis">    #consul server 服务注册地址</span></span><br><span class="line"><span class="emphasis">    spring.cloud.consul.host=localhost							          #注册consul服务的主机</span></span><br><span class="line"><span class="emphasis">    spring.cloud.consul.port=8500									      #注册consul服务的端口号</span></span><br><span class="line"><span class="emphasis">    spring.cloud.consul.discovery.service-name=$&#123;spring.application.name&#125; #指定注册的服务名称 默认就是应用名 可自定义   </span></span><br><span class="line"><span class="emphasis">7. 在入口类加客户端注解@EnableDiscoveryClient(除eureka client)</span></span><br><span class="line"><span class="emphasis">    package com.chabai;</span></span><br><span class="line"><span class="emphasis">    import org.springframework.boot.SpringApplication;</span></span><br><span class="line"><span class="emphasis">    import org.springframework.boot.autoconfigure.SpringBootApplication;</span></span><br><span class="line"><span class="emphasis">    import org.springframework.cloud.client.discovery.EnableDiscoveryClient;s</span></span><br><span class="line"><span class="emphasis">    @SpringBootApplication //代表这是一个springboot入口应用</span></span><br><span class="line"><span class="emphasis">    @EnableDiscoveryClient //作用：通用服务注册客户端注解 代表 consul client zk client nacos client</span></span><br><span class="line"><span class="emphasis">    public class ConsulClientApplication &#123;</span></span><br><span class="line"><span class="emphasis">        public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="emphasis">            SpringApplication.run(ConsulClientApplication.class,args);</span></span><br><span class="line"><span class="emphasis">        &#125;</span></span><br><span class="line"><span class="emphasis">    &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>8.启动服务并在consul界面查看服务信息</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410184253805.png" alt="image-20240410184253805"><br>发现服务不能使用，原因如下</p>
<p>consul server 检测所有客户端心跳，但是发送心跳时client必须给与响应该服务才能正常使用，现在所有客户端中并没有引入健康检查依赖，所以导致健康检查始终不通过，导致服务不能使用</p>
<p><strong>9.consul 开启健康监控检查</strong></p>
<p>默认情况consul监控健康是开启的,但是必须依赖健康监控依赖才能正确监控健康状态所以直接启动会显示错误,引入健康监控依赖之后服务正常</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入健康检查依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">10.</span> 再次写配置文件</span><br><span class="line"><span class="code">    server.port=8082</span></span><br><span class="line"><span class="code">    spring.application.name=CONSULCLIENT</span></span><br><span class="line"><span class="code">    #consul server 服务注册地址</span></span><br><span class="line"><span class="code">    spring.cloud.consul.host=localhost							          #注册consul服务的主机</span></span><br><span class="line"><span class="code">    spring.cloud.consul.port=8500									      #注册consul服务的端口号</span></span><br><span class="line"><span class="code">    #关闭consu服务的健康检查 在生产情况下不推荐关闭健康检查 默认开启true 设为flase不用引入健康检查依赖 就可正常启动服务</span></span><br><span class="line"><span class="code">    spring.cloud.consul.discovery.register-health-check=true          </span></span><br><span class="line"><span class="code">    spring.cloud.consul.discovery.service-name=$&#123;spring.application.name&#125; #指定注册的服务名称 默认就是应用名 可自定</span></span><br><span class="line"><span class="code">11. 再次启动consul client如下：</span></span><br><span class="line"><span class="code">    服务正常</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410184340734.png" alt="image-20240410184340734"></p>
<p><strong>12.并没有自我保护机制</strong></p>
<h3 id="不同注册中心区别"><a href="#不同注册中心区别" class="headerlink" title="不同注册中心区别"></a>不同注册中心区别</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.CAP定理</span></span><br><span class="line"><span class="bullet">-</span> CAP定理：CAP定理又称CAP原则，指的是在一个分布式系统中，一致性（Consistency）、可用性</span><br><span class="line"><span class="bullet">-</span> （Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两</span><br><span class="line"><span class="bullet">-</span> 点，不可能三者兼顾。</span><br><span class="line"><span class="code">	`一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的</span></span><br><span class="line"><span class="code">	数据副本）</span></span><br><span class="line"><span class="code">	`可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用</span></span><br><span class="line"><span class="code">	性）</span></span><br><span class="line"><span class="code">	`分区容忍性（P），就是高可用性，一个节点崩了，并不影响其它的节点（100个节点，挂了几个，不影响服务，</span></span><br><span class="line"><span class="code">	越多机器越好）</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code"># 2.Eureka特点</span></span><br><span class="line"><span class="code">- Eureka中没有使用任何的数据强一致性算法保证不同集群间的Server的数据一致，仅通过数据拷贝的方式争取注册</span></span><br><span class="line"><span class="code">- 中心数据的最终一致性，虽然放弃数据强一致性但是换来了Server的可用性，降低了注册的代价，提高了集群运行</span></span><br><span class="line"><span class="code">- 的健壮性。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.Consul特点</span></span><br><span class="line"><span class="bullet">-</span> 基于Raft算法，Consul提供强一致性的注册中心服务，但是由于Leader节点承担了所有的处理工作，势必加大了注</span><br><span class="line"><span class="bullet">-</span> 册和发现的代价，降低了服务的可用性。通过Gossip协议，Consul可以很好地监控Consul集群的运行，同时可以方</span><br><span class="line"><span class="bullet">-</span> 便通知各类事件，如Leader选择发生、Server地址变更等。</span><br><span class="line"><span class="bullet">-</span> </span><br><span class="line"></span><br><span class="line"><span class="section"># 4.zookeeper特点</span></span><br><span class="line"><span class="bullet">-</span> 基于Zab协议，Zookeeper可以用于构建具备数据强一致性的服务注册与发现中心，而与此相对地牺牲了服务的可用</span><br><span class="line"><span class="bullet">-</span> 性和提高了注册需要的时间。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410184355695.png" alt="image-20240410184355695"></p>
<h2 id="微服务间通信方式"><a href="#微服务间通信方式" class="headerlink" title="微服务间通信方式"></a>微服务间通信方式</h2><h3 id="Rest-Template"><a href="#Rest-Template" class="headerlink" title="Rest Template"></a>Rest Template</h3><h4 id="Rest-Template通信"><a href="#Rest-Template通信" class="headerlink" title="Rest Template通信"></a>Rest Template通信</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 什么是微服务</span><br><span class="line">定义：基于单体应用围绕业务进行服务拆分,拆分出的每个服务独立项目,独立运行，他们独立部署运行在自己的计算机进程里,基于分布式的管理</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 如何解决微服务的服务间通信问题  在springcloud中服务间调用方式主要是使用 http restful方式进行服务间调用 可实现服务间高度解耦 不同语言开发的服务可是实现通信</span><br><span class="line"> a.Http Rest方式 使用http协议进行数据传递 JSON格式</span><br><span class="line"> b.RPC方式       远程过程调用            二进制</span><br><span class="line"> RPC传输效率远高于http OSI七层 物理层（高） 数据链路层 网络层 传输层（RPC）会话层 表示层 应用层（http）</span><br><span class="line"> </span><br><span class="line"><span class="bullet">3.</span> 如何在java代码中发起http方式请求</span><br><span class="line">spring框架提供的HttpClient对象 RestTemplate 发起一个http请求 RestTemplate就相当于一个http客户端即浏览器 spring框架提供的RestTemplate类可用于在应用中调用rest服务，它简化了与http服务的通信方式，统一了RESTful的标准，封装了http链接， 我们只需要传入url及返回值类型即可。相较于之前常用的HttpClient，RestTemplate是一种更优雅的调用RESTful服务的方式。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 实现服务间通信案例 基于RestTemplate的服务调用  以用户和订单服务为例</span><br><span class="line">   1.开发两个测试服务  users<span class="emphasis">_client orders_</span>client  两个服务都是两个独立的springboot应用 注意:这里服务仅仅用来测试,没有实际业务意义 </span><br><span class="line">   2.引入springboot依赖</span><br><span class="line"><span class="code">       &lt;dependency&gt;</span></span><br><span class="line"><span class="code">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line"><span class="code">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span></span><br><span class="line"><span class="code">        &lt;/dependency&gt;</span></span><br><span class="line"><span class="code">   3.提供springboot配置文件</span></span><br><span class="line"><span class="code">   users_client:</span></span><br><span class="line"><span class="code">       server.port=8888</span></span><br><span class="line"><span class="code">       spring.application.name=USERS </span></span><br><span class="line"><span class="code">   orders_client:</span></span><br><span class="line"><span class="code">       server.port=9999</span></span><br><span class="line"><span class="code">       spring.application.name=ORDERS</span></span><br><span class="line"><span class="code">   4.写入口类测试springboot是否可以启动</span></span><br><span class="line"><span class="code">   users_client:</span></span><br><span class="line"><span class="code">        package com.chabai;</span></span><br><span class="line"><span class="code">        import org.springframework.boot.SpringApplication;</span></span><br><span class="line"><span class="code">        import org.springframework.boot.autoconfigure.SpringBootApplication;</span></span><br><span class="line"><span class="code">        @SpringBootApplication</span></span><br><span class="line"><span class="code">        @EnableDiscoveryClient</span></span><br><span class="line"><span class="code">        public class UsersApplication &#123;</span></span><br><span class="line"><span class="code">            public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="code">                SpringApplication.run(UsersApplication.class,args);</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">   orders_client:</span></span><br><span class="line"><span class="code">        package com.chabai;</span></span><br><span class="line"><span class="code">        import org.springframework.boot.SpringApplication;</span></span><br><span class="line"><span class="code">        import org.springframework.boot.autoconfigure.SpringBootApplication;</span></span><br><span class="line"><span class="code">        @SpringBootApplication</span></span><br><span class="line"><span class="code">        @EnableDiscoveryClient</span></span><br><span class="line"><span class="code">        public class OrdersApplication &#123;</span></span><br><span class="line"><span class="code">            public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="code">                SpringApplication.run(OrdersApplication.class,args);</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">   5.引入consul客户端依赖 作用：能把当前服务注册到指定的consul服务注册中心 引入健康检查依赖</span></span><br><span class="line"><span class="code">        &lt;!--引入consul客户端依赖 discovery：服务注册和发现--&gt;</span></span><br><span class="line"><span class="code">        &lt;dependency&gt;</span></span><br><span class="line"><span class="code">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="code">            &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;</span></span><br><span class="line"><span class="code">        &lt;/dependency&gt;</span></span><br><span class="line"><span class="code">        &lt;!--引入健康检查依赖--&gt;</span></span><br><span class="line"><span class="code">        &lt;dependency&gt;</span></span><br><span class="line"><span class="code">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line"><span class="code">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span></span><br><span class="line"><span class="code">        &lt;/dependency&gt;</span></span><br><span class="line"><span class="code">   6.再次写配置文件</span></span><br><span class="line"><span class="code">   users_client:</span></span><br><span class="line"><span class="code">        server.port=8888</span></span><br><span class="line"><span class="code">        spring.application.name=USERS</span></span><br><span class="line"><span class="code">        spring.cloud.consul.host=localhost</span></span><br><span class="line"><span class="code">        spring.cloud.consul.port=8500</span></span><br><span class="line"><span class="code">        spring.cloud.consul.discovery.service-name=$&#123;spring.application.name&#125;#可不写都是默认的</span></span><br><span class="line"><span class="code">        spring.cloud.consul.discovery.register-health-check=true             #可不写都是默认的</span></span><br><span class="line"><span class="code">   orders_client:</span></span><br><span class="line"><span class="code">        server.port=9999</span></span><br><span class="line"><span class="code">        spring.application.name=ORDERS</span></span><br><span class="line"><span class="code">        spring.cloud.consul.host=localhost</span></span><br><span class="line"><span class="code">        spring.cloud.consul.port=8500</span></span><br><span class="line"><span class="code">        spring.cloud.consul.discovery.service-name=$&#123;spring.application.name&#125; #可不写都是默认的</span></span><br><span class="line"><span class="code">        spring.cloud.consul.discovery.register-health-check=true              #可不写都是默认的</span></span><br><span class="line"><span class="code">   7.在入口类加客户端注解@EnableDiscoveryClient(除eureka client) 让当前微服务作为一个服务客户端 进行微服务注册</span></span><br><span class="line"><span class="code">   8.启动服务并在consul界面查看服务信息 </span></span><br><span class="line"><span class="code">     成功==》服务已准备好</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412004103063.png" alt="image-20240412004103063"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">9.编写controller </span><br><span class="line">UsersController:</span><br><span class="line">  package com.chabai.controller;</span><br><span class="line">  import org.slf4j.Logger;</span><br><span class="line">  import org.slf4j.LoggerFactory;</span><br><span class="line">  import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">  import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">  import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">  @RestController</span><br><span class="line">  public class UsersController &#123;</span><br><span class="line"></span><br><span class="line"><span class="code">      private static final Logger log = LoggerFactory.getLogger(UsersController.class);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">      @GetMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="code">      public String invokeDemo() &#123;</span></span><br><span class="line"><span class="code">          log.info(&quot;user demo ...&quot;);</span></span><br><span class="line"><span class="code">          //1.调用订单服务 服务地址url：http://localhost:9999/order   必须是get方式 接收返回值 String类型</span></span><br><span class="line"><span class="code">          RestTemplate restTemplate = new RestTemplate();</span></span><br><span class="line"><span class="code">          String orderResult = restTemplate.getForObject(&quot;http://localhost:9999/order &quot;, String.class);</span></span><br><span class="line"><span class="code">          log.info(&quot;调用订单服务成功:&#123;&#125;&quot;,orderResult);//logi才能正常导入类</span></span><br><span class="line"><span class="code">          return &quot;调用订单服务成功,结果为：&quot;+orderResult;</span></span><br><span class="line"><span class="code">      &#125;</span></span><br><span class="line"><span class="code">  &#125;</span></span><br><span class="line"><span class="code">OrdersController:</span></span><br><span class="line"><span class="code">  package com.chabai.controller;</span></span><br><span class="line"><span class="code">  import org.slf4j.Logger;</span></span><br><span class="line"><span class="code">  import org.slf4j.LoggerFactory;</span></span><br><span class="line"><span class="code">  import org.springframework.web.bind.annotation.GetMapping;</span></span><br><span class="line"><span class="code">  import org.springframework.web.bind.annotation.RestController;</span></span><br><span class="line"><span class="code">  @RestController</span></span><br><span class="line"><span class="code">  public class OrdersController &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">      private static final Logger log = LoggerFactory.getLogger(OrdersController.class);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">      @GetMapping(&quot;order&quot;)</span></span><br><span class="line"><span class="code">      public String demo()&#123;</span></span><br><span class="line"><span class="code">          log.info(&quot;order demo ...&quot;);</span></span><br><span class="line"><span class="code">          return &quot;order demo  ok&quot;;</span></span><br><span class="line"><span class="code">      &#125;</span></span><br><span class="line"><span class="code">  &#125; </span></span><br></pre></td></tr></table></figure>

<p><strong>10.Spring中对REST请求的处理方式</strong>  延申了解即可不是重点</p>
<blockquote>
<p>深入了解可参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lasdaybg/p/10180201.html">Spring中RestTemplate的使用方法 - lasdaybg - 博客园 (cnblogs.com)</a></p>
</blockquote>
<p>Spring中可以使用RestTemplate来操作REST资源，主要包含以下几个方法：</p>
<ul>
<li>getForEntity()，getForObject()，发送HTTP GET请求，getForEntity()返回的是ResponseEntity对象，里面包含响应实体对象及响应状态码，而getForObject()则直接返回响应实体对象；</li>
<li>postForEntity()，postForObject()，发送HTTP POST请求，postForEntity()返回的是ResponseEntity对象，里面包含响应实体对象及响应状态码，而postForObject()则直接返回响应实体对象；</li>
<li>put()，发送HTTP PUT请求；</li>
<li>delete()，发送HTTP DELETE请求；</li>
<li>exchange()，可以发送GET、POST、PUT和DELETE中的任意一种请求，同时还可以自定义请求头。</li>
</ul>
<p><strong>11.启动两个服务 访问:<a target="_blank" rel="noopener" href="http://localhost:8888/user">http://localhost:8888/user</a>  成功实现通信 如下：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412004535371.png" alt="image-20240412004535371"></p>
<p><strong>12.使用Rest Template对象实现服务间通信存在的问题</strong></p>
<p>Rest Template是直接基于服务地址调用没有在服务注册中心获取服务,也没有办法完成服务的负载均衡如果需要实现服务的负载均衡需要自己书写服务负载均衡策略</p>
<h4 id="使用RestTemplate通信存在的问题"><a href="#使用RestTemplate通信存在的问题" class="headerlink" title="使用RestTemplate通信存在的问题"></a>使用RestTemplate通信存在的问题</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412105119245.png" alt="image-20240412105119245"></p>
<h4 id="解决负载均衡问题"><a href="#解决负载均衡问题" class="headerlink" title="解决负载均衡问题"></a>解决负载均衡问题</h4><h5 id="自定义负载均衡"><a href="#自定义负载均衡" class="headerlink" title="自定义负载均衡"></a>自定义负载均衡</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chabai.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsersController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(UsersController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">invokeDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;user demo ...&quot;</span>);</span><br><span class="line">        <span class="comment">//1.调用订单服务 服务地址url：randomHost()随机生成   必须是get方式 接收返回值 String类型</span></span><br><span class="line">        <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">orderResult</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;http://&quot;</span>+randomHost()+<span class="string">&quot;/order&quot;</span>, String.class);</span><br><span class="line">        log.info(<span class="string">&quot;调用订单服务成功:&#123;&#125;&quot;</span>,orderResult);<span class="comment">//logi才能正常导入类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;调用订单服务成功,结果为：&quot;</span>+orderResult;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义随机策略</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">randomHost</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;String&gt; hosts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        hosts.add(<span class="string">&quot;localhost:9999&quot;</span>);  <span class="comment">//假设有两个订单服务</span></span><br><span class="line">        hosts.add(<span class="string">&quot;localhost:9990&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成随机数 只能在0-hosts.size()波动</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(host.size());</span><br><span class="line">        <span class="keyword">return</span> host.get(i);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Ribbon负载均衡客户端组件"><a href="#Ribbon负载均衡客户端组件" class="headerlink" title="Ribbon负载均衡客户端组件"></a>Ribbon负载均衡客户端组件</h5><blockquote>
<p>spring基于neflix开源组件进行的封装 springcloud-netflix-ribbon netflix的组件        作用：用来实现请求调用时负载均衡</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> 官方网址：https://github.com/Netflix/ribbon</span><br><span class="line"><span class="bullet">-</span> Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用</span><br></pre></td></tr></table></figure>

<p><strong>1.Rubbon组件实现负载均衡原理</strong></p>
<p>根据调用服务的服务id去服务注册中心获取对应服务id的服务列表，并将服务列表拉取到本地进行缓存，然后在本地通过默认的轮询的负载均衡策略在现有的列表中选择一个可用的节点提供服务，图解如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412122231163.png" alt="image-20240412122231163"></p>
<p>注：如果刚缓存到本地其中一台服务器down了，如果轮询又刚好到这台服务器，那么本次请求失败</p>
<p><strong>2.使用Ribbon组件+RestTemplate实现请求的负载均衡调用</strong>  以用户和订单服务为例</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 2.0场景:使用用户服务调用订单服务 </span></span><br><span class="line"><span class="section"># 2.1用户服务引入ribbon依赖</span></span><br><span class="line"><span class="bullet">-</span> 如果使用的是eureka client 和 consul client,无须引入依赖,因为在eureka,consul客户端依赖 中默认集成了ribbon组件</span><br><span class="line"><span class="bullet">-</span> 如果使用的client中没有ribbon依赖需要显式引入如下依赖</span><br><span class="line">   &lt;!--引入ribbon依赖--&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="code">     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="code">     &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;</span></span><br><span class="line"><span class="code">   &lt;/dependency&gt;</span></span><br><span class="line"><span class="code"># 2.2使用RestTemplate + ribbon 进行服务调用并实现负载均衡 三种方法</span></span><br><span class="line"><span class="code">- DisvoveryClient       </span></span><br><span class="line"><span class="code">- LoadBalanceClient </span></span><br><span class="line"><span class="code">- @LoadBalance</span></span><br><span class="line"><span class="code">- consul客户端依赖已集成ribbon组件 故我们一启动springboot工厂就会有DisvoveryClient、LoadBalanceClient 对象 如果我们要使用这两个对象直接注入就可以了</span></span><br><span class="line"><span class="code"># 2.2.1Discoveryclient   服务注册发现客户端对象</span></span><br><span class="line"><span class="code">- discoveryclient 服务发现对象 根据服务id去服务注册中心获取对应的服务列表到本地中</span></span><br><span class="line"><span class="code">- 缺点:没有负载均衡，需要自己实现负载均衡</span></span><br><span class="line"><span class="code">注:ribbon只是一个负载均衡客户端 不负责发请求 发请求还是要用RestTemplate</span></span><br><span class="line"><span class="code">代码实现如下:</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chabai.controller;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.DiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsersController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(UsersController.class);</span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient; <span class="comment">//服务注册发现客户端对象</span></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//现在spring推荐我们使用构造器注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UsersController</span><span class="params">(DiscoveryClient discoveryClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.discoveryClient = discoveryClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">invokeDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;user demo ...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.使用ribbon组件+RestTemplate实现负载均衡调用</span></span><br><span class="line">        <span class="comment">//2.1使用Discoveryclient   进行客户端调用</span></span><br><span class="line">        <span class="comment">//获取服务列表到本地</span></span><br><span class="line">        List&lt;ServiceInstance&gt; serviceInstances = discoveryClient.getInstances(<span class="string">&quot;ORDERS&quot;</span>);<span class="comment">//写服务名大小写均可</span></span><br><span class="line">        serviceInstances.forEach(serviceInstance -&gt; log.info(<span class="string">&quot;服务主机:&#123;&#125; 服务端口:&#123;&#125; 服务地址:&#123;&#125;&quot;</span>,serviceInstance.getHost(),serviceInstance.getPort(),serviceInstance.getUri()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用RestTemplate进行微服务间通信</span></span><br><span class="line">        <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(serviceInstances.get(<span class="number">0</span>).getUri() + <span class="string">&quot;/order&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">//String result = new RestTemplate().getForObject(serviceInstances.get(0).getUri()+ &quot;/order&quot;, String.class); 也可合并这样写</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>+ result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 2.2.2loadBalanceClient 负载均衡的客户端对象</span></span><br><span class="line"><span class="bullet">-</span> LoadBalancerClient 负载均衡对象客户端，根据服务id去服务注册中心获取服务列表，根据默认负载均衡策略，选择  列表中一台机器进行返回</span><br><span class="line"><span class="bullet">-</span> 缺点：使用时需要每次先根据服务id获取一个负载均衡机器之后再通过restTemplate调用服务</span><br><span class="line">代码实现如下:</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chabai.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalancerClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsersController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(UsersController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient; <span class="comment">//负载均衡的客户端对象</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">invokeDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;user demo ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ServiceInstance</span> <span class="variable">serviceInstance</span> <span class="operator">=</span> loadBalancerClient.choose(<span class="string">&quot;ORDERS&quot;</span>); <span class="comment">//默认负载均衡策略轮询策略</span></span><br><span class="line">        log.info(<span class="string">&quot;服务主机:&#123;&#125; 服务端口:&#123;&#125; 服务地址:&#123;&#125;&quot;</span>,serviceInstance.getHost(),serviceInstance.getPort(),serviceInstance.getUri());</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>().getForObject(serviceInstance.getUri()+ <span class="string">&quot;/order&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span> + result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412161010608.png" alt="image-20240412161010608"><br>可以看出就是轮询的方式跳转</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 2.2.3@LoadBalanced      负载均衡的客户端注解</span></span><br><span class="line"><span class="bullet">-</span> @LoadBalance 负载均衡客户端注解</span><br><span class="line"><span class="bullet">-</span> 修饰范围：作用在方法上</span><br><span class="line"><span class="bullet">-</span> 作用: 让当前方法|当前对象具有负载均衡特性</span><br><span class="line">代码实现如下：</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建配置类   src&#x2F;main&#x2F;com&#x2F;chabai&#x2F;config&#x2F;Beanconfig</p>
<p>使用RestTemplate()每次都需要我们new RestTemplate()太麻烦  我们可以把它交给工厂管理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chabai.config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">//代表这是一个springboot配置类  相当于 spring.xml ==&gt;工厂 创建对象 bean id class=&quot;&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工厂中创建restTemplate  日后使用 声明为成员变量注入即可</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span> <span class="comment">//使对象具有ribbon的负载均衡特性</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>@LoadBalanced注解使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.chabai.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsersController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(UsersController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">invokeDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;user demo ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.3@LoadBalanced 作用:使对象具有ribbon的负载均衡特性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;http://ORDERS/order&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span> + result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Ribbon组件细节"><a href="#Ribbon组件细节" class="headerlink" title="Ribbon组件细节"></a>Ribbon组件细节</h4><p><strong>Ribbon组件支持哪些负载均衡策略</strong></p>
<p>追负载均衡源码追出支持哪些负载均衡策略</p>
<p><strong>首先分析如何追：</strong></p>
<p>追逐注解源码无意义 注解在java中就是一个标识 它里边不会具体写出负载均衡策略是什么</p>
<p>再次分析可发现负载均衡是在LoadBalancerClient类的choose()方法实现的 </p>
<p>**第一步:**查看LoadBalancerClient源码发现没有实现choose()方法，再看继承的父类有choose()方法但没有具体实现故choose()方法只能是LoadBalancerClient的子类实现的，选中LoadBalancerClient ctrl+h查看继承关系 发现有两个子类，只有可能是这两个子类实现的choose()方法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412220549899.png" alt="image-20240412220549899"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412220614144.png" alt="image-20240412220614144"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412220354948.png" alt="image-20240412220354948"></p>
<p>**第二步:**进入两个子类ctrl+f12发现都实现了choose()方法 我们无法判断默认是在哪个子类的choose()方法实现的负载均衡</p>
<p><strong>第三步：</strong>到这里 无法判断是哪个 追不下去了 可返回第一步打断点调试 看默认实现类是哪个 发现是choose()方法的默认实现类是RibbonLoadBalancerClient </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412213135018.png" alt="image-20240412213135018"></p>
<p>**第四步:**进入RibbonLoadBalancerClient ctrl+12查看文件结构  找到Choose方法 分析发现负载均衡具体在RibbonLoadBalancerClientl类的getServer()方法里面实现</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412210047792.png" alt="image-20240412210047792"></p>
<p><strong>第五步</strong>:查看getServer()源码 发现是在ILoadBalancer的chooseServer()方法实现负载均衡的 点进去ILoadBalancer()查看源码 发现ILoadBalancer并没有实现chooseServer()方法 故只可能是父类实现的chooseServer()方法   我们查看chooseServer()的实现类 发现有三个实现类 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412210501874.png" alt="image-20240412210501874"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412210902821.png" alt="image-20240412210902821"></p>
<p>**第六步:**到这里 无法判断是哪个 追不下去了 可返回第五步打断点调试 看默认实现类是哪个</p>
<p>打断点 调试 f7进入方法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412222450797.png" alt="image-20240412222450797"></p>
<p>f8下一步 发现进入ZoneAwareLoadBalancer类但是别急 继续f8 发现有这么一段代码 return super.chooseServer(key) super代表返回父类的方法  我们查看父类DynamicServerListLoadBalancer发现没有chooseServer()方法，那么就只能是父类的父类BaseLoadBalancer实现的chooseServer()方法，我们查看BaseLoadBalancer类 发现确实是BaseLoadBalancer类实现的chooseServer()方法，我们也可以通过f7进入方法 发现确实是进入了BaseLoadBalancer类也确实是这个类实现chooseServer()方法 完全匹配我们追父类时的猜想。调试验证的图片如下，追父类就不给出图片了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412224910771.png" alt="image-20240412224910771"></p>
<p>**第七步:**继续调试f8到return this.rule.choose(key) 发现是底层的规则做的负载均衡</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412225438968.png" alt="image-20240412225438968"></p>
<p>我们f7进入规则 f8下一步到 Optional<Server> server &#x3D; this.getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(), key)  这句的意思就是根据传的key从所有规则获取一种规则给我们 此时的key是default 即采用默认规则</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412225913226.png" alt="image-20240412225913226"></p>
<p>我们返回BaseLoadBalancer找看这个rule即规则到底是什么</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412230431095.png" alt="image-20240412230431095"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412230454820.png" alt="image-20240412230454820"></p>
<p>从而我们可以推出默认负载均衡策略是RoundRobinRule轮询 且真正决定负载均衡策略的是IRule这个接口</p>
<p>**第八步:**根据private static final IRule DEFAULT_RULE &#x3D; new RoundRobinRule()可知看IRule这个接口有哪些实现类即可看出有哪些负载均衡策略</p>
<p>选中IRule右键 图表 显示图  新面板 右键 将类添加到图 选择IRule 双击添加 选中IRule右键添加实现添加完所有实现即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412232122765.png" alt="image-20240412232122765"></p>
<table>
<thead>
<tr>
<th><strong>内置负载均衡规则类</strong></th>
<th>名称</th>
<th><strong>规则描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RoundRobinRule</td>
<td>轮询策略</td>
<td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。按顺序循环选择server</td>
</tr>
<tr>
<td>AvailabilityFilteringRule</td>
<td>可过滤策略</td>
<td>对以下两种服务器进行忽略： （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的..ActiveConnectionsLimit属性进行配置。</td>
</tr>
<tr>
<td>WeightedResponseTimeRule</td>
<td>响应时间加权测率</td>
<td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>
</tr>
<tr>
<td>ZoneAvoidanceRule</td>
<td>区域敏感性策略</td>
<td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td>
</tr>
<tr>
<td>BestAvailableRule</td>
<td>最低并发策略</td>
<td>忽略那些短路的服务器，并选择并发数较低的服务器。</td>
</tr>
<tr>
<td>RandomRule</td>
<td>随机策略</td>
<td>随机选择一个可用的服务器。</td>
</tr>
<tr>
<td>RetryRule</td>
<td>重试策略</td>
<td>重试机制的选择逻辑</td>
</tr>
</tbody></table>
<p><strong>负载均衡原理</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410184605069.png" alt="image-20240410184605069"><br>基本流程如下：</p>
<ul>
<li>拦截我们的RestTemplate请求<a target="_blank" rel="noopener" href="http://userservice/user/1">http://userservice/user/1</a></li>
<li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li>
<li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li>
<li>eureka返回列表，localhost:8081、localhost:8082</li>
<li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li>
<li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a target="_blank" rel="noopener" href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li>
</ul>
<p><strong>修改服务的默认负载均衡策略</strong></p>
<blockquote>
<p>方式一:修改配置类或在启动类定义一个新的IRule</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方式二 :配置文件方式 推荐</p>
</blockquote>
<p>在user-service的application.yml文件中</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改用户服务调用订单服务默认负载均衡策略不在使用轮询 使用随机策略 写全限命名 复制引用即可</span></span><br><span class="line"><span class="attr">ORDERS.ribbon.NFLoadBalancerRuleClassName</span>=<span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure>

<p>两者区别，方式一是访问所有服务都是随机，方式二是访问userservice这一种服务是随机</p>
<blockquote>
<p>如果方式一想要特殊化定制,这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下</p>
</blockquote>
<p>放在启动类扫描的包外面</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.<span class="property">netflix</span>.<span class="property">loadbalancer</span>.<span class="property">IRule</span>;</span><br><span class="line"><span class="keyword">import</span> com.<span class="property">netflix</span>.<span class="property">loadbalancer</span>.<span class="property">RandomRule</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">context</span>.<span class="property">annotation</span>.<span class="property">Bean</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">context</span>.<span class="property">annotation</span>.<span class="property">Configuration</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Configuration</span></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">MySelfRule</span> &#123;</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Bean</span></span><br><span class="line">    public <span class="title class_">IRule</span> <span class="title function_">myRule</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上@RibbonClient注解 name是服务名称，configuration是配置类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.<span class="property">lun</span>.<span class="property">myrule</span>.<span class="property">MySelfRule</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">boot</span>.<span class="property">SpringApplication</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">boot</span>.<span class="property">autoconfigure</span>.<span class="property">SpringBootApplication</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">cloud</span>.<span class="property">netflix</span>.<span class="property">eureka</span>.<span class="property">EnableEurekaClient</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">cloud</span>.<span class="property">netflix</span>.<span class="property">ribbon</span>.<span class="property">RibbonClient</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">SpringBootApplication</span></span><br><span class="line">@<span class="title class_">EnableEurekaClient</span></span><br><span class="line"><span class="comment">//添加到此处</span></span><br><span class="line">@<span class="title class_">RibbonClient</span>(name = <span class="string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>, configuration = <span class="title class_">MySelfRule</span>.<span class="property">class</span>)</span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">OrderMain80</span></span><br><span class="line">&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"> <span class="built_in">String</span>[] args </span>)&#123;</span><br><span class="line">        <span class="title class_">SpringApplication</span>.<span class="title function_">run</span>(<span class="title class_">OrderMain80</span>.<span class="property">class</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>饥饿加载</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</span><br><span class="line"></span><br><span class="line">而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</span><br><span class="line"><span class="number">123</span></span><br><span class="line">ribbon:</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line">    clients: userservice</span><br></pre></td></tr></table></figure>

<p><strong>Ribbon默认负载轮询算法原理</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">默认负载轮训算法: rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标，每次服务重启动后rest接口计数从1开始。</span><br><span class="line"></span><br><span class="line">List instances = discoveryClient.getInstances(“CLOUD-PAYMENT-SERVICE”);</span><br><span class="line"></span><br><span class="line">如:</span><br><span class="line"></span><br><span class="line">List [0] instances = 127.0.0.1:8002</span><br><span class="line">List [1] instances = 127.0.0.1:8001</span><br><span class="line">8001+ 8002组合成为集群，它们共计2台机器，集群总数为2，按照轮询算法原理：</span><br><span class="line"></span><br><span class="line">当总请求数为1时:1%2=1对应下标位置为1，则获得服务地址为127.0.0.1:8001</span><br><span class="line">当总请求数位2时:2%2=О对应下标位置为0，则获得服务地址为127.0.0.1:8002</span><br><span class="line">当总请求数位3时:3%2=1对应下标位置为1，则获得服务地址为127.0.0.1:8001</span><br><span class="line">当总请求数位4时:4%2=О对应下标位置为0，则获得服务地址为127.0.0.1:8002</span><br><span class="line">如此类推…</span><br></pre></td></tr></table></figure>

<h4 id="Ribbon组件停止维护"><a href="#Ribbon组件停止维护" class="headerlink" title="Ribbon组件停止维护"></a>Ribbon组件停止维护</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Ribbon组件现在状态</span></span><br><span class="line"><span class="bullet">-</span> https://github.com/Netflix/ribbon</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240412234628178.png" alt="image-20240412234628178"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># ribbon-core ribbon-loadbalancer 依然在大规模生产实践中部署 意味着日后如果实现服务间通信负载均衡依然使用ribbon组件</span></span><br></pre></td></tr></table></figure>

<h4 id="未解决问题-代码写死"><a href="#未解决问题-代码写死" class="headerlink" title="未解决问题:代码写死"></a>未解决问题:代码写死</h4><p>解决负载均衡问题，但是没有解决路径写死问题，还是不利于我们的维护</p>
<h4 id="前边两大组件快速回顾"><a href="#前边两大组件快速回顾" class="headerlink" title="前边两大组件快速回顾"></a>前边两大组件快速回顾<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240413141633592.png" alt="image-20240413141633592"></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240413141351478.png" alt="image-20240413141351478"></p>
<h3 id="OpenFeign-组件"><a href="#OpenFeign-组件" class="headerlink" title="OpenFeign 组件"></a>OpenFeign 组件</h3><blockquote>
<p>实现服务间通信组件 属于spring</p>
</blockquote>
<h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># OpenFeign组件历史</span></span><br><span class="line"><span class="bullet">-</span> Feign(neflix) --&gt; 维护状态--&gt;OpenFeign(spring)   特性和使用方式一摸一样</span><br><span class="line"><span class="section"># 什么是Feign组件</span></span><br><span class="line"><span class="bullet">-</span> OpenFeign组件一个Rest Client相当于http client 和RestTemplate作用一样都是http client 但不同的是RestTemplate是Http客户端而OpenFeign是伪Http客户端。需要我们给底层声明。</span><br><span class="line"><span class="bullet">-</span> Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性(可以使用springmvc的注解)，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，默认实现了负载均衡的效果并且springcloud为feign添加了springmvc注解的支持。</span><br><span class="line"><span class="bullet">-</span> 伪Http客户端: OpenFeign确实可以帮我们发请求，但是真正帮我们发请求发的不是它，是它底层包裹的spring框架提供的HttpClient对象RestTemplate发起的http请求(可结合服务器和代理服务器理解)。</span><br><span class="line"><span class="section"># 为什么OpenFeign</span></span><br><span class="line"><span class="bullet">-</span> OpenFeign优势</span><br><span class="line"><span class="code">	封装后使服务间通信变得简单:</span></span><br><span class="line"><span class="code">	  1.使用:写一个接口 加一个注解</span></span><br><span class="line"><span class="code">	  2.调用服务代码:自动完成数据传递过程对象转换</span></span><br><span class="line"><span class="code">	默认集成了Ribbon，默认实现了负载均衡的效果</span></span><br><span class="line"><span class="code">- 解决了RestTemplate+Ribbon的存在问题所有问题</span></span><br><span class="line"><span class="code">	  1.路径写死引起的代码冗余 维护成本增高</span></span><br><span class="line"><span class="code">	  2.使用不灵活 不能自动转换响应结果为对应对象</span></span><br><span class="line"><span class="code">	  3.必须使用Ribbon实现负载均衡</span></span><br><span class="line"><span class="code"># 现在实现服务间通信的方法</span></span><br><span class="line"><span class="code">- RestTemplate</span></span><br><span class="line"><span class="code">- RestTemplate+Ribbon</span></span><br><span class="line"><span class="code">- OpenFeign </span></span><br><span class="line"><span class="code"># 为什么说OpenFeign使用起来麻烦呢？</span></span><br><span class="line"><span class="code">OpenFeign不是一个真正的http client，使用时好多东西都需要我们显示的去给它指定 </span></span><br><span class="line"><span class="code">要想使用它好的特性 就要学会适应它的麻烦</span></span><br></pre></td></tr></table></figure>

<h4 id="OpenFeign组件使用"><a href="#OpenFeign组件使用" class="headerlink" title="OpenFeign组件使用"></a>OpenFeign组件使用</h4><blockquote>
<p>以商品和类别服务为例 让类别服务调用商品服务</p>
</blockquote>
<blockquote>
<p>创建两个独立的springboot应用  并注册到服务注册中心 consul</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0.启动服务注册中心consul</span><br><span class="line">1.在父模块新建两个maven空项目 分别为 categorie<span class="emphasis">_client product_</span>client</span><br><span class="line">2.引入springboot依赖 引完依赖别忘了import change</span><br><span class="line">3.引入springboot配置文件 注:这里可把后续需做的配置能提前写的可先写一下 端口号和服务名最好先配下</span><br><span class="line">4.构建入口类测试springboot应用是否可以正常启动</span><br><span class="line">5.引入服务注册中心consul和健康检查依赖 引完依赖别忘了import change</span><br><span class="line">6.写配置注册到consul server</span><br><span class="line">7.在入口类加注解@EnableDiscoveryClient 开启服务注册 并测试是否可以正常注册到consul</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用OpenFeign进行服务调用 </p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">8.开发服务接口(controller) 在里边写服务 ProductController CategoryController</span><br><span class="line">9.先不进行服务调用测试两个服务接口是否正常</span><br><span class="line">10.在服务调用方引入依赖OpenFeign 即在类别服务引入</span><br><span class="line">11.在服务调用方入口类加入注解@EnableFeignClients 开启Feign客户端调用支持 </span><br><span class="line">12.实现服务调用: 写接口加注解 回到CategoryController实现真正调用商品服务  </span><br><span class="line"><span class="bullet">-</span> 要单独写接口故我们要新建包放这个接口 com/chabai/feignclient 命名调用服务名+Client 这个接口不是一个普通的接口是一个<span class="code">`fegin接口`</span>， 我们要把要将来要调用服务的方法声明到这个接口</span><br><span class="line"><span class="bullet">-</span> 加注解  注解包含调用服务服务的id  这个注解写完这个接口就被工厂托管了</span><br><span class="line">如:@FeignClient(value=&quot;PRODUCT&quot;) //value:用来书写调用服务的服务id 可不写value</span><br><span class="line"><span class="bullet">-</span> 写接口 即写被调用商品服务的客户端 接口只声明不实现 声明被调用商品服务接口即可，日后这个接口的方法都会通过openfegin来通信，其实底层还是使用RestTemplate</span><br><span class="line">如:商品服务里此时只有product服务 get请求方式 我们可以这样写接口 </span><br><span class="line">package com.chabai.feignclient;</span><br><span class="line">import org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">//声明调用商品服务接口</span><br><span class="line">@FeignClient(value=&quot;PRODUCT&quot;) //value:用来书写调用服务的服务id 可不写value</span><br><span class="line">public interface ProductClient &#123;</span><br><span class="line"><span class="code">    //声明调用商品服务中的produc接口</span></span><br><span class="line"><span class="code">    @GetMapping(&quot;/product&quot;)</span></span><br><span class="line"><span class="code">    public String product(); //声明方法和服务路径和被调用服务方法和服务路径一样即可</span></span><br><span class="line"><span class="code">                             //返回值和形参列表和路径必须一致，方法名可以不一致 public也可不写</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">**这个被调用商品服务的客户端主要是基于SpringMVC的注解来声明远程调用的信息**，比如：</span></span><br><span class="line"><span class="code">- 服务名称：PRODUCT</span></span><br><span class="line"><span class="code">- 请求方式：GET</span></span><br><span class="line"><span class="code">- 请求路径：/product</span></span><br><span class="line"><span class="code">- 请求参数：xxx</span></span><br><span class="line"><span class="code">- 返回值类型：String</span></span><br><span class="line"><span class="code">这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> 回到CategoryController调用商品服务中的produc接口</span><br><span class="line">我们希望在这里调用商品服务,故回到这里,因为我们已有被调用商品服务的客户端，故直接注入即可，最后调用其里边需要调用的方法即可完成调用</span><br><span class="line">package com.chabai.controller;</span><br><span class="line">import com.chabai.feignclient.ProductClient;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">@RestController</span><br><span class="line">public class CategoryController &#123;</span><br><span class="line"><span class="code">    private static final Logger log = LoggerFactory.getLogger(CategoryController.class);</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    @Autowired</span></span><br><span class="line"><span class="code">    private ProductClient productClient;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    @GetMapping(&quot;/category&quot;)</span></span><br><span class="line"><span class="code">    public String category()&#123;</span></span><br><span class="line"><span class="code">        log.info(&quot;category service ...&quot;);</span></span><br><span class="line"><span class="code">        String product = productClient.product();</span></span><br><span class="line"><span class="code">        return &quot;category ok&quot; +product;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">13.测试是否成功调用服务</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">14.测试负载均衡  默认实现了负载均衡</span><br><span class="line"><span class="bullet">-</span> 使用idea快速创建功能再创建一个 商品服务节点</span><br><span class="line"><span class="bullet">-</span> 发现确实实现了负载均衡</span><br></pre></td></tr></table></figure>

<h4 id="服务间通信之参数传递"><a href="#服务间通信之参数传递" class="headerlink" title="服务间通信之参数传递"></a>服务间通信之参数传递</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 微服务架构中服务间通信手段？</span></span><br><span class="line">http协议:   springcloud:   1.RestTeamplate   2.OpenFegin(推荐) </span><br><span class="line"><span class="section"># 服务间通信之参数传递</span></span><br><span class="line">服务和服务之间通信,不仅仅是调用,往往在调用过程中还伴随着参数传递,接下来重点来看看OpenFeign在调用服务时如何传递参数</span><br><span class="line"><span class="section"># 参数传递类型</span></span><br><span class="line"><span class="bullet">-</span> 传递零散类型参数</span><br><span class="line"><span class="bullet">-</span> 传递对象类型</span><br><span class="line"><span class="bullet">-</span> 数组或集合类型</span><br><span class="line"><span class="section"># 流程</span></span><br><span class="line">我们执行CategoryController 执行到productClient.test(&quot;茶白&quot;, 22) 开始执行调用伴随着参数传递 openfegin会根据我们在feignclient的声明参数，传递类型和接口 底层进行一系列的加工成对应请求 ProductController里接到请求会有对应接口做出处理 最终完成伴随着参数传递的调用</span><br></pre></td></tr></table></figure>

<h5 id="零散类型传递"><a href="#零散类型传递" class="headerlink" title="零散类型传递"></a>零散类型传递</h5><blockquote>
<p>如: 八种基本类型 + String + 日期类型 </p>
</blockquote>
<p><strong>querystring方式传递参数  ?name&#x3D;chabai</strong></p>
<blockquote>
<p>注意:在openfegin接口声明中必须给参数加入注解@RequestParm指明传递方式为querystring方式</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 在被调用服务的接口即商品接口里定义一个接收零散类型参数接口 接收?name=xxx&amp;age=xxx方式请求传递的参数  ProductController</span><br><span class="line"><span class="code">        package com.chabai.controller;</span></span><br><span class="line"><span class="code">        import org.slf4j.Logger;</span></span><br><span class="line"><span class="code">        import org.slf4j.LoggerFactory;</span></span><br><span class="line"><span class="code">        import org.springframework.beans.factory.annotation.Value;</span></span><br><span class="line"><span class="code">        import org.springframework.web.bind.annotation.GetMapping;</span></span><br><span class="line"><span class="code">        import org.springframework.web.bind.annotation.RestController;</span></span><br><span class="line"><span class="code">        @RestController</span></span><br><span class="line"><span class="code">        public class ProductController &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            private static final Logger log = LoggerFactory.getLogger(ProductController.class);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            @Value(&quot;$&#123;server.port&#125;&quot;) //属性注入 注解方式</span></span><br><span class="line"><span class="code">            private int port;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            //定义一个接收零散类型参数接口 接收?name=xxx&amp;age=xxx方式传递的参数</span></span><br><span class="line"><span class="code">            @GetMapping(&quot;test&quot;)</span></span><br><span class="line"><span class="code">            //默认把?后的参数赋值变量 可不加@RequestParam(&quot;name&quot;)</span></span><br><span class="line"><span class="code">            public String test(String name,Integer age)&#123;</span></span><br><span class="line"><span class="code">                log.info(&quot;name: &#123;&#125; age: &#123;&#125;&quot;,name,age);</span></span><br><span class="line"><span class="code">                return &quot;test ok ,当前服务的端口为:&quot;+port;</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">2. 声明调用商品服务中的test接口name,age参数     ProductClient</span></span><br><span class="line"><span class="code">        package com.chabai.feignclient;</span></span><br><span class="line"><span class="code">        import org.springframework.cloud.openfeign.FeignClient;</span></span><br><span class="line"><span class="code">        import org.springframework.web.bind.annotation.GetMapping;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        //声明调用商品服务接口</span></span><br><span class="line"><span class="code">        @FeignClient(value=&quot;PRODUCT&quot;) //value:用来书写调用服务的服务id 可不写value</span></span><br><span class="line"><span class="code">        public interface ProductClient &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            //声明调用商品服务中test接口传递name,age参数</span></span><br><span class="line"><span class="code">            @GetMapping(&quot;test&quot;)</span></span><br><span class="line"><span class="code">            String test(String name,Integer age);</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">3. 回到CategoryController调用商品服务中的test接口传递参数</span></span><br><span class="line"><span class="code">        package com.chabai.controller;</span></span><br><span class="line"><span class="code">        import com.chabai.feignclient.ProductClient;</span></span><br><span class="line"><span class="code">        import org.slf4j.Logger;</span></span><br><span class="line"><span class="code">        import org.slf4j.LoggerFactory;</span></span><br><span class="line"><span class="code">        import org.springframework.beans.factory.annotation.Autowired;</span></span><br><span class="line"><span class="code">        import org.springframework.web.bind.annotation.GetMapping;</span></span><br><span class="line"><span class="code">        import org.springframework.web.bind.annotation.RestController;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        @RestController</span></span><br><span class="line"><span class="code">        public class CategoryController &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            private static final Logger log = LoggerFactory.getLogger(CategoryController.class);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            @Autowired</span></span><br><span class="line"><span class="code">            private ProductClient productClient;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            @GetMapping(&quot;/category&quot;)</span></span><br><span class="line"><span class="code">            public String category()&#123;</span></span><br><span class="line"><span class="code">                log.info(&quot;category service ...&quot;);</span></span><br><span class="line"><span class="code">                String result = productClient.test(&quot;茶白&quot;, 22); //注 我们这里写死是为了演示以后跟业务整合可把业务对象值传过来，或者利用category方法接收的参数</span></span><br><span class="line"><span class="code">                return &quot;category ok &quot; +result;</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">4. 启动CategoryController服务会报错:test()方法不让我们传递多参数</span></span><br><span class="line"><span class="code">“Method has too many Body parameters”</span></span><br><span class="line"><span class="code">- 解释：类别服务调用商品服务，要用到openfegin来通信，但是openfegin是一个伪http client,底层有可能走的还是RestTemplate对象(真正的http client),传参的时候懵了，它是接受这个参数的，但是底层要用真实的http client对象传这个参，底层压根不知道这个参数是哪种方法传过来的，无法组织(零散类型传参有两种方式,底层无法判断,没有组织参数能力,没有浏览器聪明),</span></span><br><span class="line"><span class="code">- 但注意传一个参数不会报错，当只有一个参数时底层不用加注解默认走的是?方式传递参数 </span></span><br><span class="line"><span class="code">- 日后我们不管几个参数，都明确告诉要怎么传</span></span><br><span class="line"><span class="code">5. 解决办法</span></span><br><span class="line"><span class="code">- 在openfegin接口声明中必须给参数加入注解@RequestParm指明传递方式为?name=chabai</span></span><br><span class="line"><span class="code">代码如下:</span></span><br><span class="line"><span class="code">- 声明调用商品服务中的test接口传递name,age参数 显性声明以querystring方式传递</span></span><br><span class="line"><span class="code">        package com.chabai.feignclient;</span></span><br><span class="line"><span class="code">        import org.springframework.cloud.openfeign.FeignClient;</span></span><br><span class="line"><span class="code">        import org.springframework.web.bind.annotation.GetMapping;</span></span><br><span class="line"><span class="code">        import org.springframework.web.bind.annotation.RequestParam;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        //声明调用商品服务接口</span></span><br><span class="line"><span class="code">        @FeignClient(value=&quot;PRODUCT&quot;) //value:用来书写调用服务的服务id 可不写value</span></span><br><span class="line"><span class="code">        public interface ProductClient &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            //声明调用商品服务中test接口传递name,age参数 以querystring方式传递</span></span><br><span class="line"><span class="code">            @GetMapping(&quot;test&quot;)</span></span><br><span class="line"><span class="code">            //底层在组织的时候以?name=xxx&amp;age=xxx方式拼到test后边作为请求</span></span><br><span class="line"><span class="code">            String test(@RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;age&quot;) Integer age); 			  //@RequestParam(&quot;xxx&quot;)传的变量名以xxx为主 必须显示写出key即@RequestParam(&quot;name&quot;)</span></span><br><span class="line"><span class="code">            //不然会报错</span></span><br><span class="line"><span class="code">			//我们要传递参数到商品服务的故一定要和商品服务的变量名保持一致</span></span><br><span class="line"><span class="code">			//不一致商品服务方法接收不到参数</span></span><br><span class="line"><span class="code">			</span></span><br><span class="line"><span class="code">            //声明调用商品服务中的produc接口</span></span><br><span class="line"><span class="code">            @GetMapping(&quot;/product&quot;)</span></span><br><span class="line"><span class="code">            public String product(); //声明请求方法和服务路径和被调用服务请求方法和服务路径一样即可</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">6. 访问http://localhost:8081/category测试</span></span><br></pre></td></tr></table></figure>

<p><strong>路径传递参数 url&#x2F;chabai&#x2F;22</strong></p>
<blockquote>
<p>注意:在openfegin接口声明中必须给参数加入注解@PathVariable指明传递方式为路径传递方式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 在被调用服务的接口即商品接口里定义一个接收零散类型参数接口 接收test1/<span class="number">22</span>/chabai方式请求传递的参数 ProductController</span><br><span class="line">    <span class="keyword">package</span> com.chabai.controller;</span><br><span class="line">    <span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line">    <span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RestController</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(ProductController.class);</span><br><span class="line">        <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span> <span class="comment">//属性注入 注解方式</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个接收零散类型参数接口 接收test1/22/chabai方式请求传递的参数</span></span><br><span class="line">        <span class="meta">@GetMapping(&quot;test1/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line">        <span class="comment">//默认把?后的参数赋值变量 必须加@PathVariable(&quot;id&quot;) 明确表示要取路径id的值作为变量id的值</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">test1</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, <span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;name: &#123;&#125; id: &#123;&#125;&quot;</span>,name,id);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;test1 ok ,当前服务的端口为:&quot;</span>+port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span> 声明调用商品服务中的test1接口传递name,age参数 显性声明以路径传递参数传递</span><br><span class="line">    <span class="keyword">package</span> com.chabai.feignclient;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明调用商品服务接口</span></span><br><span class="line">    <span class="meta">@FeignClient(value=&quot;PRODUCT&quot;)</span> <span class="comment">//value:用来书写调用服务的服务id 可不写value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductClient</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明调用商品服务中test1接口传递name,age参数 以路径传递方式传递零散类型参数</span></span><br><span class="line">        <span class="meta">@GetMapping(&quot;test1/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line">        <span class="comment">//底层在组织的时候把id的值赋给路径&#123;id&#125;站位作为请求</span></span><br><span class="line">        String <span class="title function_">test1</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, <span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">3.</span> 回到CategoryController调用商品服务中的test1接口传递参数</span><br><span class="line">    <span class="keyword">package</span> com.chabai.controller;</span><br><span class="line">    <span class="keyword">import</span> com.chabai.feignclient.ProductClient;</span><br><span class="line">    <span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line">    <span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RestController</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(CategoryController.class);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> ProductClient productClient;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@GetMapping(&quot;/category&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">category</span><span class="params">()</span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;category service ...&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> productClient.test1(<span class="number">22</span>,<span class="string">&quot;chabai&quot;</span>); <span class="comment">//注 我们这里写死是为了演示以后跟业务整合可把业务对象值传过来，或者利用category方法接收的参数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;category ok &quot;</span> +result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">4.</span> 访问http:<span class="comment">//localhost:8081/category测试</span></span><br></pre></td></tr></table></figure>

<h5 id="对象类型参数传递"><a href="#对象类型参数传递" class="headerlink" title="对象类型参数传递"></a>对象类型参数传递</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.</span> 要传递对象故我们先定义一个对象 新建实体类  com/chabai/entity/Product</span><br><span class="line">    <span class="keyword">package</span> com.chabai.entity;</span><br><span class="line">    <span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Double price;</span><br><span class="line">        <span class="keyword">private</span> Date bir;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Double <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> price;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(Double price)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.price = price;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Date <span class="title function_">getBir</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> bir;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBir</span><span class="params">(Date bir)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.bir = bir;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(Integer id, String name, Double price, Date bir)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.price = price;</span><br><span class="line">            <span class="built_in">this</span>.bir = bir;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Product&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                    <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                    <span class="string">&quot;, bir=&quot;</span> + bir +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1.</span> 在被调用服务的接口即商品接口里定义一个接收对象类型的接口</span><br><span class="line">    <span class="keyword">package</span> com.chabai.controller;</span><br><span class="line">    <span class="keyword">import</span> com.chabai.entity.Product;</span><br><span class="line">    <span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line">    <span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RestController</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(ProductController.class);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span> <span class="comment">//属性注入 注解方式</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个接收对象类型参数的接口</span></span><br><span class="line">        <span class="meta">@PostMapping(&quot;/test2&quot;)</span>  <span class="comment">//接收对象站在rest角度我们一般都是post put patch请求方式  查询或者删除一般传零散类型</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(Product product)</span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;product:&#123;&#125;&quot;</span>,product);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;test2 ok ,当前服务的端口为:&quot;</span>+port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>声明调用商品服务中test2接口传递一个商品对象</span><br><span class="line">    <span class="keyword">package</span> com.chabai.feignclient;</span><br><span class="line">    <span class="keyword">import</span> com.chabai.entity.Product;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明调用商品服务接口</span></span><br><span class="line">    <span class="meta">@FeignClient(value=&quot;PRODUCT&quot;)</span> <span class="comment">//value:用来书写调用服务的服务id 可不写value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductClient</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostMapping(&quot;/test2&quot;)</span></span><br><span class="line">        <span class="comment">//声明调用商品服务中test2接口传递一个商品对象</span></span><br><span class="line">        String <span class="title function_">test2</span><span class="params">(Product product)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="number">3.</span>cv实体类到category_client服务  注：真正开发时实体类是公共搭建的 不用cv即可访问到</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>回到CategoryController调用商品服务中的test2接口传递参数</span><br><span class="line">    <span class="keyword">package</span> com.chabai.controller;</span><br><span class="line">    <span class="keyword">import</span> com.chabai.entity.Product;</span><br><span class="line">    <span class="keyword">import</span> com.chabai.feignclient.ProductClient;</span><br><span class="line">    <span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line">    <span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RestController</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(CategoryController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductClient productClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/category&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">category</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;category service ...&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> productClient.test2(<span class="keyword">new</span> <span class="title class_">Product</span>(<span class="number">11</span>,<span class="string">&quot;chabai&quot;</span>,<span class="number">123.123</span>,<span class="keyword">new</span> <span class="title class_">Date</span>()));<span class="comment">//注 我们这里写死是为了演示以后跟业务整合可把业务对象值传过来，或者利用category方法接收的参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;category ok &quot;</span> +result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="number">5.</span>为<span class="literal">null</span>不能正确接收到参数</span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span>显性声明以json字符串传递对象  加注解<span class="meta">@RequestBody</span> application/json方式 声明和接收处都加 推荐</span><br><span class="line">  <span class="meta">@RequestBody</span>：底层传递对象时 会把对象组织成jiso字符串形式的请求</span><br><span class="line">！！！ ......我这里就不写了 加上<span class="meta">@RequestBody</span>即可</span><br><span class="line">    </span><br><span class="line"><span class="number">7.</span>以form表单方式传递对象  加注解<span class="meta">@RequestPart</span>  暂时有问题先不使用 </span><br><span class="line">  <span class="meta">@RequestPart</span>：底层传递对象时 会把对象组织成form请求体形式的请求</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="数组和集合"><a href="#数组和集合" class="headerlink" title="数组和集合"></a>数组和集合</h5><p><strong>数组</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 定义一个接收数组类型参数的接口</span><br><span class="line"><span class="code">    //定义一个接收数组类型参数的接口</span></span><br><span class="line"><span class="code">    @GetMapping(&quot;/test3&quot;)</span></span><br><span class="line"><span class="code">    public String test3(String[] ids)&#123; //可不加默认就是?方式取数据</span></span><br><span class="line"><span class="code">        for (String id : ids) &#123;</span></span><br><span class="line"><span class="code">            log.info(&quot;id:&#123;&#125;&quot;,id);</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">        return &quot;test3 ok ,当前服务的端口为:&quot;+port;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">2. 声明调用商品服务中test3接口 传递一个数组类型</span></span><br><span class="line"><span class="code">    //声明调用商品服务中test3接口 传递一个数组类型 底层只能以queryString方式即/test3?ids=23ids=22方式传递</span></span><br><span class="line"><span class="code">    @GetMapping(&quot;/test3&quot;)</span></span><br><span class="line"><span class="code">    String test3(@RequestParam(&quot;ids&quot;) String[] ids);</span></span><br><span class="line"><span class="code">3. 回到CategoryController调用商品服务中的test3接口传递参数</span></span><br><span class="line"><span class="code">    String result = productClient.test3(new String[]&#123;&quot;20&quot;,&quot;21&quot;,&quot;22&quot;&#125;);</span></span><br><span class="line"><span class="code">4. 可手动转为list集合 List&lt;String&gt; Strings = Arrays.asList(ids);</span></span><br></pre></td></tr></table></figure>

<p><strong>集合</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">0.</span> 定义用来接收集合类型参数的对象 vos/CollectionVo</span><br><span class="line"><span class="code">    package com.chabai.vos;</span></span><br><span class="line"><span class="code">    import java.util.List;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    //定义用来接收集合类型参数的对象</span></span><br><span class="line"><span class="code">    public class CollectionVo &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        private List&lt;String&gt; ids; //接收的集合声明到这里//springmvc写对象的属性名就可以自动创建对象并为属性赋值</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        public List&lt;String&gt; getIds() &#123;</span></span><br><span class="line"><span class="code">            return ids;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">        public void setIds(List&lt;String&gt; ids) &#123;</span></span><br><span class="line"><span class="code">            this.ids = ids;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">1. 定义一个接收集合类型参数的接口 注：</span></span><br><span class="line"><span class="code">//定义一个接收集合类型参数的接口  //springmvc不能直接接收集合类型参数，如果想要接收集合参数必须将集合放入对象中，使用对象的方式接收</span></span><br><span class="line"><span class="code">//vo(value object):用来传递数据对象成为值对象---用来收参   dto(data transfer(传输) object) ：数据传输对象---用来传数据  两个相对应的</span></span><br><span class="line"><span class="code">//接收集合参数必须将集合放入对象中，使用对象的方式接收 我们可以放到entity的对象里去接收</span></span><br><span class="line"><span class="code">//但是entity的对象是和库表映射的,为了不污染我们的实体 我们可以新建vos包放vo 业务数据复杂的时候我们把一次性的数据统一的放到一个对象里边即vo去接收数据</span></span><br><span class="line"><span class="code">    @GetMapping(&quot;/test4&quot;)</span></span><br><span class="line"><span class="code">    public String test4(CollectionVo collectionVo)&#123;</span></span><br><span class="line"><span class="code">        collectionVo.getIds().forEach(id-&gt; log.info(&quot;id:&#123;&#125;&quot;,id));</span></span><br><span class="line"><span class="code">        return &quot;test4 ok ,当前服务的端口为:&quot;+port;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">2. 声明调用商品服务中test4接口 传递一个集合类型</span></span><br><span class="line"><span class="code">//声明调用商品服务中test4接口 传递一个list集合类型</span></span><br><span class="line"><span class="code">//我们通过测试发现地址栏是test4?ids=21&amp;ids=22&amp;ids=23形式商品服务对应接口可以正确接收到数据</span></span><br><span class="line"><span class="code">//故我们feign底层只要把请求组装成test4?ids=21&amp;ids=22&amp;ids=23形式就可成功传递数据  这个思想你要明白</span></span><br><span class="line"><span class="code">//这里传递参数无非就是把我们通过http client手动通过任务栏传参数构建请求 转变为我们声明请求方式和参数给OpenFeign帮我们构建请求从而达成一样的效果</span></span><br><span class="line"><span class="code">//和数组拼接方式一样</span></span><br><span class="line"><span class="code">    @GetMapping(&quot;/test4&quot;)</span></span><br><span class="line"><span class="code">    String test4(@RequestParam(&quot;ids&quot;) String[] ids);</span></span><br><span class="line"><span class="code">3. 回到CategoryController调用商品服务中的test4接口传递参数</span></span><br><span class="line"><span class="code">    String result = productClient.test4(new String[]&#123;&quot;20&quot;,&quot;21&quot;,&quot;22&quot;&#125;);</span></span><br></pre></td></tr></table></figure>

<h4 id="服务间通信之响应处理"><a href="#服务间通信之响应处理" class="headerlink" title="服务间通信之响应处理"></a>服务间通信之响应处理</h4><h5 id="使用openfeign调用服务并返回对象"><a href="#使用openfeign调用服务并返回对象" class="headerlink" title="使用openfeign调用服务并返回对象"></a>使用openfeign调用服务并返回对象</h5><blockquote>
<p>使用openfeign调用服务并返回对象  类别调用 商品服务 根据类别服务传递的id 把查询到的商品对象返回给类别服务</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定义一个接口,接收id类型参数,返回一个基于id查询的对象</span><br><span class="line">    <span class="comment">//定义一个接口,接收id类型参数,返回一个基于id查询的对象</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">product</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;id:&#123;&#125;&quot;</span>,id);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Product</span>(id,<span class="string">&quot;chabai&quot;</span>,<span class="number">232.21</span>,<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span> 声明调用根据id查询商品信息的接口 </span><br><span class="line">    <span class="comment">//声明调用根据id查询商品信息的接口</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/&#123;id&#125;&quot;)</span></span><br><span class="line">    Product <span class="title function_">product</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>; </span><br><span class="line"><span class="number">3.</span> 回到CategoryController调用商品服务中的product接口传递参数 调用服务并返回对象   </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/category&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">category</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;category service ...&quot;</span>);</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productClient.product(<span class="number">22</span>);<span class="comment">//注 我们这里写死是为了演示以后跟业务整合可把业务对象值传过来，或者利用category方法接收的参数</span></span><br><span class="line">        log.info(<span class="string">&quot;product：&#123;&#125;&quot;</span>,product);</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用openfeign调用服务并返回所有list集合"><a href="#使用openfeign调用服务并返回所有list集合" class="headerlink" title="使用openfeign调用服务并返回所有list集合"></a>使用openfeign调用服务并返回所有list集合</h5><blockquote>
<p>使用openfeign调用服务并返回所有list集合  类别调用 商品服务 根据类别服务传递的类的id 把查询到某个类别下的所有商品返回给类别服务 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">注:集合也是一个对像 多个对象组成了一个集合</span><br><span class="line"><span class="number">1.</span> 定义一个接口,接收id类型参数,返回一个基于id查询的集合</span><br><span class="line">    <span class="comment">//定义一个接口,接收id类型参数,返回一个基于id查询的集合</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/products&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">findByCategoryId</span><span class="params">(Integer categoryId)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;类别：&#123;&#125;&quot;</span>,categoryId);</span><br><span class="line">        <span class="comment">//调用业务逻辑根据类别id查询商品列表 我们这里是模拟</span></span><br><span class="line">        List&lt;Product&gt; products = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        products.add(<span class="keyword">new</span> <span class="title class_">Product</span>(<span class="number">21</span>,<span class="string">&quot;c&quot;</span>,<span class="number">22.22</span>,<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        products.add(<span class="keyword">new</span> <span class="title class_">Product</span>(<span class="number">22</span>,<span class="string">&quot;b&quot;</span>,<span class="number">22.23</span>,<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        products.add(<span class="keyword">new</span> <span class="title class_">Product</span>(<span class="number">23</span>,<span class="string">&quot;b&quot;</span>,<span class="number">22.24</span>,<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        <span class="keyword">return</span> products;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span> 声明调用商品服务根据类别id查询一组商品信息</span><br><span class="line">    <span class="comment">//声明调用商品服务根据类别id查询一组商品信息</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/products&quot;)</span></span><br><span class="line">    List&lt;Product&gt; <span class="title function_">findByCategoryId</span><span class="params">(<span class="meta">@RequestParam(&quot;categoryId&quot;)</span> Integer categoryId)</span>;</span><br><span class="line"><span class="number">3.</span> 回到CategoryController调用商品服务中的findByCategoryId接口传递参数 调用服务并返回list集合</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/category&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">category</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;category service ...&quot;</span>);</span><br><span class="line">        List&lt;Product&gt; products = productClient.findByCategoryId(<span class="number">21</span>);<span class="comment">//注 我们这里写死是为了演示以后跟业务整合可把业务对象值传过来，或者利用category方法接收的参数</span></span><br><span class="line">        products.forEach(product -&gt; log.info(<span class="string">&quot;product：&#123;&#125;&quot;</span>,product));</span><br><span class="line">        <span class="keyword">return</span> products;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用openfeign调用服务并返回所有Map集合"><a href="#使用openfeign调用服务并返回所有Map集合" class="headerlink" title="使用openfeign调用服务并返回所有Map集合"></a>使用openfeign调用服务并返回所有Map集合</h5><blockquote>
<p>使用openfeign调用服务并返回所有Map集合  类别调用 商品服务 根据类别服务传递的类的id 把查询到某个类别下的所有商品返回给类别服务</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定义一个接口,接收id类型参数,返回一个基于id查询的map集合</span><br><span class="line">    <span class="comment">//定义一个接口,接收id类型参数,返回一个基于id查询的map集合</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/productsPage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">findByCategoryIdAndPage</span><span class="params">(Integer page, Integer rows , Integer categoryId)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前页：&#123;&#125; 每页显示的记录数:&#123;&#125; 当前的类别:&#123;&#125;&quot;</span>,page,rows,categoryId);</span><br><span class="line">        <span class="comment">//根据类别id分页查询符合当前页的集合数据 List&lt;Product&gt; 里边有所有符合的对象  select * from t_product where categoryId=xx limit (page -1)*rows,rows</span></span><br><span class="line">        <span class="comment">//根据类别id查询当前类别下的总条数      Long                            select count(id) from t_product where categoryId=xx</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        List&lt;Product&gt; products = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        products.add(<span class="keyword">new</span> <span class="title class_">Product</span>(<span class="number">21</span>,<span class="string">&quot;c&quot;</span>,<span class="number">22.22</span>,<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        products.add(<span class="keyword">new</span> <span class="title class_">Product</span>(<span class="number">22</span>,<span class="string">&quot;b&quot;</span>,<span class="number">22.23</span>,<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        products.add(<span class="keyword">new</span> <span class="title class_">Product</span>(<span class="number">23</span>,<span class="string">&quot;b&quot;</span>,<span class="number">22.24</span>,<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        map.put(<span class="string">&quot;rows&quot;</span>,products);</span><br><span class="line">        map.put(<span class="string">&quot;total&quot;</span>,total);</span><br><span class="line">        <span class="keyword">return</span> map; <span class="comment">//返回的是一个map集合里边有两个key vale 一个&lt;rows,products&gt; 一个&lt;total,1000&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span> 声明调用商品服务根据类别id分页查询商品信息 以及总条数</span><br><span class="line"> <span class="comment">//声明调用商品服务根据类别id分页查询商品信息 以及总条数</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/productsPage&quot;)</span></span><br><span class="line">    Map&lt;String, Object&gt; <span class="title function_">findByCategoryIdAndPage</span><span class="params">(<span class="meta">@RequestParam(&quot;page&quot;)</span> Integer page,<span class="meta">@RequestParam(&quot;rows&quot;)</span> Integer rows , <span class="meta">@RequestParam(&quot;categoryId&quot;)</span> Integer categoryId)</span>;</span><br><span class="line"><span class="number">3.</span> 回到CategoryController调用商品服务中的findByCategoryIdAndPage接口传递参数 调用服务并返回map集合</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/category&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">category</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;category service ...&quot;</span>);</span><br><span class="line">        Map&lt;String, Object&gt; objectMap = productClient.findByCategoryIdAndPage(<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>);<span class="comment">//注 我们这里写死是为了演示以后跟业务整合可把业务对象值传过来，或者利用category方法接收的参数</span></span><br><span class="line">        <span class="comment">//当我们再调别人接口的时候，发了一个请求调支付宝接口，人家返回过来的是一个json字符串，我们不能把这个字符串强转为我们的java对象</span></span><br><span class="line">        <span class="comment">//即：List&lt;Product&gt; rows = (List&lt;Product&gt;)(objectMap.get(&quot;rows&quot;))会报错 objectMap.get(&quot;rows&quot;)我们拿到的是一个json格式数组字符串</span></span><br><span class="line">        <span class="comment">//虽然我们这里写了一个强转但是我们底层是当成一个object 我们不能把一个object强转为list</span></span><br><span class="line">        <span class="comment">//解释：Java中不能将一个Object对象直接强转为List，因为它们之间没有继承或实现关系。要将Object对象转换为List，你需要明确知道这个Object对象实际上是一个List类型的实例，然后使用合适的转换方法，比如类型转换或者通过构造函数创建一个新的List。</span></span><br><span class="line">       <span class="comment">//解决办法:自定义格式解析</span></span><br><span class="line">        <span class="keyword">return</span> objectMap;</span><br></pre></td></tr></table></figure>

<h5 id="自定义格式解析json字符串"><a href="#自定义格式解析json字符串" class="headerlink" title="自定义格式解析json字符串"></a>自定义格式解析json字符串</h5><blockquote>
<p>自定义格式解析json字符串</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span> 解决办法:自定义格式解析 既然这个接口虽然响应给我们的我们自己写的是个map但最后响应给我们的是个json那么我们就把它当做普通字符串来处理 </span><br><span class="line">-   定义一个String去接收 自己去处理这个序列化 不用feign底层的序列化</span><br><span class="line">    <span class="comment">//声明调用商品服务根据类别id分页查询商品信息 以及总条数</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/productsPage&quot;)</span></span><br><span class="line">    String <span class="title function_">findByCategoryIdAndPage</span><span class="params">(<span class="meta">@RequestParam(&quot;page&quot;)</span> Integer page,<span class="meta">@RequestParam(&quot;rows&quot;)</span> Integer rows , <span class="meta">@RequestParam(&quot;categoryId&quot;)</span> Integer categoryId)</span>;</span><br><span class="line">- 引入序列化依赖</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.2</span><span class="number">.75</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">-  自定义格式解析</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/category&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">category</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;category service ...&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> productClient.findByCategoryIdAndPage(<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>);<span class="comment">//注 我们这里写死是为了演示以后跟业务整合可把业务对象值传过来，或者利用category方法接收的参数</span></span><br><span class="line">        <span class="comment">//当我们再调别人接口的时候，发了一个请求调支付宝接口，人家返回过来的是一个json字符串，我们不能把这个字符串强转为我们的java对象</span></span><br><span class="line">        <span class="comment">//即：List&lt;Product&gt; rows = (List&lt;Product&gt;)(objectMap.get(&quot;rows&quot;))会报错 objectMap.get(&quot;rows&quot;)我们拿到的是一个json格式数组字符串</span></span><br><span class="line">        <span class="comment">//虽然我们这里写了一个强转但是我们底层是当成一个object 我们不能把一个object强转为list</span></span><br><span class="line">        <span class="comment">//解释：Java中不能将一个Object对象直接强转为List，因为它们之间没有继承或实现关系。要将Object对象转换为List，你需要明确知道这个Object对象实际上是一个List类型的实例，然后使用合适的转换方法，比如类型转换或者通过构造函数创建一个新的List。</span></span><br><span class="line">       <span class="comment">//解决办法:自定义格式解析</span></span><br><span class="line">        log.info(<span class="string">&quot;result:&#123;&#125;&quot;</span>,result);</span><br><span class="line">        <span class="comment">// 自定义json反序列化  当有复杂对象我们处理不了时 你给我响应的时一个json 我就定义一个String去接收 自己去处理这个序列化 不用feign底层的序列化</span></span><br><span class="line">        <span class="comment">//feign底层只能处理简单的序列化 复杂的只能我们自己来</span></span><br><span class="line">        <span class="comment">// 对象转json--》序列化  json字符串转对象---》反序列化</span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONObject.parseObject(result);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">total</span> <span class="operator">=</span> jsonObject.get(<span class="string">&quot;total&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">rows</span> <span class="operator">=</span> jsonObject.get(<span class="string">&quot;rows&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;total:&#123;&#125;&quot;</span>,total);</span><br><span class="line">        log.info(<span class="string">&quot;rows:&#123;&#125;&quot;</span>,rows);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二次json反序列化</span></span><br><span class="line">        List&lt;Product&gt; products = jsonObject.parseArray(rows.toString(), Product.class);</span><br><span class="line">        products.forEach(product -&gt;log.info(<span class="string">&quot;product:&#123;&#125;&quot;</span>,product));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<h4 id="openfeign细节"><a href="#openfeign细节" class="headerlink" title="openfeign细节"></a>openfeign细节</h4><h5 id="openfeign默认超时处理"><a href="#openfeign默认超时处理" class="headerlink" title="openfeign默认超时处理"></a>openfeign默认超时处理</h5><p><strong>openfeign默认超时处理是什么</strong></p>
<p>默认情况下,openFiegn在进行服务调用时,要求服务提供方处理业务逻辑时间必须在1S内返回,如果超过1S没有返回则OpenFeign会直接报错,不会等待服务执行,但是往往在处理复杂业务逻辑是可能会超过1S,因此需要修改OpenFeign的默认服务调用超时时间</p>
<p><strong>模拟超时</strong></p>
<ul>
<li>服务提供方加入线程等待阻塞</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/product&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">product</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       log.info(<span class="string">&quot;进入商品服务...&quot;</span>)</span><br><span class="line">       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;product ok,当前提供端口服务：&quot;</span>+port;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>前台页面显示 超时</li>
</ul>
<p><code>Read timed out executing GET http://PRODUCT/product</code></p>
<p><strong>修改OpenFeign默认超时时间</strong></p>
<blockquote>
<p>修改当前服务调用指定服务时间</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#注意应该在调用者的配置文件修改，填的是服务名id</span><br><span class="line">feign.client.config.PRODUCT.connectTimeout=<span class="number">5000</span>  		#配置指定服务连接超时</span><br><span class="line">feign.client.config.PRODUCT.readTimeout=<span class="number">5000</span>		  	#配置指定服务等待超时</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改当前服务调用所有服务时间</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">feign.client.config.<span class="keyword">default</span>.connectTimeout=<span class="number">5000</span>  		#配置所有服务连接超时</span><br><span class="line">feign.client.config.<span class="keyword">default</span>.readTimeout=<span class="number">5000</span>			#配置所有服务等待超时</span><br></pre></td></tr></table></figure>

<h5 id="OpenFeign调用详细日志展示"><a href="#OpenFeign调用详细日志展示" class="headerlink" title="OpenFeign调用详细日志展示"></a>OpenFeign调用详细日志展示</h5><p>openfeign伪httpclient客户端对象，用来帮助我们完成服务间通信  底层用http协议  完成服务间调用</p>
<p>日志：openfeign为了更好方便在开发过程中调试openfeign数据传递，和响应处理，openfeign在设计时添加了日志功能，默认openfeign日志功能需要手动开启的</p>
<p>往往在服务调用时我们需要详细展示feign的日志,默认feign在调用是并不是最详细日志输出,因此在调试程序时应该开启feign的详细日志展示。feign对日志的处理非常灵活可为<code>每个feign客户端</code>指定日志记录策略，每个客户端都会创建一个logger默认情况下logger的名称是feign的全限定名需要注意的是，feign日志的打印只会<code>DEBUG</code>级别做出响应。</p>
<blockquote>
<p>展示日志</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#展示openfeign日志</span></span><br><span class="line"><span class="attr">logging.level.com.chabai.feignclient</span>=<span class="string">debug</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们可以为openfeign客户端配置各自的logger ,lever对象 ,告诉feign记录哪些日志logger,lever 有以下几种值</p>
</blockquote>
<ul>
<li>NONE：不记录任何日志信息，这是默认值。</li>
<li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li>
<li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li>
<li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li>
</ul>
<blockquote>
<p>基于配置文件修改feign的日志级别可以针对单个服务  </p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对某个微服务的配置   </span></span><br><span class="line"><span class="string">feign.client.config.PRODUCT.loggerLevel=full</span> <span class="comment">#开启指定服务日志展示     四个值根据需求选择</span></span><br><span class="line"><span class="string">logging.level.root=info</span>                    <span class="comment"># 根日志展示级别</span></span><br><span class="line"><span class="string">logging.level.com.chabai.feignclient=debug</span> <span class="comment">#指定feign调用客户端对象所在的包必须为debug级别</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>基于配置文件修改feign的日志级别也可以针对所有服务</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span></span><br><span class="line"><span class="string">feign.client.config.default.loggerLevel=full</span>   <span class="comment">#全局开启服务日志展示  四个值根据需求选择</span></span><br><span class="line"><span class="string">logging.level.root=info</span>                        <span class="comment"># 根日志展示级别</span></span><br><span class="line"><span class="string">logging.level.com.baizhi.feignclients=debug</span>    <span class="comment">#指定feign调用客户端对象所在包,必须是debug级别</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410184821821.png" alt="image-20240410184821821"></p>
<p><strong>注：第一个框是请求(根据声明和参数底层给我们拼接成的对应调用请求)，第二个框是响应情况</strong></p>
<blockquote>
<p>Java代码方式修改日志（了解即可）</p>
</blockquote>
<p>也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfiguration</span>  &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.BASIC; <span class="comment">// 日志级别为BASIC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure>

<p>如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure>

<h5 id="Feign使用优化-暂放"><a href="#Feign使用优化-暂放" class="headerlink" title="Feign使用优化(暂放)"></a>Feign使用优化(暂放)</h5><p>Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：</p>
<ul>
<li><p>URLConnection：默认实现，不支持连接池</p>
</li>
<li><p>Apache HttpClient ：支持连接池</p>
</li>
<li><p>OKHttp：支持连接池</p>
</li>
</ul>
<p>因此提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。</p>
<p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--httpClient的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>配置</strong></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># default全局的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">BASIC</span> <span class="comment"># 日志级别，BASIC就是基本的请求和响应信息</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对HttpClient的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure>

<p>总结，Feign的优化：</p>
<p>1.日志级别尽量用basic</p>
<p>2.使用HttpClient或OKHttp代替URLConnection</p>
<p>① 引入feign-httpClient依赖</p>
<p>② 配置文件开启httpClient功能，设置连接池参数</p>
<h2 id="Hystrix组件"><a href="#Hystrix组件" class="headerlink" title="Hystrix组件"></a>Hystrix组件</h2><h3 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h3><p><strong>现象</strong>：在一个时刻微服务系统中所有微服务均不可用的这种现象，称之为服务雪崩现象<br><strong>引发</strong>：在服务之间进行服务的调用时由于某一个服务故障，导致级联服务故障的现象，称为雪崩效应，雪崩效应的提供方不可用，导致消费方不可用，逐渐放大的过程</p>
<p>注：springboot内嵌tomcat,里边帮我们处理请求的是一个个线程，一个操作系统创建线程的数量是有限的，一旦过大操作系统会崩溃，Tomcat默认线程数150个，超过150个再来的请求只能等待前边执行完才行</p>
<p><strong>根本原因</strong>：调用链路中链路某一服务因为执行业务时间过程，或者是大规模出现异常导致自身服务不可用，并把这种不可用放大情况</p>
<p><strong>图解雪崩效应：</strong></p>
<p>如存在以下调用链路：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410184921208.png" alt="image-20240410184921208"></p>
<p>Service A的流量波动很大，流量经常会突然性增加！那么在这种情况下，就算Service A能扛得住请求，Service B和Service C未必能扛得住这突发的请求。此时，如果Service C因为抗不住请求，变得不可用。那么Service B的请求也会阻塞，慢慢耗尽Service B的线程资源，Service B就会变得不可用。紧接着，Service A也会不可用。图示如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240416174428691.png" alt="image-20240416174428691"></p>
<p><strong>如何解决微服务系统服务雪崩问题？</strong></p>
<p>a. 服务熔断</p>
<h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><blockquote>
<p>对某一个服务调用链路服务的保护</p>
</blockquote>
<p><strong>定义：</strong>有点类似保险丝，熔断器本身是一种开关装置，当某个服务单元发生故障之后，通过断路器(hystrix)的故障监控，某个异常条件被触发，直接熔断整个服务。向调用方法返回一个符合预期的、可处理的备选响应(FallBack),而不是长时间的等待或者抛出调用方法无法处理的异常，就保证了服务调用方的线程不会被长时间占用，避免故障在分布式系统中蔓延，乃至雪崩。如果目标服务情况好转则恢复调用。服务熔断是解决服务雪崩的重要手段</p>
<p><strong>服务熔断图示：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240416182129455.png" alt="image-20240416182129455"></p>
<h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><blockquote>
<p>站在整个系统架构的考虑 系统层面的优化</p>
</blockquote>
<p><strong>定义：</strong>服务压力剧增的时候根据当前的业务情况及流量对一些服务和页面有策略的降级，以此缓解服务器的压力，以保证核心任务的进行。同时保证部分甚至大部分任务客户能得到正确的响应。也就是当前的请求处理不了了或者出错了，给一个默认的返回</p>
<p><strong>通俗定义:</strong> 当网站|服务流量突然增加时，有策略关闭微服务系统中某些边缘服务 保证系统核心服务正常运行</p>
<p><strong>服务降级图示：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410184935713.png" alt="image-20240410184935713"></p>
<h3 id="降级和熔断总结"><a href="#降级和熔断总结" class="headerlink" title="降级和熔断总结"></a>降级和熔断总结</h3><p><strong>共同点</strong></p>
<ul>
<li>目的很一致，都是从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术手段；</li>
<li>最终表现类似，对于两者来说，最终让用户体验到的是某些功能暂时不可达或不可用；</li>
<li>粒度一般都是服务级别，当然，业界也有不少更细粒度的做法，比如做到数据持久层（允许查询，不允许增删改）；</li>
<li>自治性要求很高，熔断模式一般都是服务基于策略的自动触发，降级虽说可人工干预，但在微服务架构下，完全靠人显然不可能，开关预置、配置中心都是必要手段；sentinel(alibaba)</li>
</ul>
<p><strong>异同点</strong></p>
<ul>
<li>触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；</li>
<li>管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务边缘服务开始）</li>
</ul>
<p><strong>总结</strong></p>
<p>熔断必会触发降级,所以熔断也是降级一种,区别在于熔断是对调用链路的保护,而降级是对系统过载的一种保护处理</p>
<h3 id="组件定义"><a href="#组件定义" class="headerlink" title="组件定义"></a>组件定义</h3><blockquote>
<p>服务熔断器 监控器  防雪崩利器  属于Netflix已处于维护模式   了解思想即可 以后用sentinel(alibaba)</p>
</blockquote>
<p><strong>定义：</strong>在分布式环境中，许多服务依赖项不可避免地会失败，Hystrix是一个库，它通过添加延迟容忍和容错逻辑来帮助你控制这些分布式服务的交互。Hystrix通过隔离服务之间地访问点，停止它们之间的级联故障以及提供后备选项来实现这一点，所有这些都可以提高系统的整体弹性。</p>
<p><strong>通俗定义</strong>: Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统中，许多依赖不可避免的会调用失败，超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障(服务雪崩现象)，提高分布式系统的弹性。</p>
<p><strong>作用</strong>：hystrix 用来保护微服务系统 实现 <strong>服务降级</strong> <strong>服务熔断(防雪崩利器)</strong></p>
<h3 id="服务熔断的实现"><a href="#服务熔断的实现" class="headerlink" title="服务熔断的实现"></a>服务熔断的实现</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240416234155609.png" alt="image-20240416234155609"></p>
<h4 id="断路器打开关闭的条件"><a href="#断路器打开关闭的条件" class="headerlink" title="断路器打开关闭的条件"></a>断路器打开关闭的条件</h4><blockquote>
<p>如果触发一定条件断路器会自动打开,过了一点时间正常之后又会关闭</p>
</blockquote>
<p><strong>断路器打开关闭的条件:</strong>  (两个阈值)</p>
<p>1、 当满足一定的阀值的时候（默认10秒内超过20个请求次数）</p>
<p>2、 当失败率达到一定的时候（默认10秒内超过50%的请求失败）</p>
<p><strong>注意：</strong></p>
<p>1、 到达以上阀值，断路器将会开启</p>
<p>2、 一旦断路器开启之后，所有请求都不会进行转发，只有在断路关闭之后才可用</p>
<p>3、 一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5</p>
<p><strong>断路器流程:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410185304064.png" alt="image-20240410185304064"></p>
<p><strong>整个流程：</strong>当hystrix监控到对该服务接口调用触发的两种阈值时，会在系统中自动触发熔断器，在熔断器打开期间内，任何到该接口请求均不可用，同时在断路器打开5秒后断路器会处于半开状态，此时断路器允许放行一个请求到该服务接口，如果该请求执行成功，断路器彻底关闭，如果该请求执行失败，断路器重新打开</p>
<h4 id="服务熔断备选处理"><a href="#服务熔断备选处理" class="headerlink" title="服务熔断备选处理"></a>服务熔断备选处理</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 被调用服务没有down掉 只是商品(我们暂且模拟调用)服务调用库存服务失败率达到了我给你熔断了，过段时间还能正常处理</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个springboot并注册到consul server</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注:熟练之后需要依赖可一下引完</span></span><br><span class="line">1.使用maven新建一个空项目 springcloud<span class="emphasis">_hystrix</span></span><br><span class="line"><span class="emphasis">2.引入springboot依赖</span></span><br><span class="line"><span class="emphasis">3.提供springboot配置文件</span></span><br><span class="line"><span class="emphasis">4.写入口类测试springboot是否可以启动</span></span><br><span class="line"><span class="emphasis">5.引入consul客户端依赖 作用：能把当前服务注册到指定的consul服务注册中心 引入健康检查依赖</span></span><br><span class="line"><span class="emphasis">6.再次写配置文件</span></span><br><span class="line"><span class="emphasis">7.在入口类加客户端注解@EnableDiscoveryClient(除eureka client) 让当前微服务作为一个服务客户端 进行微服务注册</span></span><br><span class="line"><span class="emphasis">8.启动服务并在consul界面查看服务信息 </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>给调用服务方提供一个服务接口  DemoController 并测试接口是否正常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chabai.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(DemoController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">demo</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;demo ok ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;demo ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>模拟</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chabai.controller;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(DemoController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/demo&quot;)</span>  <span class="comment">//queryString方式传一个参数 即?id=</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">demo</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;demo ok ...&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (id&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;无效id&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;demo ok,id:&quot;</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果 访问<a target="_blank" rel="noopener" href="http://localhost:8990/demo?id=1%E6%AD%A3%E5%B8%B8">http://localhost:8990/demo?id=1正常</a> <a target="_blank" rel="noopener" href="http://localhost:8990/demo?id=-1%E6%8A%A5%E9%94%99">http://localhost:8990/demo?id=-1报错</a> 没有熔断 会服务雪崩</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240416230555321.png" alt="image-20240416230555321"></p>
<p>此时再传一个正常参数可立刻返回请求结果 注意：有断路器就不行了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240416230541295.png" alt="image-20240416230541295"></p>
<blockquote>
<p>所有微服务项目中引入hystrix依赖</p>
</blockquote>
<p>这个组件只能监控当前这个服务自身的状态，每个微服务都要引入 一旦引入这个组件就具有服务熔断功能</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入hystrix--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>开启断路器 在入口类加入注解@EnableCircuitBreaker</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>  <span class="comment">//代表springboot应用</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span>  <span class="comment">//代表服务注册中心客户端  consul  client</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span>   <span class="comment">//开启hystrix服务熔断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        SpringApplication.run(HystrixApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法一：使用HystrixCommand注解  为每一个调用接口提供自定义备选处理  熔断之后快速响应</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chabai.controller;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(DemoController.class);</span><br><span class="line"></span><br><span class="line">                                                    <span class="comment">//失败之后快速响应</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;demoFallBack&quot;)</span><span class="comment">//失败之后处理 fallbackMethod 书写失败处理方法名</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/demo&quot;)</span>  <span class="comment">//queryString方式传一个参数 即?id=</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">demo</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;demo ok ...&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (id&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;无效id&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;demo ok,id:&quot;</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自己备选处理</span></span><br><span class="line">    <span class="comment">//注意：fallbackMethod方法返回类型和参数列表必须要和熔断的方法一样 方法名任意</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">demoFallBack</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;当前活动过于火爆,服务已经被熔断&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果 多次错误请求 导致熔断器打开 正常请求也无法得到响应</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240416232649805.png" alt="image-20240416232649805"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240416232759158.png" alt="image-20240416232759158"></p>
<p>过一段时间熔断器关闭正确请求可以得到响应</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240416233159718.png" alt="image-20240416233159718"></p>
<blockquote>
<p>方法二：使用Hystrix提供默认备选处理 提供统一备选处理 不需要每次单独写一个备选处理了</p>
</blockquote>
<p>除了个别重要核心业务有专属，其它普通的可以通过@DefaultProperties(defaultFallback &#x3D; “”)统一跳转到统一处理结果页面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chabai.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Demo2Controller.class);</span><br><span class="line"></span><br><span class="line">                                                        <span class="comment">//失败之后快速响应</span></span><br><span class="line">    <span class="meta">@HystrixCommand(defaultFallback = &quot;defaultFallBack&quot;)</span><span class="comment">//失败之后 fallbackMethod 书写快速失败方法名</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/demo2&quot;)</span>  <span class="comment">//queryString方式传一个参数 即?id=</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">demo</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;demo ok ...&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (id&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;无效id&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;demo ok,id:&quot;</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认的备选处理,返回类型必须是String类型,不能有参数列表，同时存在优先自定义</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">defaultFallBack</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;网络连接失败,请重试&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务降级的实现"><a href="#服务降级的实现" class="headerlink" title="服务降级的实现"></a>服务降级的实现</h3><p>服务降级: 站在系统整体负荷角度 实现: 关闭系统中某些边缘服务 保证系统核心服务运行<br>Emps 核心服务 Depts 边缘服务</p>
<h4 id="feign服务降级备选处理"><a href="#feign服务降级备选处理" class="headerlink" title="feign服务降级备选处理"></a>feign服务降级备选处理</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 用户调商品调用库存服务 库存服务被作为边缘服务down掉了 openfeign会拿到无法访问此网站异常返回给商品服务 当用户调用商品时也会收到这样的异常 为了让用户有更好体验 我们在openfeign这边也做熔断策略即一次快速处理 Hystrix也可以帮我们实现</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个springboot并注册到consul server</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 我这里就快速构建了不再按部就班了</span></span><br><span class="line">1.使用maven新建一个空项目 springcloud<span class="emphasis">_hystrix_</span>openfeign</span><br><span class="line">2.引入springboot依赖 引入consul客户端依赖 引入健康检查依赖</span><br><span class="line">3.提供springboot配置文件 编写项目端口号,名称,以及服务注册地址</span><br><span class="line">4.写入口类并添加注解@SpringBootApplication和@EnableDiscoveryClient </span><br><span class="line">5.启动服务看springboot是否可以启动 并在consul界面查看服务是否成功注册 </span><br></pre></td></tr></table></figure>

<blockquote>
<p>给服务方提供一个服务接口  DemoController 并测试接口是否正常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chabai.controller;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemoController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(TestDemoController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;test ok ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过openfeign调用服务springcloud_hystrix的DemoController接口的demo方法并传一个int类型id</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 引入Open Feign依赖 import change</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span></span>org.springframework.cloud<span class="language-xml"><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span>spring-cloud-starter-openfeign<span class="language-xml"><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="section"># 在入口类加注解@EnableFeignClients开启feign调用</span></span><br><span class="line"><span class="section"># 定义一个接口feignclient接收我们给openfeign的调用声明</span></span><br><span class="line"><span class="section"># 加注解@FeignClient(&quot;HYSTRIX&quot;),并在接口里写调用方法声明</span></span><br><span class="line"><span class="bullet">-</span> 写声明时别忘了使用对应注解@RequestParam(&quot;id&quot;)告诉底层怎么传递参数</span><br><span class="line"><span class="bullet">-</span> 加入注解后我们的接口已被工厂托管</span><br><span class="line"><span class="section"># 回到服务消费方 注入openfeign客户端 并写调用代码完成调用</span></span><br><span class="line"><span class="code">    package com.chabai.controller;</span></span><br><span class="line"><span class="code">    import com.chabai.feignclients.HystrixClient;</span></span><br><span class="line"><span class="code">    import org.slf4j.Logger;</span></span><br><span class="line"><span class="code">    import org.slf4j.LoggerFactory;</span></span><br><span class="line"><span class="code">    import org.springframework.beans.factory.annotation.Autowired;</span></span><br><span class="line"><span class="code">    import org.springframework.web.bind.annotation.GetMapping;</span></span><br><span class="line"><span class="code">    import org.springframework.web.bind.annotation.RestController;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    @RestController</span></span><br><span class="line"><span class="code">    public class TestDemoController &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        private static final Logger log = LoggerFactory.getLogger(TestDemoController.class);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        //注入openfeign的客户端对象</span></span><br><span class="line"><span class="code">        @Autowired</span></span><br><span class="line"><span class="code">        private HystrixClient hystrixClient;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        @GetMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="code">        public String test()&#123;</span></span><br><span class="line"><span class="code">            log.info(&quot;test ok ...&quot;);</span></span><br><span class="line"><span class="code">            String result = hystrixClient.demo(21);</span></span><br><span class="line"><span class="code">            log.info(&quot;demo result:&#123;&#125;&quot;,result);</span></span><br><span class="line"><span class="code">            return &quot;test ok&quot;;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"># 访问http://localhost:8999/test 测试是否可调用成功</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>被调用服务被作为边缘服务down掉了，openfeign调用服务时会接收到异常  需做服务降级备选处理</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 引入hystrix依赖</span></span><br><span class="line"><span class="bullet">-</span> 注意openfeign底层已经依赖了hystrix，所有引入了openfeign的依赖就不用在显示引入hystrix的依赖了</span><br><span class="line"><span class="section"># 配置文件开启feign支持hystrix</span></span><br><span class="line"><span class="bullet">-</span> feign.hystrix.enabled=true #开启openfeign支持降级 默认是关闭的必须写</span><br><span class="line"><span class="section"># 在feign客户端调用加入fallback指定降级处理</span></span><br><span class="line"><span class="code">    //fallback 这个属性用来指定当前服务不可用时，默认的备选处理 我们必须写个类实现这个接口 这个接口每一个实现的方法就是对应接口每一个方法的备选处理</span></span><br><span class="line"><span class="code">    @FeignClient(value = &quot;HYSTRIX&quot;,fallback = HystrixClientFallBack.class) </span></span><br><span class="line"><span class="code">    public interface HystrixClient &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        @GetMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="code">        public String test(Integer id);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"># 开发fallback处理类并在类中开发降级处理方法</span></span><br><span class="line"><span class="code">    //HystrixClient的默认备选处理类</span></span><br><span class="line"><span class="code">    @Component //注意要给工厂托管</span></span><br><span class="line"><span class="code">    public class HystrixClientFallBack implements HystrixClient&#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        //openfeign服务降级备选处理方法</span></span><br><span class="line"><span class="code">        @Override</span></span><br><span class="line"><span class="code">        public String demo(Integer id) &#123;</span></span><br><span class="line"><span class="code">            return &quot;当前服务不可用,请稍后再试&quot;;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"># down掉被调用服务访问http://localhost:8999/test </span></span><br><span class="line"><span class="code">结果：test ok当前服务不可用,请稍后再试</span></span><br></pre></td></tr></table></figure>

<h3 id="Hystrix-Dashboard-暂放"><a href="#Hystrix-Dashboard-暂放" class="headerlink" title="Hystrix Dashboard(暂放)"></a>Hystrix Dashboard(暂放)</h3><p>仪表盘：用来显示状态信息  可有可无 锦上添花  帮助我们看看项目中断路器的状态</p>
<p>定义：Hystrix Dashboard的一个主要优点是它收集了关于每个HystrixCommand的一组度量。Hystrix仪表板以高效的方式显示每个断路器的运行状况。</p>
<p>作用：监控每一个@HystruxCommand注解创建一组度量，构建一组信息，然后通过图形化方式展示当前方法@HystruxCommand的状态信息</p>
<p><strong>项目中引入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入hystrix dashboard 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>入口类中开启hystrix dashboard</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span>  <span class="comment">//开启当前应用为仪表盘应用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixDashBoardApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(HystrixDashBoardApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>启动hystrix dashboard应用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:7006(dashboard端口)/hystrix</span></span><br></pre></td></tr></table></figure>

<p>端口号为你创建的springboot应用的端口号</p>
<p><strong>监控的项目中入口类中加入监控路径配置[新版本坑],并启动监控项目</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ServletRegistrationBean <span class="title function_">getServlet</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">HystrixMetricsStreamServlet</span> <span class="variable">streamServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HystrixMetricsStreamServlet</span>();</span><br><span class="line">  <span class="type">ServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>(streamServlet);</span><br><span class="line">  registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">  registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">  registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410185238959.png" alt="image-20240410185238959"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410185324393.png" alt="image-20240410185324393"></p>
<p><strong>解决方案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 新版本中springcloud将jquery版本升级为<span class="number">3.4</span><span class="number">.1</span>，定位到monitor.ftlh文件中，js的写法如下：</span><br><span class="line">	$(window).load(function() </span><br><span class="line">	</span><br><span class="line">- jquery <span class="number">3.4</span><span class="number">.1</span>已经废弃上面写法</span><br><span class="line"></span><br><span class="line">- 修改方案 修改monitor.ftlh为如下调用方式：</span><br><span class="line">	$(window).on(<span class="string">&quot;load&quot;</span>,function()</span><br><span class="line">	</span><br><span class="line">- 编译jar源文件，重新打包引入后，界面正常响应。</span><br></pre></td></tr></table></figure>

<p><strong>在maven仓库中找到这个jar包的位置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Maven\apache-maven-<span class="number">3.8</span><span class="number">.1</span>\maven-repo\org\springframework\cloud\spring-cloud-netflix-hystrix-dashboard\<span class="number">2.2</span><span class="number">.3</span>.RELEASE</span><br></pre></td></tr></table></figure>

<p>可能你的就是maven仓库的位置前面不一样，按照自己的路径一直往下找<br>在templates目录下的monitor.ftlh<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410185351891.png" alt="image-20240410185351891"><br>修改111行和149行的代码<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410185411285.png" alt="image-20240410185411285"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410185434664.png" alt="image-20240410185434664"><br>注意前面那段配置应该放在要监视的微服务项目里面，可以创建一个配置文件，我这里就放在启动类里了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410185449804.png" alt="image-20240410185449804"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410185502893.png" alt="image-20240410185502893"><br>这次就没有报错<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410185520426.png" alt="image-20240410185520426"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410185534354.png" alt="image-20240410185534354"></p>
<h3 id="停止维护"><a href="#停止维护" class="headerlink" title="停止维护"></a>停止维护</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Hystrix</span></span><br><span class="line"><span class="bullet">-</span> 官网：https://github.com/Netflix/Hystrix</span><br><span class="line"><span class="bullet">-</span> Hystrix is no longer in active development, and is currently in maintenance mode.</span><br><span class="line"><span class="section"># 日后如何解决服务雪崩</span></span><br><span class="line"><span class="bullet">-</span> 1. Hystrix (at version 1.5.18) is stable enough to meet the needs of Netflix for our existing applications. </span><br><span class="line"><span class="bullet">-</span> 2. resilience4j: Meanwhile, our focus has shifted towards more adaptive implementations that react to an application’s real time performance rather than pre-configured settings (for example, through adaptive concurrency limits). For the cases where something like Hystrix makes sense, we intend to continue using Hystrix for existing applications, and to leverage open and active projects like resilience4j for new internal projects. We are beginning to recommend others do the same.(resilience4j 属于spring cloud)</span><br><span class="line"><span class="bullet">-</span> 3. sentinel: 流量卫兵 属于spring cloud alibab 流量控制 降级策略  推荐 </span><br><span class="line"><span class="section"># Dashboard</span></span><br><span class="line"><span class="bullet">-</span> The hystrix-dashboard component of this project has been deprecated and moved to Netflix-Skunkworks/hystrix-dashboard. Please see the README there for more details including important security considerations.</span><br><span class="line"><span class="section"># Dashboard替代产品 </span></span><br><span class="line"><span class="bullet">-</span> Netflix-Skunkworks/hystrix-dashboard </span><br><span class="line"><span class="bullet">-</span> sentinel dashboard                    推荐</span><br></pre></td></tr></table></figure>

<h2 id="Gateway组件"><a href="#Gateway组件" class="headerlink" title="Gateway组件"></a>Gateway组件</h2><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 什么是网关</span></span><br><span class="line"><span class="bullet">-</span> 网关统一服务入口，可方便实现对平台众多服务接口进行管控,对访问服务的身份认证、防报文重放与防数据篡改、功能调用的业务鉴权、响应数据的脱敏、流量与并发控制，甚至基于API调用的计量或者计费等等。</span><br><span class="line"></span><br><span class="line"><span class="section"># 网关作用</span></span><br><span class="line"><span class="bullet">-</span> 网关 = 路由转发 + 过滤器</span><br><span class="line"><span class="bullet">-</span> 网关统一所有微服务入口</span><br><span class="line"><span class="bullet">-</span> 路由转发：接收一切外界请求，转发到后端的微服务上去，以及请求过程负载均衡</span><br><span class="line"><span class="bullet">-</span> 在服务网关中可以完成一系列的横切功能，例如权限校验、限流以及监控等，这些都可以通过过滤器完成</span><br><span class="line"></span><br><span class="line"><span class="section"># 网关功能详解</span></span><br><span class="line"><span class="bullet">-</span> 权限控制:网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 路由和负载均衡：一切请求都必须先经过网关，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 限流:当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> ......</span><br><span class="line"></span><br><span class="line"><span class="section"># 为什么需要网关</span></span><br><span class="line"><span class="bullet">-</span> 1.网关可以实现服务的统一管理</span><br><span class="line"><span class="bullet">-</span> 2.网关可以解决微服务中通用代码的冗余问题(如权限控制,流量监控,限流等)</span><br><span class="line"></span><br><span class="line"><span class="section"># 网关组件在微服务中架构</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410185549841.png" alt="image-20240410185549841"></p>
<h3 id="zuul"><a href="#zuul" class="headerlink" title="zuul"></a>zuul</h3><blockquote>
<p>属于netflix</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 定义</span></span><br><span class="line">zuul是从设备和网站到Netflix流媒体应用程序后端的所有请求的前门。作为一个边缘服务应用程序，zuul被构建为支持动态路由、监视、弹性和安全性</span><br><span class="line"><span class="section"># 版本说明</span></span><br><span class="line">目前zuul组件已经从1.0更新到2.0，但是作为springcloud官方不再推荐使用zuul2.0，但是依然支持zuul2.0</span><br><span class="line"><span class="section"># springcloud官方集成zuul文档 可自行学习</span></span><br><span class="line">https://cloud.spring.io/spring-cloud-netflix/2.2.x/reference/html/#netflix-zuul-starter</span><br></pre></td></tr></table></figure>

<h3 id="gateway"><a href="#gateway" class="headerlink" title="gateway"></a>gateway</h3><blockquote>
<p>属于spring  推荐</p>
<p>官网:<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud-gateway">https://spring.io/projects/spring-cloud-gateway</a></p>
</blockquote>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 和zuul区别</span></span><br><span class="line">Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux(异步非阻塞IO模型)，属于响应式编程的实现，具备更好的性能</span><br><span class="line"></span><br><span class="line"><span class="section"># 官方说明</span></span><br><span class="line">这个项目提供了一个在<span class="code">`springmvc之上`</span>构建API网关的库。springcloudgateway旨在提供一种简单而有效的方法来路由到api，并为api提供横切关注点，比如：安全性、监控/度量和弹性</span><br><span class="line"></span><br><span class="line"><span class="section"># 特性</span></span><br><span class="line"><span class="bullet">-</span> 基于springboot2.x 和 spring webFlux 和 Reactor 构建 响应式异步非阻塞IO模型 </span><br><span class="line"><span class="bullet">-</span> 动态路由</span><br><span class="line"><span class="bullet">-</span> 请求过滤</span><br><span class="line"></span><br><span class="line"><span class="section"># 注：gateway等价于路由转发(router)+请求过率(filter)</span></span><br><span class="line"></span><br><span class="line"><span class="section"># gateway核⼼概念</span></span><br><span class="line"><span class="bullet">-</span> Route（路由）:路由是构建⽹关的基本模块，它由ID，⽬标URI，⼀系列的断⾔和过滤器组成，如果断⾔为true则匹配该路由</span><br><span class="line"><span class="bullet">-</span> Predicate（断⾔、谓词）:开发⼈员可以匹配HTTP请求中的所有内容（例如请求头或请求参数），如果请求与断⾔相匹配则进⾏路由  后边章节会细讲</span><br><span class="line"><span class="bullet">-</span> Filter（过滤）:指的是Spring框架中GatewayFilter的实例，使⽤过滤器，可以在请求被路由前或者之后对请求进⾏修改</span><br><span class="line"><span class="section"># 我们学习的就是路由转发(router)+请求过率(filter)</span></span><br></pre></td></tr></table></figure>

<h4 id="gateway网关使用"><a href="#gateway网关使用" class="headerlink" title="gateway网关使用"></a>gateway网关使用</h4><h5 id="路由转发"><a href="#路由转发" class="headerlink" title="路由转发"></a>路由转发</h5><blockquote>
<p>配置文件配置路由 推荐 完全展开方式</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 开发一个独立的springboot应用</span></span><br><span class="line"><span class="bullet">-</span> 新建一个maven空项目 springcloud<span class="emphasis">_gateway</span></span><br><span class="line"><span class="emphasis">- 引入springboot和consul依赖</span></span><br><span class="line"><span class="emphasis">- 引入配置文件编写配置 建议用yml方式编写 防止混乱</span></span><br><span class="line"><span class="emphasis">- 构建启动类测试springboot是否可以正常启动以及服务是否可以成功注册</span></span><br><span class="line"><span class="emphasis"># 引入网关依赖</span></span><br><span class="line"><span class="emphasis">&lt;!--引入gateway网关依赖--&gt;</span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">  <span class="language-xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span></span>org.springframework.cloud<span class="language-xml"><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">  <span class="language-xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span>spring-cloud-starter-gateway<span class="language-xml"><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"># 我们先看路由转发 启动类别和商品服务 通过网关访问这两个服务</span></span><br><span class="line"><span class="emphasis">- 在配置文件编写规则配置 </span></span><br><span class="line"><span class="emphasis">    server:</span></span><br><span class="line"><span class="emphasis">      port: 7979</span></span><br><span class="line"><span class="emphasis">    spring:</span></span><br><span class="line"><span class="emphasis">      application:</span></span><br><span class="line"><span class="emphasis">        name: GATEWAY</span></span><br><span class="line"><span class="emphasis">      cloud:</span></span><br><span class="line"><span class="emphasis">        consul:</span></span><br><span class="line"><span class="emphasis">          host: localhost</span></span><br><span class="line"><span class="emphasis">          port: 8500</span></span><br><span class="line"><span class="emphasis">        gateway:</span></span><br><span class="line"><span class="emphasis">          routes:</span></span><br><span class="line"><span class="emphasis">            - id: category_</span>router         #路由商品和对象的唯一标识 路由id，自定义，只要唯一即可</span><br><span class="line"><span class="code">              uri: http://localhost:8081  #用来书写类别服务地址</span></span><br><span class="line"><span class="code">              predicates:                 #断言 用来配置路由规则 也就是判断请求是否符合路由规则的条件</span></span><br><span class="line"><span class="code">                - Path=/category/**       #指定路由规则 这个是按照路径匹配，只要以/category/开头就符合要求 即转到http://localhost:8081/category/**</span></span><br><span class="line"><span class="code">            - id: product_router</span></span><br><span class="line"><span class="code">              uri: http://localhost:8083</span></span><br><span class="line"><span class="code">              predicates:</span></span><br><span class="line"><span class="code">                - Path=/product           #更精确只要/product 即只要地址栏访问product 就转到http://localhost:8083/product</span></span><br><span class="line"><span class="code">- 启动会直接报错，这是因为网关是用最新的WebFlux编程模型开发的,也是一种web模型只是在springmvc的模型之上又做了优化，两种web模型不兼容</span></span><br><span class="line"><span class="code">- 解决办法：在依赖种去代表springmvc的spring-boot-starter-web ！！！</span></span><br><span class="line"><span class="code">- 重新import change再次启动</span></span><br><span class="line"><span class="code">访问：http://localhost:7979/category 和 http://localhost:7979/product都会正确转发</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>java代码方式配置路由 新建配置类 放com&#x2F;chabai&#x2F;config包下  优于配置文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.route.RouteLocator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouteLocator <span class="title function_">customRouteLocator</span><span class="params">(RouteLocatorBuilder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.routes()</span><br><span class="line">                <span class="comment">//类别路由配置</span></span><br><span class="line">                .route(<span class="string">&quot;category_router&quot;</span>, r -&gt; r.path(<span class="string">&quot;/category/**&quot;</span>) <span class="comment">//指明路径断言</span></span><br><span class="line">                        .uri(<span class="string">&quot;http://localhost:8081&quot;</span>))</span><br><span class="line">                <span class="comment">//商品路由配置</span></span><br><span class="line">                .route(<span class="string">&quot;product_router&quot;</span>, r -&gt; r.path(<span class="string">&quot;/product/**&quot;</span>)</span><br><span class="line">                        .uri(<span class="string">&quot;http://localhost:8083&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="网关的路由解析规则以及查看"><a href="#网关的路由解析规则以及查看" class="headerlink" title="网关的路由解析规则以及查看"></a>网关的路由解析规则以及查看</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 访问网关的路径</span></span><br><span class="line">http://localhost:7979/category</span><br><span class="line"><span class="section"># 现有网关的配置</span></span><br><span class="line"><span class="code">    server:</span></span><br><span class="line"><span class="code">      port: 7979</span></span><br><span class="line"><span class="code">    spring:</span></span><br><span class="line"><span class="code">      application:</span></span><br><span class="line"><span class="code">        name: GATEWAY</span></span><br><span class="line"><span class="code">      cloud:</span></span><br><span class="line"><span class="code">        consul:</span></span><br><span class="line"><span class="code">          host: localhost</span></span><br><span class="line"><span class="code">          port: 8500</span></span><br><span class="line"><span class="code">        gateway:</span></span><br><span class="line"><span class="code">          routes:</span></span><br><span class="line"><span class="code">            - id: category_router         #路由商品和对象的唯一标识 路由id，自定义，只要唯一即可</span></span><br><span class="line"><span class="code">              uri: http://localhost:8081  #用来书写类别服务地址</span></span><br><span class="line"><span class="code">              predicates:                 #断言 用来配置路由规则 也就是判断请求是否符合路由规则的条件</span></span><br><span class="line"><span class="code">                - Path=/category/**       #指定路由规则 这个是按照路径匹配，只要以/category/开头就符合要求 即转到http://localhost:8081/category/**</span></span><br><span class="line"><span class="code">            - id: product_router</span></span><br><span class="line"><span class="code">              uri: http://localhost:8083</span></span><br><span class="line"><span class="code">              predicates:</span></span><br><span class="line"><span class="code">                - Path=/product           #更精确只要/product 即只要地址栏访问product 就转到http://localhost:8083/product</span></span><br><span class="line"><span class="code"># 流程</span></span><br><span class="line"><span class="code">访问http://localhost:7979/category 会去网关7979的路由列表去匹配一个对应的 然后保留路径/category 把匹配到的uri拼接到前边对后端服务进行访问</span></span><br><span class="line"><span class="code"># 访问多个路径 配置文件支持多路径逗号隔开匹配的</span></span><br><span class="line"><span class="code">        - id: product_router</span></span><br><span class="line"><span class="code">          uri: http://localhost:8083</span></span><br><span class="line"><span class="code">          predicates:</span></span><br><span class="line"><span class="code">            - Path=/product,/product1 </span></span><br><span class="line"><span class="code"># 问题：每次这样写很麻烦</span></span><br><span class="line"><span class="code"># 解决办法：通配符方式写  在ProductController添加总入口 @RequestMapping(&quot;/product&quot;)</span></span><br><span class="line"><span class="code">        - id: product_router</span></span><br><span class="line"><span class="code">          uri: http://localhost:8083</span></span><br><span class="line"><span class="code">          predicates:</span></span><br><span class="line"><span class="code">            - Path=/product/**       </span></span><br><span class="line"><span class="code">            #更精确只要/product 即只要地址栏访问product 就转到http://localhost:8083/product</span></span><br><span class="line"><span class="code"># 访问：http://localhost:7979/product/product1测试结果</span></span><br><span class="line"><span class="code"># 通过网关提供的web路径查看路由详细规划 | 看配置文件也可(直接看即可)  这里讲解web路径查看</span></span><br><span class="line"><span class="code">- gateway提供路由访问规则列表的web界面,但是默认是关闭的,如果想要查看服务路由规则可以在配置文件中开启</span></span><br><span class="line"><span class="code">    management:</span></span><br><span class="line"><span class="code">      endpoints:</span></span><br><span class="line"><span class="code">        web:</span></span><br><span class="line"><span class="code">          exposure:</span></span><br><span class="line"><span class="code">            include: &quot;*&quot;   #开启所有web端点暴露</span></span><br><span class="line"><span class="code">- 访问：http://localhost:7979/actuator/gateway/routes查看</span></span><br></pre></td></tr></table></figure>

<h5 id="网管在路由转发时如何实现请求的负载均衡"><a href="#网管在路由转发时如何实现请求的负载均衡" class="headerlink" title="网管在路由转发时如何实现请求的负载均衡"></a>网管在路由转发时如何实现请求的负载均衡</h5><blockquote>
<p>现有网关配置存在问题</p>
</blockquote>
<p>现有路由配置方式在uri的属性中路径写死为服务的某个节点，这样没法实现请求的负载均衡</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7979</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">GATEWAY</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">category_router</span>         <span class="comment">#路由商品和对象的唯一标识 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8081</span>  <span class="comment">#用来书写类别服务地址</span></span><br><span class="line">          <span class="attr">predicates:</span>                 <span class="comment">#断言 用来配置路由规则 也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/category/**</span>       <span class="comment">#指定路由规则 这个是按照路径匹配，只要以/category/开头就符合要求 即转到http://localhost:8081/category/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">product_router</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8083</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/product/**</span>       <span class="comment">#更精确只要/product 即只要地址栏访问product 就转到http://localhost:8083/product</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如何配置网关转发实现负载均衡  Ribbon组件 负载均衡客户端组件  gateway默认集成了ribbon</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7979</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">GATEWAY</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">category_router</span>         <span class="comment">#路由商品和对象的唯一标识 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8081</span>  <span class="comment">#用来书写类别服务地址</span></span><br><span class="line">          <span class="attr">predicates:</span>                 <span class="comment">#断言 用来配置路由规则 也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/category/**</span>       <span class="comment">#指定路由规则 这个是按照路径匹配，只要以/category/开头就符合要求 即转到http://localhost:8081/category/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">product_router</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8083</span></span><br><span class="line">          <span class="comment"># lb是负载均衡，根据服务名拉取服务列表，实现负载均衡</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://PRODUCT</span>           <span class="comment">#lb代表转发后台服务使用负载均衡,PRODUCT 代表服务注册中心上的服务名</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/product/**</span>       <span class="comment">#更精确只要/product 即只要地址栏访问product 就转到http://localhost:8083/product    </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>路由配置小总结</p>
</blockquote>
<p>路由配置包括：3和4后边会学到</p>
<ol>
<li>路由id：路由的唯一标示</li>
<li>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</li>
<li>路由断言（predicates）：判断路由的规则 </li>
<li>路由过滤器（filters）：对请求或响应做处理</li>
</ol>
<blockquote>
<p>访问<a target="_blank" rel="noopener" href="http://localhost:7979/product/product">http://localhost:7979/product/product</a> 发现已实现了请求的负载均衡</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一次:product ok,当前提供服务的端口:8082</span><br><span class="line">第二次:product ok,当前提供服务的端口:8083</span><br></pre></td></tr></table></figure>

<h5 id="常用路由predicate-断言-验证"><a href="#常用路由predicate-断言-验证" class="headerlink" title="常用路由predicate(断言,验证)"></a>常用路由predicate(断言,验证)</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 断言 predicate  当请求到达网关时，网关前置处理，当请求满足断言的所有条件后，会向后端服务转发，在向后端服务转发之前会经过过滤器 ,不满足断言立即返回  自上而下匹配到第一个就停止</span></span><br><span class="line"></span><br><span class="line"><span class="section"># springcloud给我们提供了大量的断言，过滤工厂，功能已经写好了，我们按需选择用就行</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>网关断言使用 Route Predicate Factories</p>
<p>官网:<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-gateway/docs/3.0.8/reference/html/#gateway-request-predicates-factories">https://docs.spring.io/spring-cloud-gateway/docs/3.0.8/reference/html/#gateway-request-predicates-factories</a></p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>After Route</td>
<td>某个时间点后的请求才能生效</td>
<td>- After&#x3D;2021-08-18T13:30:33.993+08:00[Asia&#x2F;Shanghai]</td>
</tr>
<tr>
<td>Before Route</td>
<td>某个时间点之前的请求才能生效</td>
<td>- Before&#x3D;2021-08-18T13:30:33.993+08:00[Asia&#x2F;Shanghai]</td>
</tr>
<tr>
<td>Between Route</td>
<td>某两个时间点之间的请求才能生效</td>
<td>- Between&#x3D;2021-08-18T13:30:33.993+08:00[Asia&#x2F;Shanghai], 2021-08-1T13:30:33.993+08:00[Asia&#x2F;Shanghai]</td>
</tr>
<tr>
<td>Cookie Route</td>
<td>请求必须包含某些cookie才能生效</td>
<td>- Cookie&#x3D;name,chabai</td>
</tr>
<tr>
<td>Header Route</td>
<td>请求必须包含某些header才能生效</td>
<td>- Header&#x3D;X-Request-Id, \d+</td>
</tr>
<tr>
<td>Host  Route</td>
<td>请求必须是访问某个host（域名）才能生效</td>
<td>- Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td>
</tr>
<tr>
<td>Method Route</td>
<td>请求方式必须是指定方式才能生效</td>
<td>- Method&#x3D;GET,POST</td>
</tr>
<tr>
<td>Path Route</td>
<td>请求路径必须符合指定规则才能生效</td>
<td>- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td>
</tr>
<tr>
<td>Query Route</td>
<td>请求参数必须包含指定参数才能生效</td>
<td>- Query&#x3D;name, Jack或者- Query&#x3D;name</td>
</tr>
<tr>
<td>RemoteAddr Route</td>
<td>请求者的ip必须是指定范围才能生效</td>
<td>- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td>
</tr>
<tr>
<td>Weight Route</td>
<td>权重处理才能生效</td>
<td></td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
</tbody></table>
<blockquote>
<p>predicate和filter再配置文件如何使用</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span>  <span class="comment"># 断言</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span> </span><br><span class="line">        <span class="attr">filters:</span>     <span class="comment"># 过滤器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=name,dyk</span> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们这里演示几个常用的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">指定日期之后的请求进行路由</span><br><span class="line">After=<span class="number">2020</span>-<span class="number">07</span>-21T11:<span class="number">33</span>:<span class="number">33.993</span>+08:<span class="number">00</span>[Asia/Shanghai]  			</span><br><span class="line"></span><br><span class="line">指定日期之前的请求进行路由，过了时间失效</span><br><span class="line">Before=<span class="number">2020</span>-<span class="number">07</span>-21T11:<span class="number">33</span>:<span class="number">33.993</span>+08:<span class="number">00</span>[Asia/Shanghai]       </span><br><span class="line"></span><br><span class="line">指定时间段内有效</span><br><span class="line">Between=<span class="number">2020</span>-<span class="number">07</span>-21T11:<span class="number">33</span>:<span class="number">33.993</span>+08:<span class="number">00</span>[Asia/Shanghai],<span class="number">2021</span>-<span class="number">07</span>-21T11:<span class="number">33</span>:<span class="number">33.993</span>+08:<span class="number">00</span>[Asia/Shanghai] </span><br><span class="line"></span><br><span class="line">指定cookie的请求进行路由</span><br><span class="line"></span><br><span class="line">curl http:<span class="comment">//localhost:8888/product --cookie &quot;name=chabai&quot; #curl工具访问添加cookie win10默认安装</span></span><br><span class="line"></span><br><span class="line">- Cookie=name,[A-Za-z0-<span class="number">9</span>]+    # [A-Za-z0-<span class="number">9</span>]+ 这是正则表达式</span><br><span class="line">curl工具访问如下图:</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410185741078.png" alt="image-20240410185741078"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基于请求头中的指定属性的正则匹配路由(这里全是整数)   #可用postman工具添加请求头</span><br><span class="line">- Header=X-Request-Id, \d+	</span><br><span class="line">如下图:</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410185759374.png" alt="image-20240410185759374"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基于指定的请求方式请求进行路由</span><br><span class="line">- Method=GET,POST</span><br></pre></td></tr></table></figure>

<h5 id="网关的过滤-Filter"><a href="#网关的过滤-Filter" class="headerlink" title="网关的过滤 Filter"></a>网关的过滤 Filter</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 当请求满足断言的所有条件后，会像后端服务转发，再向后端服务转发之前会经过过滤器</span></span><br><span class="line"></span><br><span class="line"><span class="section"># GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理</span></span><br></pre></td></tr></table></figure>


<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410185811666.png" alt="image-20240410185811666"></p>
<blockquote>
<p>网关过滤使用 GateWayFilter Factories</p>
<p>官网：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-gateway/docs/3.0.8/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/3.0.8/reference/html/#gatewayfilter-factories</a></p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AddRequestHeader Filter</td>
<td>给当前请求添加一个请求头</td>
</tr>
<tr>
<td>RemoveRequestHeader Filter</td>
<td>移除请求中的一个请求头</td>
</tr>
<tr>
<td>AddResponseHeader Filter</td>
<td>给响应结果中添加一个响应头</td>
</tr>
<tr>
<td>RemoveResponseHeader Filter</td>
<td>从响应结果中移除有一个响应头</td>
</tr>
<tr>
<td>RequestRateLimiter Filter</td>
<td>限制请求的流量</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
</tbody></table>
<blockquote>
<p>常用filter使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">用来给路由对象所有转发的请求加入指定请求头信息</span><br><span class="line">- AddRequestHeader=X-Request-red, blue	</span><br><span class="line"></span><br><span class="line">用来给路由对象所有转发的请求加入指定请求参数				</span><br><span class="line">- AddRequestParameter=red, blue	</span><br><span class="line"></span><br><span class="line">用来给路由对象所有转发的请求加入指定响应头信息											</span><br><span class="line">- AddResponseHeader=X-Response-Red, AAA	</span><br><span class="line">- 	</span><br><span class="line">用来给路由对象所有转发的请求加入指定请求的url加上指定前缀的信息						</span><br><span class="line">- PrefixPath=/mypath	</span><br><span class="line">如浏览器访问网关地址 /list  前缀地址/mypath  转发到服务器地址为: uri+前缀地址+地址栏路径  /mypath/list</span><br><span class="line"></span><br><span class="line">用来给对象路由的转发请求的url去掉指定n个前缀</span><br><span class="line">- StripPrefix=<span class="number">2</span></span><br><span class="line">如浏览器访问网关地址 /product/list    StripPrefix=<span class="number">1</span>      ===&gt;/list   </span><br></pre></td></tr></table></figure>

<blockquote>
<p>使配置的filter对所有的路由都生效</p>
</blockquote>
<p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># 默认过滤项</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AddRequestHeader=name,dyk</span> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>自定义全局网关filter 当内置filter不能满足我们时 可自定义 所有请求都要经过全局filter之后再转发到后端服务</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//放在com/chabai/filters下 </span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(CustomGlobalFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类似javaweb doFilter</span></span><br><span class="line">    <span class="comment">//exchange ；交换 request response 封装了 request response</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        log.info(<span class="string">&quot;进入自定义的filter&quot;</span>);</span><br><span class="line">        Mono&lt;Void&gt; filter = chain.filter(exchange); <span class="comment">//放行filter继续向后执行微服务</span></span><br><span class="line">        log.info(<span class="string">&quot;响应回来filter处理&quot;</span>);              <span class="comment">//执行完微服务回来</span></span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//order:排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 用来指定filter执行顺序 默认顺序按照自然排序进行  -1在所有filter执行之前执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>过滤器执行顺序</p>
</blockquote>
<p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p>
<p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410185836727.png" alt="image-20240410185836727"><br>排序的规则是什么呢？</p>
<ul>
<li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li>
<li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li>
<li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li>
<li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li>
</ul>
<h5 id="网关跨域问题"><a href="#网关跨域问题" class="headerlink" title="网关跨域问题"></a>网关跨域问题</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># 。。。</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求 </span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure>

<h2 id="Config组件"><a href="#Config组件" class="headerlink" title="Config组件"></a>Config组件</h2><p>config(配置)又称为 统一配置中心顾名思义,就是将配置统一管理,配置统一管理的好处是在日后大规模集群部署服务应用时相同的服务配置一致,日后再修改配置只需要统一修改全部同步,不需要一个一个服务手动维护。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410185853827.png" alt="image-20240410185853827"><br>SpringCloud Config分为服务端和客户端两部分。</p>
<p>服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密&#x2F;解密信息等访问接口。</p>
<p>客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。</p>
<ul>
<li>集中管理配置文件</li>
<li>不同环境不同配置，动态化的配置更新，分环境部署比如dev&#x2F;test&#x2F;prod&#x2F;beta&#x2F;release</li>
<li>运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息</li>
<li>当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置</li>
<li>将配置信息以REST接口的形式暴露 - post&#x2F;crul访问刷新即可…</li>
</ul>
<h3 id="Config-Server-开发"><a href="#Config-Server-开发" class="headerlink" title="Config Server 开发"></a>Config Server 开发</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入统一配置中心--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="开启统一配置中心服务"><a href="#开启统一配置中心服务" class="headerlink" title="开启统一配置中心服务"></a>开启统一配置中心服务</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">SpringBootApplication</span></span><br><span class="line">@<span class="title class_">EnableConfigServer</span></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">Configserver7878Application</span> &#123;</span><br><span class="line">	public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">		<span class="title class_">SpringApplication</span>.<span class="title function_">run</span>(<span class="title class_">Configserver7878Application</span>.<span class="property">class</span>, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="property">port</span>=<span class="number">7878</span></span><br><span class="line">spring.<span class="property">application</span>.<span class="property">name</span>=configserver</span><br><span class="line">spring.<span class="property">cloud</span>.<span class="property">consul</span>.<span class="property">host</span>=localhost</span><br><span class="line">spring.<span class="property">cloud</span>.<span class="property">consul</span>.<span class="property">port</span>=<span class="number">8500</span></span><br></pre></td></tr></table></figure>

<h4 id="直接启动服务报错"><a href="#直接启动服务报错" class="headerlink" title="直接启动服务报错"></a>直接启动服务报错</h4><p>没有指定远程仓库的相关配置<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410190025743.png" alt="image-20240410190025743"></p>
<h4 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h4><p>github创建一个仓库，在统一配置中心服务中修改配置文件指向远程仓库地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定仓库的url</span></span><br><span class="line">spring.cloud.config.server.git.uri=https://github.com/chenyn-java/configservers.git  </span><br><span class="line"><span class="comment"># 指定访问的分支 </span></span><br><span class="line">spring.cloud.config.server.git.default-label=master									</span><br><span class="line"><span class="comment">#spring.cloud.config.server.git.username=       私有仓库访问用户名</span></span><br><span class="line"><span class="comment">#spring.cloud.config.server.git.password=		私有仓库访问密码</span></span><br></pre></td></tr></table></figure>

<h4 id="拉取远端配置规则"><a href="#拉取远端配置规则" class="headerlink" title="拉取远端配置规则"></a>拉取远端配置规则</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- label/name-profiles.<span class="property">yml</span>|properties|json</span><br><span class="line">	<span class="string">`label   代表去那个分支获取 默认使用master分支</span></span><br><span class="line"><span class="string">	`</span>name    代表读取那个具体的配置文件文件名称</span><br><span class="line">	<span class="string">`profile 代表读取配置文件环境</span></span><br><span class="line"><span class="string">1234</span></span><br><span class="line"><span class="string">server:</span></span><br><span class="line"><span class="string">  port: 7878</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">spring:</span></span><br><span class="line"><span class="string">  application:</span></span><br><span class="line"><span class="string">    name:  configserver #注册进Eureka服务器的微服务名</span></span><br><span class="line"><span class="string">  cloud:</span></span><br><span class="line"><span class="string">    config:</span></span><br><span class="line"><span class="string">      server:</span></span><br><span class="line"><span class="string">        git:</span></span><br><span class="line"><span class="string">          uri: https://github.com/chenyn-java/configservers.git #GitHub上面的git仓库名字</span></span><br><span class="line"><span class="string">        ####搜索目录仓库名</span></span><br><span class="line"><span class="string">          search-paths:</span></span><br><span class="line"><span class="string">            - configservers</span></span><br><span class="line"><span class="string">      ####读取分支</span></span><br><span class="line"><span class="string">      label: master</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#服务注册到eureka地址</span></span><br><span class="line"><span class="string">eureka:</span></span><br><span class="line"><span class="string">  client:</span></span><br><span class="line"><span class="string">    service-url:</span></span><br><span class="line"><span class="string">      defaultZone: http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>

<h3 id="Config-Client-开发"><a href="#Config-Client-开发" class="headerlink" title="Config Client 开发"></a>Config Client 开发</h3><h4 id="项目中引入config-client依赖"><a href="#项目中引入config-client依赖" class="headerlink" title="项目中引入config client依赖"></a>项目中引入config client依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入config client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"> #开启统一配置中心服务</span></span><br><span class="line"><span class="attr">spring.cloud.config.discovery.enabled</span>=<span class="string">true   </span></span><br><span class="line"><span class="comment">#指定统一配置服务中心的服务唯一标识          </span></span><br><span class="line"><span class="attr">spring.cloud.config.discovery.service-id</span>=<span class="string">configserver     </span></span><br><span class="line"><span class="comment">#指定从仓库的那个分支拉取配置	</span></span><br><span class="line"><span class="attr">spring.cloud.config.label</span>=<span class="string">master</span></span><br><span class="line"><span class="comment">#指定拉取配置文件的名称													</span></span><br><span class="line"><span class="attr">spring.cloud.config.name</span>=<span class="string">client	</span></span><br><span class="line"><span class="comment">#指定拉取配置文件的环境													</span></span><br><span class="line"><span class="attr">spring.cloud.config.profile</span>=<span class="string">dev														</span></span><br><span class="line"><span class="attr">12345678910</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">3355</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line"><span class="comment">    #Config客户端配置</span></span><br><span class="line">    <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">label</span>: <span class="string">master #分支名称</span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">client	 #配置文件名称</span></span><br><span class="line">      <span class="attr">profile</span>: <span class="string">dev #读取后缀名称   上述3个综合：master分支上client-dev.yml的配置文件被读取</span></span><br><span class="line">      <span class="attr">uri</span>: <span class="string">http://localhost:7878 #配置中心地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>

<h4 id="远程仓库配置文件"><a href="#远程仓库配置文件" class="headerlink" title="远程仓库配置文件"></a>远程仓库配置文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">远程仓库创建配置文件</span><br><span class="line">- client.properties										[用来存放公共配置][]</span><br><span class="line">	spring.application.name=configclient</span><br><span class="line">	spring.cloud.consul.host=localhost</span><br><span class="line">	spring.cloud.consul.port=<span class="number">8500</span></span><br><span class="line"></span><br><span class="line">- client-dev.properties  							[用来存放研发相关配置][注意:这里端口为例,以后不同配置分别存放]</span><br><span class="line">	server.port=<span class="number">9099</span></span><br><span class="line"></span><br><span class="line">- client-prod.properties							[用来存放生产相关配置][]</span><br><span class="line">	server.port=<span class="number">9098</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240410185909799.png" alt="image-20240410185909799"></p>
<h4 id="直接启动过程中发现无法启动直接报错"><a href="#直接启动过程中发现无法启动直接报错" class="headerlink" title="直接启动过程中发现无法启动直接报错"></a>直接启动过程中发现无法启动直接报错</h4><h5 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h5><p>项目中目前使用的是application.pAAroperties启动项目,使用这个配置文件在springboot项目启动过程中不会等待远程配置拉取,直接根据配置文件中内容启动,因此当需要注册中心,服务端口等信息时,远程配置还没有拉取到,所以直接报错</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>应该在项目启动时先等待拉取远程配置,拉取远程配置成功之后再根据远程配置信息启动即可,为了完成上述要求springboot官方提供了一种解决方案,就是在使用统一配置中心时应该将微服务的配置文件名修改为bootstrap.(properties|yml),bootstrap.properties作为配置启动项目时,会优先拉取远程配置,远程配置拉取成功之后根据远程配置启动当前应用。</p>
<ul>
<li>applicaiton.yml是用户级的资源配置项</li>
<li>bootstrap.yml是系统级的，优先级更加高</li>
</ul>
<p><strong>名称必须为bootstrap.yml&#x2F;properties</strong></p>
<h4 id="手动配置刷新"><a href="#手动配置刷新" class="headerlink" title="手动配置刷新"></a>手动配置刷新</h4><p>在生产环境中,微服务可能非常多,每次修改完远端配置之后,不可能对所有服务进行重新启动,这个时候需要让修改配置的服务能够刷新远端修改之后的配置,从而不要每次重启服务才能生效,进一步提高微服务系统的维护效率。在springcloud中也为我们提供了手动刷新配置和自动刷新配置两种策略,这里我们先使用手动配置文件刷新。</p>
<h5 id="引入actuator监控依赖"><a href="#引入actuator监控依赖" class="headerlink" title="引入actuator监控依赖"></a>引入actuator监控依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="在config-client端加入刷新暴露端点"><a href="#在config-client端加入刷新暴露端点" class="headerlink" title="在config client端加入刷新暴露端点"></a>在config client端加入刷新暴露端点</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=*          <span class="comment">#开启所有web端点暴露</span></span><br></pre></td></tr></table></figure>

<p>修改YML，添加暴露监控端口配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴露监控端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="在需要刷新代码的类中加入刷新配置的注解"><a href="#在需要刷新代码的类中加入刷新配置的注解" class="headerlink" title="在需要刷新代码的类中加入刷新配置的注解"></a>在需要刷新代码的类中加入刷新配置的注解</h5><p>@RefreshScope</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;当前加载配置文件信息为:[&#123;&#125;]&quot;</span>,name);</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改之后在访问</p>
<ul>
<li>发现并没有自动刷新配置?</li>
<li>必须调用刷新配置接口才能刷新配置</li>
</ul>
<h5 id="需要手动发送post请求才会刷新配置"><a href="#需要手动发送post请求才会刷新配置" class="headerlink" title="需要手动发送post请求才会刷新配置"></a>需要手动发送post请求才会刷新配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http:<span class="comment">//localhost:9099/actuator/refresh</span></span><br></pre></td></tr></table></figure>

<p>在次访问发现配置已经成功刷新</p>
<h1 id="springcloudalibaba"><a href="#springcloudalibaba" class="headerlink" title="springcloudalibaba"></a>springcloudalibaba</h1><h2 id="简介和组件介绍"><a href="#简介和组件介绍" class="headerlink" title="简介和组件介绍"></a>简介和组件介绍</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240418224444557.png" alt="image-20240418224444557"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240418224416322.png" alt="image-20240418224416322"></p>
<h2 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="思路整理-1"><a href="#思路整理-1" class="headerlink" title="思路整理"></a>思路整理</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 创建全局父项目维护版本</span></span><br><span class="line">继承springboot父项目        2.2.5.RELEASE</span><br><span class="line">维护springcloud依赖         Hoxton.SR6</span><br><span class="line">维护springcloudalibaba依赖  2.1.2.RELEASE</span><br></pre></td></tr></table></figure>

<h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    &lt;groupId&gt;org.example&lt;/groupId&gt;</span></span><br><span class="line"><span class="code">    &lt;artifactId&gt;springcloudalibaba_parent&lt;/artifactId&gt;</span></span><br><span class="line"><span class="code">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    &lt;!--继承springboot的父项目--&gt;</span></span><br><span class="line"><span class="code">    &lt;parent&gt;</span></span><br><span class="line"><span class="code">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line"><span class="code">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span></span><br><span class="line"><span class="code">        &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;</span></span><br><span class="line"><span class="code">    &lt;/parent&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    &lt;properties&gt;</span></span><br><span class="line"><span class="code">        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span></span><br><span class="line"><span class="code">        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span></span><br><span class="line"><span class="code">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        &lt;!--定义springcloud使用版本号--&gt;</span></span><br><span class="line"><span class="code">        &lt;spring-cloud.version&gt;Hoxton.SR6&lt;/spring-cloud.version&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        &lt;!--定义springcloudaliba使用版本号--&gt;</span></span><br><span class="line"><span class="code">        &lt;spring.cloud.alibaba.version&gt;2.1.2.RELEASE&lt;/spring.cloud.alibaba.version&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    &lt;/properties&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    &lt;!--维护依赖--&gt;</span></span><br><span class="line"><span class="code">    &lt;dependencyManagement&gt;</span></span><br><span class="line"><span class="code">        &lt;dependencies&gt;</span></span><br><span class="line"><span class="code">            &lt;!--全局管理springcloud版本,并不会引入具体依赖--&gt;</span></span><br><span class="line"><span class="code">            &lt;dependency&gt;</span></span><br><span class="line"><span class="code">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="code">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span></span><br><span class="line"><span class="code">                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="code">                &lt;type&gt;pom&lt;/type&gt;</span></span><br><span class="line"><span class="code">                &lt;scope&gt;import&lt;/scope&gt;</span></span><br><span class="line"><span class="code">            &lt;/dependency&gt;</span></span><br><span class="line"><span class="code">            &lt;!--维护sprincloudalibaba--&gt;</span></span><br><span class="line"><span class="code">            &lt;dependency&gt;</span></span><br><span class="line"><span class="code">                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="code">                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span></span><br><span class="line"><span class="code">                &lt;version&gt;$&#123;spring.cloud.alibaba.version&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="code">                &lt;type&gt;pom&lt;/type&gt;</span></span><br><span class="line"><span class="code">                &lt;scope&gt;import&lt;/scope&gt;</span></span><br><span class="line"><span class="code">            &lt;/dependency&gt;</span></span><br><span class="line"><span class="code">        &lt;/dependencies&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    &lt;/dependencyManagement&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建一个普通的maven项目，删除src   作为父模块管理维护依赖  同时检查项目结构里项目和模块sdk jdk 和maven上的java版本以及maven配置仓库</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240419112525488.png" alt="image-20240419112525488"></p>
<h2 id="nacos组件"><a href="#nacos组件" class="headerlink" title="nacos组件"></a>nacos组件</h2><h3 id="nacos简介"><a href="#nacos简介" class="headerlink" title="nacos简介"></a>nacos简介</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Nacos组件</span></span><br><span class="line">命名: Name Service(服务注册中心) Configuration Service(统一配置中心)</span><br><span class="line">Nacos名字由来 = Name + Configuration +Service</span><br><span class="line">作用: 服务注册中心|统一配置中心</span><br><span class="line"><span class="section"># 我们先来看作为服务注册中心怎么用</span></span><br></pre></td></tr></table></figure>

<h3 id="nacos安装和配置"><a href="#nacos安装和配置" class="headerlink" title="nacos安装和配置"></a>nacos安装和配置</h3><blockquote>
<p>从下载地址下载nacos 版本选择1.4.6 linux版</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 官网地址: https://nacos.io</span><br><span class="line"><span class="bullet">-</span> github仓库地址 : https://github.com/alibaba/nacos</span><br><span class="line"><span class="bullet">-</span> 下载地址 : https://github.com/alibaba/nacos/releases</span><br></pre></td></tr></table></figure>

<blockquote>
<p>环境准备</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 推荐使用linux/unix/mac 必备</span><br><span class="line"><span class="bullet">-</span> 64 bit JDK 1.8+       必备</span><br><span class="line"><span class="bullet">-</span> maven 3.2.x+</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上传jdk，nacos安装包到服务器</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 安装jdk</span></span><br><span class="line">rpm -ivh jdk-xxxx.rpm</span><br><span class="line"><span class="section"># 配置环境变量 rpm安装会配一个临时环境变量  但是建议还是要配</span></span><br><span class="line"><span class="bullet">-</span> 找到jdk的bin目录：find / -name java</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 把它添加到环境变量</span><br><span class="line">a. vim /etc/profile  </span><br><span class="line">添加两句话 export JAVA<span class="emphasis">_HOME=/usr/lib/jvm/jdkXXXXXX  export PATH=$PATH:$JAVA_</span>HOME/bin</span><br><span class="line">wq退出</span><br><span class="line"></span><br><span class="line">b.source /etc/profile重新加载配置生效</span><br><span class="line"><span class="section"># 安装nacos</span></span><br><span class="line"><span class="bullet">-</span> 1.解压缩nacos安装包 tar -zxvf nacos-server-1.4.6.tar.gz</span><br><span class="line"><span class="bullet">-</span> 2.解压缩之后有个nacos目录 查看nacos目录结构</span><br><span class="line"><span class="code">     drwxr-xr-x 2 root root   4096 Apr 19 12:31 bin    启动关闭nacos脚本目录</span></span><br><span class="line"><span class="code">     drwxr-xr-x 2  502 games  4096 May 25  2023 conf   配置nacos配置文件目录</span></span><br><span class="line"><span class="code">     drwxr-xr-x 2 root root   4096 Apr 19 12:31 target nacos-service 核心jar包</span></span><br><span class="line"><span class="code">- 注：如果使用的使aliyun服务器记的在安全组规则开启端口 不然后边无法访问web页面 </span></span><br><span class="line"><span class="code">- 3.启动nacos服务 默认nacos以集群模式启动，必须满足多个节点 我们这里单机启动</span></span><br><span class="line"><span class="code">    单机启动：在bin目录执行 ./startup.sh -m standalone</span></span><br><span class="line"><span class="code">    启动后如何看日志 后台启动的不能直接看到日志  查看日志: tail -f ncos.log nacos目录下的logs不是bin下</span></span><br><span class="line"><span class="code">- 4.访问web端口</span></span><br><span class="line"><span class="code">    http://47.115.221.37:8848/nacos    中间是自己服务器公网ips  账号密码默认nacos</span></span><br><span class="line"><span class="code">- 到此为止服务注册中心已经搭建完毕 接下来看看如何向服务注册中注册服务 以及一些细节问题</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240419125456139.png" alt="image-20240419125456139"></p>
<h3 id="nacos-client开发"><a href="#nacos-client开发" class="headerlink" title="nacos client开发"></a>nacos client开发</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 创建一个独立springboot应用</span></span><br><span class="line">1.新建一个maven空项目 canosclient</span><br><span class="line">2.引入springboot依赖  imort changes</span><br><span class="line">3.引入配置文件  配置服务名和端口号</span><br><span class="line">4.编写启动类测试springboot应用是否可以正常去启动</span><br><span class="line"><span class="section"># 引入nacos client依赖</span></span><br><span class="line"><span class="code">        &lt;!--引入nacosclient依赖--&gt;</span></span><br><span class="line"><span class="code">        &lt;dependency&gt;</span></span><br><span class="line"><span class="code">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="code">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span></span><br><span class="line"><span class="code">        &lt;/dependency&gt;</span></span><br><span class="line"><span class="code"># 在配置文件提供服务注册中心地址 我们这里先写总地址</span></span><br><span class="line"><span class="code">spring.cloud.nacos.server-addr=47.115.221.37:8848</span></span><br><span class="line"><span class="code"># 在启动类加上注解@EnableDiscoveryClient 开启服务注册   这个注解可以省略不写</span></span><br><span class="line"><span class="code"># 启动服务看是否注册成功  注：关闭服务立即移除没有自我保护机制</span></span><br></pre></td></tr></table></figure>

<h3 id="nacos细节"><a href="#nacos细节" class="headerlink" title="nacos细节"></a>nacos细节</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Nacos 作为服务注册中心细节</span></span><br><span class="line"><span class="bullet">-</span> 安装并启动nacos server</span><br><span class="line"><span class="bullet">-</span> 默监听web端口：8848</span><br><span class="line"><span class="bullet">-</span> 访问web界面：http://47.115.221.37:8848/nacos </span><br><span class="line"><span class="section"># 开发微服务进行注册</span></span><br><span class="line"><span class="bullet">-</span> a.创建独立springboot应用</span><br><span class="line"><span class="bullet">-</span> b.引入依赖 springcloud-starter-alibaba-nacos-discovery</span><br><span class="line"><span class="bullet">-</span> c.编写配置 配置服务注册中心地址  spring.cloud.nacos.server-addr=47.115.221.37:8848  我们这里先写总地址 作为nacos server注册地址是spring.cloud.nacos.discovery.server-addr=$&#123;spring.cloud.nacos.server-addr&#125;</span><br><span class="line"><span class="code">    可如下配置：</span></span><br><span class="line"><span class="code">    #nacos 总地址</span></span><br><span class="line"><span class="code">    spring.cloud.nacos.server-addr=47.115.221.37:8848   </span></span><br><span class="line"><span class="code">    #作为nacos client注册地址 默认值引用了上边spring.cloud.nacos.server-addr 可不写</span></span><br><span class="line"><span class="code">    #spring.cloud.nacos.discovery.server-addr=$&#123;spring.cloud.nacos.server-addr&#125; </span></span><br><span class="line"><span class="code">- d.指定向nacos server注册服务名称</span></span><br><span class="line"><span class="code">    可如下配置</span></span><br><span class="line"><span class="code">    spring.application.name=NACOSCLIETN</span></span><br><span class="line"><span class="code">    #指定向nacos server注册服务名称 默认引用了我们写的微服务名 可不写 </span></span><br><span class="line"><span class="code">    #spring.cloud.nacos.discovery.service=$&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="code">    如果我们这里给定服务名称以这里为主 ，即</span></span><br><span class="line"><span class="code">    spring.cloud.nacos.discovery.service=aa #服务名就是aa不是NACOSCLIETN</span></span><br></pre></td></tr></table></figure>

<h2 id="服务间通信"><a href="#服务间通信" class="headerlink" title="服务间通信"></a>服务间通信</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 服务间通信 两种方式</span></span><br><span class="line"><span class="bullet">-</span> a.Http Rest 推荐</span><br><span class="line"><span class="bullet">-</span> b.RPC</span><br><span class="line"><span class="section"># 使用Rest通信方式实现服务间通信</span></span><br><span class="line"><span class="bullet">-</span> 1.sprig框架提供的RestTemplate  并且使用Ribbon实现负载均衡</span><br><span class="line"><span class="bullet">-</span> 2.OpenFeign组件  推荐</span><br><span class="line">演示如下；</span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建两个微服务并注册到nacos server  用于测试通信</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 新建两个独立springboot应用并注册到nacos server </span></span><br><span class="line"><span class="bullet">-</span> 新建一个maven空项目   users products</span><br><span class="line"><span class="bullet">-</span> 引入springboot和nacos client依赖</span><br><span class="line"><span class="bullet">-</span> 引入配置文件 配置服务端口号 名称 服务注册中心地址</span><br><span class="line"><span class="bullet">-</span> 编写启动类并加注解@EnableDiscoveryClient测试springboot是否可以成功启动和查看微服务在注册中心是否成功注册</span><br><span class="line"><span class="section"># 接下来分别用两种方式实现服务通信 如下 用户服务调用商品服务</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>两个服务都暴漏一个接口供通信使用</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 首先在商品服务构建(暴漏)一个接口 供用户服务调用 com/chabai/controller/ProductsController</span></span><br><span class="line">package com.chabai.controller;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class ProductsController &#123;</span><br><span class="line"></span><br><span class="line"><span class="code">    private static final Logger log = LoggerFactory.getLogger(ProductsController.class);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    @Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line"><span class="code">    private int port;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    @GetMapping(&quot;/product&quot;)</span></span><br><span class="line"><span class="code">    public String product(Integer id)&#123;</span></span><br><span class="line"><span class="code">        log.info(&quot;id:&#123;&#125;&quot;,id);</span></span><br><span class="line"><span class="code">        return &quot;商品服务: &quot;+id+ &quot;,当前提供服务的端口为:&quot;+port;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"># 用户服务构建一个接口,里边调用商品服务接口</span></span><br><span class="line"><span class="code">package com.chabai.controller;</span></span><br><span class="line"><span class="code">import org.slf4j.Logger;</span></span><br><span class="line"><span class="code">import org.slf4j.LoggerFactory;</span></span><br><span class="line"><span class="code">import org.springframework.web.bind.annotation.GetMapping;</span></span><br><span class="line"><span class="code">import org.springframework.web.bind.annotation.RestController;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class UsersController &#123;</span><br><span class="line"></span><br><span class="line"><span class="code">    private static final Logger log = LoggerFactory.getLogger(UsersController.class);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    @GetMapping(&quot;/invoke&quot;)</span></span><br><span class="line"><span class="code">    public String invokeProduct()&#123;</span></span><br><span class="line"><span class="code">        log.info(&quot;调用用户服务&quot;);</span></span><br><span class="line"><span class="code">        return &quot;调用用户服务成功&quot;;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"># 测试两个微服务是否可以成功启动 此时并没有调用服务 即通信 我们只是通过浏览器测试接口是否则正常</span></span><br><span class="line"><span class="code">- 访问：http://localhost:8986/product?id=1</span></span><br><span class="line"><span class="code">- 访问：http://localhost:8987/invoke</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>方式1：RestTemplate实现通信</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># RestTemplate方式</span></span><br><span class="line">package com.chabai.controller;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class UsersController &#123;</span><br><span class="line"></span><br><span class="line"><span class="code">    private static final Logger log = LoggerFactory.getLogger(UsersController.class);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    @GetMapping(&quot;/invoke&quot;)</span></span><br><span class="line"><span class="code">    public String invokeProduct()&#123;</span></span><br><span class="line"><span class="code">        log.info(&quot;调用用户服务&quot;);</span></span><br><span class="line"><span class="code">        String result = new RestTemplate().getForObject(&quot;http://localhost:8986/product?id=1&quot;, String.class);</span></span><br><span class="line"><span class="code">        return result;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 测试是否调用成功</span></span><br><span class="line">访问：http://localhost:8987/invoke</span><br><span class="line"><span class="section"># 缺点：1.无法实现负载均衡 2，代码写死到路径中不利于后续维护 </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Ribbon组件实现服务负载均衡</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Ribbon组件实现负载均衡</span></span><br><span class="line"><span class="bullet">-</span> 引入ribbon依赖 nacos client已集成ribbon我们不用显示引入</span><br><span class="line"><span class="bullet">-</span> 使用ribbon完成负载均衡 三种方法 DiscoveryClient LoadBalanceClient @LoadBalance</span><br><span class="line"><span class="section"># 1.DiscoveryClient对象 只要引入ribbon依赖 工厂中就有了DiscoveryClient对象 需要时注入即可 也没有负载均衡</span></span><br><span class="line"><span class="code">    package com.chabai.controller;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    import org.slf4j.Logger;</span></span><br><span class="line"><span class="code">    import org.slf4j.LoggerFactory;</span></span><br><span class="line"><span class="code">    import org.springframework.beans.factory.annotation.Autowired;</span></span><br><span class="line"><span class="code">    import org.springframework.cloud.client.ServiceInstance;</span></span><br><span class="line"><span class="code">    import org.springframework.cloud.client.discovery.DiscoveryClient;</span></span><br><span class="line"><span class="code">    import org.springframework.web.bind.annotation.GetMapping;</span></span><br><span class="line"><span class="code">    import org.springframework.web.bind.annotation.RestController;</span></span><br><span class="line"><span class="code">    import org.springframework.web.client.RestTemplate;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    import java.util.List;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    @RestController</span></span><br><span class="line"><span class="code">    public class UsersController &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        private static final Logger log = LoggerFactory.getLogger(UsersController.class);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        @Autowired</span></span><br><span class="line"><span class="code">        private DiscoveryClient discoveryClient;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        @GetMapping(&quot;/invoke&quot;)</span></span><br><span class="line"><span class="code">        public String invokeProduct()&#123;</span></span><br><span class="line"><span class="code">            log.info(&quot;调用用户服务&quot;);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            //使用ribbon组件实现堵负载均衡 三种方法 DiscoveryClient LoadBalanceClient @LoadBalance</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            //DiscoveryClient</span></span><br><span class="line"><span class="code">            List&lt;ServiceInstance&gt; serviceInstances = discoveryClient.getInstances(&quot;PRODUCTS&quot;);</span></span><br><span class="line"><span class="code">            for (ServiceInstance serviceInstance : serviceInstances) &#123;</span></span><br><span class="line"><span class="code">                log.info(&quot;服务主机：&#123;&#125; 服务端口：&#123;&#125; 服务uri：&#123;&#125;&quot;,serviceInstance.getHost(),serviceInstance.getPort(),serviceInstance.getUri());</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">            String result = new RestTemplate().getForObject(serviceInstances.get(0).getUri() + &quot;/product?id=1&quot;, String.class);</span></span><br><span class="line"><span class="code">            log.info(&quot;商品服务调用结果:&#123;&#125;&quot;,result);</span></span><br><span class="line"><span class="code">            return result;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"># 测试</span></span><br><span class="line"><span class="code">访问：http://localhost:8987/invoke</span></span><br><span class="line"><span class="code"># 2.LoadBalanceClient对象 可实现负载均衡 只要引入ribbon依赖 工厂中就有了DiscoveryClient对象 </span></span><br><span class="line"><span class="code">    package com.chabai.controller;</span></span><br><span class="line"><span class="code">    import org.slf4j.Logger;</span></span><br><span class="line"><span class="code">    import org.slf4j.LoggerFactory;</span></span><br><span class="line"><span class="code">    import org.springframework.beans.factory.annotation.Autowired;</span></span><br><span class="line"><span class="code">    import org.springframework.cloud.client.ServiceInstance;</span></span><br><span class="line"><span class="code">    import org.springframework.cloud.client.loadbalancer.LoadBalancerClient;</span></span><br><span class="line"><span class="code">    import org.springframework.web.bind.annotation.GetMapping;</span></span><br><span class="line"><span class="code">    import org.springframework.web.bind.annotation.RestController;</span></span><br><span class="line"><span class="code">    import org.springframework.web.client.RestTemplate;</span></span><br><span class="line"><span class="code">    import java.util.List;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    @RestController</span></span><br><span class="line"><span class="code">    public class UsersController &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        private static final Logger log = LoggerFactory.getLogger(UsersController.class);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"></span><br><span class="line"><span class="code">        @Autowired</span></span><br><span class="line"><span class="code">        private LoadBalancerClient loadBalancerClient;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        @GetMapping(&quot;/invoke&quot;)</span></span><br><span class="line"><span class="code">        public String invokeProduct()&#123;</span></span><br><span class="line"><span class="code">            log.info(&quot;调用用户服务&quot;);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            //LoadBalancerClient</span></span><br><span class="line"><span class="code">            ServiceInstance serviceInstance = loadBalancerClient.choose(&quot;PRODUCTS&quot;);//已经进行负载均衡返回的节点 轮询策略</span></span><br><span class="line"><span class="code">            String result = new RestTemplate().getForObject(serviceInstance.getUri() + &quot;/product?id=1&quot;, String.class);</span></span><br><span class="line"><span class="code">            log.info(&quot;商品服务调用结果:&#123;&#125;&quot;,result);</span></span><br><span class="line"><span class="code">            return result;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"># 测试</span></span><br><span class="line"><span class="code">访问：http://localhost:8987/invoke</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.@LoadBalance 可实现负载均衡</span></span><br><span class="line"><span class="bullet">-</span> 写一个config包 把RestTemplate交给工厂管理 日后不用再手动new了 直接注入即可 并添加注解实现负载均衡</span><br><span class="line"><span class="code">    package com.chabai.config;</span></span><br><span class="line"><span class="code">    import org.springframework.cloud.client.loadbalancer.LoadBalanced;</span></span><br><span class="line"><span class="code">    import org.springframework.context.annotation.Bean;</span></span><br><span class="line"><span class="code">    import org.springframework.context.annotation.Configuration;</span></span><br><span class="line"><span class="code">    import org.springframework.web.client.RestTemplate;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    @Configuration</span></span><br><span class="line"><span class="code">    public class BeansConfig &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        @Bean</span></span><br><span class="line"><span class="code">        @LoadBalanced//负载均衡的客户端</span></span><br><span class="line"><span class="code">        public RestTemplate restTemplate()&#123;</span></span><br><span class="line"><span class="code">            return new RestTemplate();</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">- 写调用接口</span></span><br><span class="line"><span class="code">    package com.chabai.controller;</span></span><br><span class="line"><span class="code">    import org.slf4j.Logger;</span></span><br><span class="line"><span class="code">    import org.slf4j.LoggerFactory;</span></span><br><span class="line"><span class="code">    import org.springframework.beans.factory.annotation.Autowired;</span></span><br><span class="line"><span class="code">    import org.springframework.cloud.client.ServiceInstance;</span></span><br><span class="line"><span class="code">    import org.springframework.web.bind.annotation.GetMapping;</span></span><br><span class="line"><span class="code">    import org.springframework.web.bind.annotation.RestController;</span></span><br><span class="line"><span class="code">    import org.springframework.web.client.RestTemplate;</span></span><br><span class="line"><span class="code">    import java.util.List;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    @RestController</span></span><br><span class="line"><span class="code">    public class UsersController &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        private static final Logger log = LoggerFactory.getLogger(UsersController.class);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        @Autowired</span></span><br><span class="line"><span class="code">        private RestTemplate restTemplate; //这个对象才是具有负载均衡的restTemplate</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        @GetMapping(&quot;/invoke&quot;)</span></span><br><span class="line"><span class="code">        public String invokeProduct()&#123;</span></span><br><span class="line"><span class="code">            log.info(&quot;调用用户服务&quot;);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"></span><br><span class="line"><span class="code">            //@LoadBalance</span></span><br><span class="line"><span class="code">            String result = this.restTemplate.getForObject(&quot;http://PRODUCTS/product?id=1&quot;, String.class);</span></span><br><span class="line"><span class="code">            log.info(&quot;商品服务调用结果:&#123;&#125;&quot;,result);</span></span><br><span class="line"><span class="code">            return result;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"># 测试</span></span><br><span class="line"><span class="code">访问：http://localhost:8987/invoke</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>方式2：OpenFeign组件实现通信  推荐</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 引入openfeign依赖</span></span><br><span class="line"><span class="code">        &lt;!--引入openfeign依赖--&gt;</span></span><br><span class="line"><span class="code">        &lt;dependency&gt;</span></span><br><span class="line"><span class="code">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="code">            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span></span><br><span class="line"><span class="code">        &lt;/dependency&gt;</span></span><br><span class="line"><span class="code"># 在入口类添加注解@EnableFeignClients开启feign调用支持</span></span><br><span class="line"><span class="code"># 新建feignclients包并建立ProductClient接口声明调用接口信息 feignclients/ProductClient</span></span><br><span class="line"><span class="code"># 写接口</span></span><br><span class="line"><span class="code">- 写注解@FeignClient(&quot;PRODUCTS&quot;) 声明是feign客户端 并且调用的服务是PRODUCTS</span></span><br><span class="line"><span class="code">- 声明调用方法</span></span><br><span class="line"><span class="code">    package com.chabai.feignclients;</span></span><br><span class="line"><span class="code">    import org.springframework.cloud.openfeign.FeignClient;</span></span><br><span class="line"><span class="code">    import org.springframework.web.bind.annotation.GetMapping;</span></span><br><span class="line"><span class="code">    import org.springframework.web.bind.annotation.RequestParam;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    @FeignClient(&quot;PRODUCTS&quot;)</span></span><br><span class="line"><span class="code">    public interface ProductClient &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        @GetMapping(&quot;/product&quot;)</span></span><br><span class="line"><span class="code">        String product(@RequestParam(&quot;id&quot;) Integer id);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"># 回到调用服务写调用</span></span><br><span class="line"><span class="code">package com.chabai.controller;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">import com.chabai.feignclients.ProductClient;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.cloud.client.ServiceInstance;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class UsersController &#123;</span><br><span class="line"></span><br><span class="line"><span class="code">    private static final Logger log = LoggerFactory.getLogger(UsersController.class);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    @Autowired</span></span><br><span class="line"><span class="code">    private ProductClient productClient;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    @GetMapping(&quot;/invoke&quot;)</span></span><br><span class="line"><span class="code">    public String invokeProduct()&#123;</span></span><br><span class="line"><span class="code">        log.info(&quot;调用用户服务&quot;);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        String result = productClient.product(1);</span></span><br><span class="line"><span class="code">        log.info(&quot;商品服务调用结果:&#123;&#125;&quot;,result);</span></span><br><span class="line"><span class="code">        return result;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"># 测试</span></span><br><span class="line"><span class="code">访问：http://localhost:8987/invoke</span></span><br></pre></td></tr></table></figure>

<h2 id="统一配置中心"><a href="#统一配置中心" class="headerlink" title="统一配置中心"></a>统一配置中心</h2><h3 id="nacos作为统一配置中心使用"><a href="#nacos作为统一配置中心使用" class="headerlink" title="nacos作为统一配置中心使用"></a>nacos作为统一配置中心使用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># nacos作为服务注册中心怎么用我们已经学习过，现在我们只考虑作为配置中心</span></span><br><span class="line"><span class="bullet">-</span> 1.他管理配置文件方式是在自己所在服务器上形成一个版本库，因此不再需要创建远程版本库</span><br><span class="line"><span class="bullet">-</span> 2.nacos作为统一配置中心管理配置文件时同样也存在版本控制</span><br><span class="line"><span class="section"># 使用nacos统一配置中心功能 </span></span><br><span class="line"><span class="bullet">-</span> 1.启动nacos server</span><br><span class="line"><span class="bullet">-</span> 2.开发微服务作为统一配置中心客户端将配置交给nacos进行管理 </span><br><span class="line">   # 新建一个独立springboot应用 并注册到nacos server 注：还是需要注册到nacos server的 虽然你要把配置放到配置中心管理 但是你作为一个微服务肯定要注册到服务注册中心了</span><br><span class="line">   a.新建一个maven空项目 configclient 我们这里只是为了方便学习 真正业务要见名知意</span><br><span class="line">   b.引入springboot和nacos client依赖 import changes</span><br><span class="line">   c.引入配置文件 配置服务端口号 名称 服务注册中心地址</span><br><span class="line">   d.编写启动类并加注解@EnableDiscoveryClient测试springboot是否可以成功启动和查看微服务在注册中心是否成功注册</span><br><span class="line">   # 测试在配置文件中自定义的属性 是否可以在接口注入正常运行 即配置文件没有交给nacos配置中心 自己管理</span><br><span class="line">   a.在配置文件写自定义属性</span><br><span class="line"><span class="code">        #自定义属性</span></span><br><span class="line"><span class="code">        name=chabai</span></span><br><span class="line"><span class="code">   b.新构建一个接口用于测试 接口中注入配置文件自定义的属性  controller/DemoController</span></span><br><span class="line"><span class="code">        package com.chabai.controller;</span></span><br><span class="line"><span class="code">        import org.slf4j.Logger;</span></span><br><span class="line"><span class="code">        import org.slf4j.LoggerFactory;</span></span><br><span class="line"><span class="code">        import org.springframework.beans.factory.annotation.Value;</span></span><br><span class="line"><span class="code">        import org.springframework.web.bind.annotation.GetMapping;</span></span><br><span class="line"><span class="code">        import org.springframework.web.bind.annotation.RestController;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        @RestController</span></span><br><span class="line"><span class="code">        public class DemoController &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            @Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="code">            private String name;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            private static final Logger log = LoggerFactory.getLogger(DemoController.class);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            @GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="code">            public String demo()&#123;</span></span><br><span class="line"><span class="code">                log.info(&quot;demo ok...&quot;);</span></span><br><span class="line"><span class="code">                return &quot;demo ok name:&quot;+name;</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">   c.访问:http://localhost:8981/demo测试是否能正常</span></span><br><span class="line"><span class="code">   # 将自身配置交给远端nacos config server进行管理 如下图： dataId写错的话要删除重写无法修改</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240419213824454.png" alt="image-20240419213824454"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240419214546963.png" alt="image-20240419214546963"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240419214613265.png" alt="image-20240419214613265"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 我们已把配置交给他管理了  我们自己服务就可以不要配置文件了 需要时去nacos config server拉取对应配置即可</span></span><br><span class="line"><span class="bullet">-</span> 1.自身项目引入nacos config client依赖 之前那个依赖是把自身当成服务客户端 现在是把自身当成一个配置客户端</span><br><span class="line"><span class="code">    **引入这个依赖代表日后我们这个服务一启动就会把自己当成configclient就会根据下边写的配置去nacos config server对应位置拉取对应配置文件 从而根据拉取的配置文件的配置启动微服务**</span></span><br><span class="line"><span class="code">        &lt;!--引入nacos config client依赖--&gt;</span></span><br><span class="line"><span class="code">        &lt;dependency&gt;</span></span><br><span class="line"><span class="code">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="code">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span></span><br><span class="line"><span class="code">        &lt;/dependency&gt;</span></span><br><span class="line"><span class="code">- 2.我们还需要引入配置文件告诉服务去哪拉取配置  application.properties </span></span><br><span class="line"><span class="code">        #告诉nacos config server地址</span></span><br><span class="line"><span class="code">        spring.cloud.nacos.config.server-addr=47.115.221.37:8848</span></span><br><span class="line"><span class="code">        #告诉从哪个命名空间获取配置 默认public为空可不写 注意要写命名空间生成的id不是命名空间名字</span></span><br><span class="line"><span class="code">        #spring.cloud.nacos.config.namespace=命名空间id 不是默认public时才需要写</span></span><br><span class="line"><span class="code">        #告诉去哪个组拉取个配置文件</span></span><br><span class="line"><span class="code">        spring.cloud.nacos.config.group=DEFAULT_GROUP</span></span><br><span class="line"><span class="code">        #从这个组拉取哪个配置文件</span></span><br><span class="line"><span class="code">        spring.cloud.nacos.config.name=configclient-prod</span></span><br><span class="line"><span class="code">        #拉取这个配置文件的哪个后缀的配置文件</span></span><br><span class="line"><span class="code">        spring.cloud.nacos.config.file-extension=properties</span></span><br><span class="line"><span class="code">- 3. 运行发现报错Could not resolve placeholder &#x27;name&#x27; in value &quot;$&#123;name&#125;&quot;，</span></span><br><span class="line"><span class="code">     原因：服务在启动时，会认为服务中的application.properties就是我们所需要的配置了，并不会等待拉取配置文件完成之后再启动</span></span><br><span class="line"><span class="code">     解决方案:让当前项目在启动时预先拉取配置，再以拉取的配置启动==》修改项目的application.properties为bootstrap.properties</span></span><br><span class="line"><span class="code"># 访问：http://localhost:8981/demo测试</span></span><br><span class="line"><span class="code"># 远端代码修改了，直接不启动的情况下，影响到当前项目 即自动配置刷新</span></span><br><span class="line"><span class="code">- 在接口加入注解@RefreshScope//允许远端配置修改</span></span><br><span class="line"><span class="code">        package com.chabai.controller;</span></span><br><span class="line"><span class="code">        import org.slf4j.Logger;</span></span><br><span class="line"><span class="code">        import org.slf4j.LoggerFactory;</span></span><br><span class="line"><span class="code">        import org.springframework.beans.factory.annotation.Value;</span></span><br><span class="line"><span class="code">        import org.springframework.cloud.context.config.annotation.RefreshScope;</span></span><br><span class="line"><span class="code">        import org.springframework.web.bind.annotation.GetMapping;</span></span><br><span class="line"><span class="code">        import org.springframework.web.bind.annotation.RestController;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        @RestController</span></span><br><span class="line"><span class="code">        @RefreshScope//允许远端配置修改</span></span><br><span class="line"><span class="code">        public class DemoController &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            @Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="code">            private String name;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            private static final Logger log = LoggerFactory.getLogger(DemoController.class);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            @GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="code">            public String demo()&#123;</span></span><br><span class="line"><span class="code">                log.info(&quot;demo ok...&quot;);</span></span><br><span class="line"><span class="code">                return &quot;demo ok name:&quot;+name;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code"># 修改nacos config server里对应配置代码 不重新启动微服务 再次访问：http://localhost:8981/demo测试 发现已改变</span></span><br></pre></td></tr></table></figure>

<h3 id="nacos作为统一配置中心细节"><a href="#nacos作为统一配置中心细节" class="headerlink" title="nacos作为统一配置中心细节"></a>nacos作为统一配置中心细节</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 统一配置中心nacos config server</span></span><br><span class="line"><span class="section"># dataId细节：代表完整配置文件名称 = prefix(前缀) + 环境(env) +file-extension(后缀)|</span></span><br><span class="line"><span class="section"># =spring.cloud.nacos.config.name + spring.cloud.nacos.config.file-extension</span></span><br><span class="line">故dataId可如下：</span><br><span class="line">dataId = spring.cloud.nacos.config.name + spring.cloud.nacos.config.file-extension</span><br><span class="line">dataId = $&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125;</span><br><span class="line"><span class="section"># 微服务客户端拉取配置方式 二选一</span></span><br><span class="line"><span class="bullet">-</span> a.第一种获取配置文件方式 dataId = name +file-extension</span><br><span class="line"><span class="code">    #从这个组拉取哪个配置文件</span></span><br><span class="line"><span class="code">    spring.cloud.nacos.config.name=configclient-prod</span></span><br><span class="line"><span class="code">    #拉取这个配置的哪个后缀的配置文件</span></span><br><span class="line"><span class="code">    spring.cloud.nacos.config.file-extension=properties</span></span><br><span class="line"><span class="code">- b.第二种获取配置文件方式  dataId = prefix + env +file-extension</span></span><br><span class="line"><span class="code">    spring.cloud.nacos.config.prefix=configclient  #默认值是服务名我们这里要自己指定</span></span><br><span class="line"><span class="code">    spring.profiles.active=prod</span></span><br><span class="line"><span class="code">    spring.cloud.nacos.config.file-extension=properties	</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 统一配置中心 nacos 三个重要概念 我们只是举个例子 没有标准</span></span><br><span class="line"><span class="bullet">-</span> 命名空间 namespace: 默认nacos安装完成之后会有一个默认命名空间 名字为public </span><br><span class="line">  作用：站在项目角度隔离每一个项目配置文件</span><br><span class="line">  例：我们可以自定义自己的命名空间一个命名空间就代表一个全局应用 防止多个应用混乱 </span><br><span class="line">  </span><br><span class="line"><span class="bullet">-</span> 组 group: 默认nacos中管理配置文件时不显示执行group名称之默认的组名称为DEFAULT<span class="emphasis">_GROUP</span></span><br><span class="line"><span class="emphasis">  作用：站在项目中每一个服务角度，隔离同一个项目中不同服务的配置文件</span></span><br><span class="line"><span class="emphasis">  </span></span><br><span class="line"><span class="emphasis">- 文件名 dataId: 获取一个配置文件的唯一标识</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 导入导出</span></span><br><span class="line"><span class="section"># nacos config支持版本回退的 在历史版本 默认为空 需要自己拿着dataId 和 group搜索</span></span><br></pre></td></tr></table></figure>

<h3 id="nacos的mysql数据持久化"><a href="#nacos的mysql数据持久化" class="headerlink" title="nacos的mysql数据持久化"></a>nacos的mysql数据持久化</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.nacos持久化</span></span><br><span class="line"><span class="bullet">-</span> 持久化：管理的配置信息持久化 数据持久化到硬盘 再次启动不会丢失</span><br><span class="line"><span class="bullet">-</span> 注意：默认nacos存在配置信息持久化，默认的持久化方式为内嵌数据库 derby nacos的data就是默认数据库存储点</span><br><span class="line"><span class="bullet">-</span> 缺点：无法更友好的展示数据</span><br><span class="line"><span class="bullet">-</span> 官方建议：在生产情况下推荐将配置存入mysql数据库 注意：nacos到目前为止只支持mysql且版本要求5.6.5+</span><br><span class="line"><span class="bullet">-</span> 优点：使用默认数据库是nacos在自己在管理数据 我们把数据放到mysql 日后不会因为nacos老化丢失数据 且方便我们图形化操作数据</span><br><span class="line"><span class="section"># 2.将nacos持久化到mysqlh中</span></span><br><span class="line"><span class="bullet">-</span> a.在linux系统安装mysql数据库服务 版本要求5.6.5+</span><br><span class="line"><span class="bullet">    -</span> 一定要卸载原来老的mysql</span><br><span class="line"><span class="code">      检查是否安装了Mysql</span></span><br><span class="line"><span class="code">      - Yum检查</span></span><br><span class="line"><span class="code">         yum list installed | grep mysql</span></span><br><span class="line"><span class="code">         删除：yum remove xxx</span></span><br><span class="line"><span class="code">      - rpm检查</span></span><br><span class="line"><span class="code">         rpm -qa | grep -i mysql </span></span><br><span class="line"><span class="code">         删除：rpm -e --nodeps xxx</span></span><br><span class="line"><span class="code">      口令查找Mysql的安装目录和残存文件</span></span><br><span class="line"><span class="code">         whereis mysql</span></span><br><span class="line"><span class="code">         find / -name mysql</span></span><br><span class="line"><span class="code">         删除：rm -rf xx</span></span><br><span class="line"><span class="code">      查看mysql配置文件</span></span><br><span class="line"><span class="code">        以my.cnf为例，一般在/etc/my.cnf，直接rm即可。</span></span><br><span class="line"><span class="code">        如果设置了开机启动，也需要关闭。</span></span><br><span class="line"><span class="code">        chkconfig --list | grep -i mysql</span></span><br><span class="line"><span class="code">        chkconfig --del mysqld      </span></span><br><span class="line"><span class="code">    - 先yum install mysql-community-server -y成功就不需要添加源否则请按如下    </span></span><br><span class="line"><span class="code">    - 添加官方的yum源创建并编辑mysql-community.repo文件</span></span><br><span class="line"><span class="code">       vi /etc/yum.repos.d/mysql-community.repo       </span></span><br><span class="line"><span class="code">    - 粘贴以下内容到源文件中</span></span><br><span class="line"><span class="code">      [mysql57-community]</span></span><br><span class="line"><span class="code">      name=MySQL 5.7 Community Server</span></span><br><span class="line"><span class="code">      baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/7/$basearch/</span></span><br><span class="line"><span class="code">      enabled=1</span></span><br><span class="line"><span class="code">      gpgcheck=0</span></span><br><span class="line"><span class="code">      gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql      </span></span><br><span class="line"><span class="code">    - 安装mysql</span></span><br><span class="line"><span class="code">      yum install mysql-community-server -y      </span></span><br><span class="line"><span class="code">    - 启动数据库</span></span><br><span class="line"><span class="code">       systemctl start mysqld       </span></span><br><span class="line"><span class="code">    - 修改mysql数据库密码 会生成临时密码要获取后修改</span></span><br><span class="line"><span class="code">      grep &#x27;temporary password&#x27; /var/log/mysqld.log</span></span><br><span class="line"><span class="code">        [Note] A temporary password is generated for root@localhost: pAltzf:Y*0:,</span></span><br><span class="line"><span class="code">      mysqladmin -u root -p password 回车 输入原始密码 再输入新密码 Root!Q2w      </span></span><br><span class="line"><span class="code">    - 登录mysql</span></span><br><span class="line"><span class="code">      mysql -uroot -p&#x27;密码&#x27;    </span></span><br><span class="line"><span class="code">    - 修改远程连接</span></span><br><span class="line"><span class="code">      grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;密码&#x27; with grant option;</span></span><br><span class="line"><span class="code">      flush privileges; 刷新权限</span></span><br><span class="line"><span class="code">- b.nacos持久化mysql配置</span></span><br><span class="line"><span class="code">    - 创建一个数据库 nacos_config  utf-8</span></span><br><span class="line"><span class="code">    - 执行nacos-mysql.sql nacos解压后在conf即可找到 拉到windows桌面 在拉到可视化工具执行即可</span></span><br><span class="line"><span class="code">    - 修改nacos配置文件 vim application.properties    </span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240420143433438.png" alt="image-20240420143433438"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 关闭重新启动nacos</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240420140509310.png" alt="image-20240420140509310"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> c.访问：http://47.115.221.37:8848/nacos发现已换为mysql数据库</span><br></pre></td></tr></table></figure>

<h3 id="nacos集群"><a href="#nacos集群" class="headerlink" title="nacos集群"></a>nacos集群</h3><blockquote>
<p>集群部署架构图</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240420144006693.png" alt="image-20240420144006693"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240420144324727.png" alt="image-20240420144324727"></p>
<blockquote>
<p>集群实现</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.集群的规划</span></span><br><span class="line"><span class="bullet">-</span> nacos01 47.115.221.37:8845</span><br><span class="line"><span class="bullet">-</span> nacos02 47.115.221.37:8846</span><br><span class="line"><span class="bullet">-</span> nacos03 47.115.221.37:8847</span><br><span class="line"><span class="bullet">-</span> mysql  47.115.221.37:3306 我们这里暂用mysql单节点 不用主从复制</span><br><span class="line"><span class="bullet">-</span> nginx  47.115.221.37:8999 实现nacos负载均衡</span><br><span class="line"><span class="section"># 2.搭建nacos集群的注意事项</span></span><br><span class="line"><span class="bullet">-</span> 数据持久化必须为mysql</span><br><span class="line"><span class="bullet">-</span> 要求在一个机器启动时虚拟机内存不小于3g</span><br><span class="line"><span class="section"># 3.搭建nacos集群 </span></span><br><span class="line"><span class="bullet">-</span> 保证要用来复制节点的nacos不能有脏数据(rm -rf nacos/data/就变成和刚解压一样了)，并为连接mysql数据库</span><br><span class="line"><span class="bullet">-</span> 重新初始化mysql 若mysql为空就不用初始化直接用即可 我们这里是为了避免有脏数据  (可选)</span><br><span class="line"><span class="code">     ----以上两步保证现在我们用来复制的nacos既没有berby数据也没有mysql数据污染----</span></span><br><span class="line"><span class="code">- 复制nacos为nacos01(cp -r nacos nacos01)</span></span><br><span class="line"><span class="code">- 配置nacos01</span></span><br><span class="line"><span class="code">  修改nacos01 conf目录中cluster.conf.example为cluster.conf</span></span><br><span class="line"><span class="code">  cluster.conf文件添加所有集群节点</span></span><br><span class="line"><span class="code">	47.115.221.37:8845</span></span><br><span class="line"><span class="code">	47.115.221.37:8846</span></span><br><span class="line"><span class="code"> 	47.115.221.37:8847</span></span><br><span class="line"><span class="code">- 复制nacos01 为nacos02 nacos03 ====》三个节点集群搭建完成</span></span><br><span class="line"><span class="code">    cp -r nacos01 nacos02</span></span><br><span class="line"><span class="code">    cp -r nacos01 nacos03</span></span><br><span class="line"><span class="code">- 修改各自端口号 vim application.properties 三个都改为规划的端口号</span></span><br><span class="line"><span class="code">- 分别启动三个节点 默认就是以集群方式启动 若更改配置记得先停止再重新启动</span></span><br><span class="line"><span class="code">  ./nacos01/bin/startup.sh</span></span><br><span class="line"><span class="code">  ./nacos02/bin/startup.sh</span></span><br><span class="line"><span class="code">  ./nacos03/bin/startup.sh</span></span><br><span class="line"><span class="code">- 不用的话及时关闭节点释放内存</span></span><br><span class="line"><span class="code">- 这里做个说明我本来想用我服务器跑集群的，结果跑第二个nacos的时候，服务器就死机了，我的服务器是一核两g的，可以把启动文件里的参数改小一点</span></span><br><span class="line"><span class="code">原因：nacos的默认启动内存参数为-Xms2g -Xmx2g -Xmn1，可能根本用不到这么多。如果只是在测试环境或者微服务数量相对比较少时，采用Nacos默认的JVM配置会浪费很多资源。 若更改配置记得先停止再重新启动</span></span><br><span class="line"><span class="code">解决办法：start.sh修改下内存分配</span></span><br><span class="line"><span class="code">standalone：表示单机模式运行，非集群模式</span></span><br><span class="line"><span class="code">-Xms: 设定程序启动时占用内存大小</span></span><br><span class="line"><span class="code">-Xmx: 设定程序运行期间最大可占用的内存大小</span></span><br><span class="line"><span class="code">-Xmn：新生代大小</span></span><br><span class="line"><span class="code">- 搭建成功如下 不知道多了个本地的 3个实例外部路由+一个内部路由（启动自带，不知原因,可能是网卡）</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240420164553746.png" alt="image-20240420164553746"></p>
<blockquote>
<p>nginx实现nacos负载均衡  即架构中的SLB</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240420144407362.png" alt="image-20240420144407362"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># nginx实现nacos负载均衡 </span></span><br><span class="line"><span class="bullet">-</span> 安装必要依赖</span><br><span class="line"><span class="code">	yum install -y gcc pcre-devel zlib-devel</span></span><br><span class="line"><span class="code">- 下载nginx</span></span><br><span class="line"><span class="code">	https://nginx.org/en/download.html</span></span><br><span class="line"><span class="code">- 将nginx上传到服务器并解压缩</span></span><br><span class="line"><span class="code">	tar -zxvf nginx-1.12.2.tar.gz</span></span><br><span class="line"><span class="code">- 进入解压后的目录并查看nginx安装目录</span></span><br><span class="line"><span class="code">    cd  nginx-1.12.2</span></span><br><span class="line"><span class="code">    ls</span></span><br><span class="line"><span class="code">	auto  CHANGES  CHANGES.ru  conf  configure  contrib  html  LICENSE  man  README  src</span></span><br><span class="line"><span class="code">- 在安装目录执行命令(指定安装位置)</span></span><br><span class="line"><span class="code">	./configure --prefix=/usr/nginx</span></span><br><span class="line"><span class="code">- 执行上述命令后再执行如下命令</span></span><br><span class="line"><span class="code">	make &amp;&amp; make install</span></span><br><span class="line"><span class="code">- 直接启动nginx 把它当作服务器启动</span></span><br><span class="line"><span class="code">	进入sbin目录执行 ./nginx</span></span><br><span class="line"><span class="code">	查看nginx进程是否启动成功： ps aux|grep nginx</span></span><br><span class="line"><span class="code">	查看web页面：http://主机:80  80是默认端口可不写</span></span><br><span class="line"><span class="code">- 但我们想让它当作代理服务器启动 故要执行下边的操作再启动</span></span><br><span class="line"><span class="code">	先关闭服务 ./nginx -s stop | kill杀死进程</span></span><br><span class="line"><span class="code">- 配置nginx.conf配置文件</span></span><br><span class="line"><span class="code">	a.加入如下配置</span></span><br><span class="line"><span class="code">	upstream nacos-servers&#123;</span></span><br><span class="line"><span class="code">		server 47.115.221.37:8845;</span></span><br><span class="line"><span class="code">		server 47.115.221.37:8846;</span></span><br><span class="line"><span class="code">		server 47.115.221.37:8847;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	b.修改</span></span><br><span class="line"><span class="code">	location / &#123;</span></span><br><span class="line"><span class="code">	  proxy_pass http://nacos-servers/;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">- 加载配置启动nginx进行测试</span></span><br><span class="line"><span class="code">	./nginx -c /usr/nginx/conf/nginx.conf</span></span><br><span class="line"><span class="code">	查看nginx进程是否启动成功： ps aux|grep nginx</span></span><br><span class="line"><span class="code">- 访问47.115.221.37:80/nacos  会根据负载均衡给我们选择一个节点返回 结果如下：</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240420174736056.png" alt="image-20240420174736056"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 日后我们配置文件项目不用再指定某个nacos server地址了</span></span><br><span class="line">spring.cloud.nacos.server-addr=47.115.221.37:80 </span><br></pre></td></tr></table></figure>

<h3 id="集群搭建遇到问题"><a href="#集群搭建遇到问题" class="headerlink" title="集群搭建遇到问题"></a>集群搭建遇到问题</h3><p>但使用springboot启动服务通过nginx提供端口进行服务注册，会发现报错，以下是错误信息。而单机启动nacos ，这可以注册的上去，由此可以判定是集群模式下会出现此问题</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240420193940989.png" alt="image-20240420193940989"></p>
<blockquote>
<p>原因分析:</p>
</blockquote>
<p>应该是nacos 注册时,需要找网卡的 ip地址,但是有多个. 而注册时轮询找的第一个网卡的ip地址.<br>我们查看nacos的集群配置文件cluster.conf也得到了验证,发现会多出来一条不属于自己配置的ip端口。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240420194106132.png" alt="image-20240420194106132"></p>
<blockquote>
<p>解决方案：</p>
</blockquote>
<p>1.修改每个nacos的配置文件aplication.properties 指定具体ip地址</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240420201148294.png" alt="image-20240420201148294"></p>
<p>2.修改每个nacos-server\conf 的cluster.conf，将多出来的配置删除掉。</p>
<p>3.删除每个nacos-server下的data文件夹</p>
<p>4.先关闭再重启nacos集群和微服务，即可发现服务已注册进nacos集群</p>
<h2 id="sentinel组件"><a href="#sentinel组件" class="headerlink" title="sentinel组件"></a>sentinel组件</h2><h3 id="sentinel-简介"><a href="#sentinel-简介" class="headerlink" title="sentinel 简介"></a>sentinel 简介</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 历史</span></span><br><span class="line"><span class="bullet">-</span> 2012 年，Sentinel 诞生，主要功能为入口流量控制。</span><br><span class="line"><span class="bullet">-</span> 2013-2017 年，Sentinel 在阿里巴巴集团内部迅速发展，成为基础技术模块，覆盖了所有的核心场景。Sentinel 也因此积累了大量的流量归整场景以及生产实践。</span><br><span class="line"><span class="bullet">-</span> 2018 年，Sentinel 开源，并持续演进。</span><br><span class="line"><span class="bullet">-</span> 2019 年，Sentinel 朝着多语言扩展的方向不断探索，推出 C++ 原生版本，同时针对 Service Mesh 场景也推出了 Envoy 集群流量控制支持，以解决 Service Mesh 架构下多语言限流的问题。</span><br><span class="line"><span class="bullet">-</span> 2020 年，推出 Sentinel Go 版本，继续朝着云原生方向演进。</span><br><span class="line"><span class="bullet">-</span> 2021 年，Sentinel 正在朝着 2.0 云原生高可用决策中心组件进行演进；同时推出了 Sentinel Rust 原生版本。同时我们也在 Rust 社区进行了 Envoy WASM extension 及 eBPF extension 等场景探索。</span><br><span class="line"><span class="bullet">-</span> 2022 年，Sentinel 品牌升级为流量治理，领域涵盖流量路由/调度、流量染色、流控降级、过载保护/实例摘除等；同时社区将流量治理相关标准抽出到 OpenSergo 标准中，Sentinel 作为流量治理标准实现。</span><br><span class="line"><span class="section"># 官网</span></span><br><span class="line"><span class="bullet">-</span> 官网：https://sentinelguard.io/zh-cn/index.html</span><br><span class="line"><span class="bullet">-</span> github:https://github.com/alibaba/Sentinel/wiki</span><br><span class="line"><span class="bullet">-</span> springcloud的alibaba工具集:https://spring.io/projects/spring-cloud-alibaba</span><br><span class="line"><span class="section"># 介绍</span></span><br><span class="line"><span class="bullet">-</span> 随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件，主要以流量为切入点，从流量路由、流量控制、流量整形、熔断降级、系统自适应过载保护、热点流量防护等多个维度来帮助开发者保障微服务的稳定性。</span><br><span class="line"><span class="section"># 作用</span></span><br><span class="line"><span class="bullet">-</span> alibaba开源用来对现有微服务系统进行保护 ===》替换hystrix</span><br><span class="line"><span class="bullet">-</span> hystrix 豪猪 用来保护微服务系统主要用来解决服务雪崩===》服务熔断</span><br><span class="line"><span class="bullet">-</span> sentinel 用来解决服务雪崩 ====》服务熔断（服务降级）、服务流控...</span><br><span class="line"><span class="section"># 基本概念</span></span><br><span class="line"><span class="bullet">-</span> <span class="code">`资源`</span>  resource</span><br><span class="line"><span class="code">    资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。在接下来的文档中，我们都会用资源来描述代码块。</span></span><br><span class="line"><span class="code">    只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源。</span></span><br><span class="line"><span class="code">- `规则` rule</span></span><br><span class="line"><span class="code">	围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</span></span><br><span class="line"><span class="code"># 特性</span></span><br><span class="line"><span class="code">- 丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> 完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240421233918406.png" alt="image-20240421233918406"></p>
<h3 id="sentinel实现原理"><a href="#sentinel实现原理" class="headerlink" title="sentinel实现原理"></a>sentinel实现原理</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># sentinel提供了两个服务组件 两个组件必须结合使用</span></span><br><span class="line"><span class="bullet">-</span> sentinel 用来实现微服务系统中服务熔断、降级等功能        -------&gt;hystrix</span><br><span class="line"><span class="bullet">-</span> sentinel dashboard 用来监控微服务系统中流量调用等情况 流控 熔断 降级 配置-----&gt;hystrix dashboard</span><br><span class="line"><span class="bullet">-</span> 注：sentinel 以依赖方式引入微服务 ,sentinel dashboard类似后台管理系统 我们下载运行即可</span><br><span class="line"><span class="section"># sentinel实现原理</span></span><br><span class="line"><span class="bullet">-</span> 保护哪个微服务哪个服务就引入sentinel,sentinel是真正用来实现微服务系统中服务熔断、降级等功能的</span><br><span class="line"><span class="bullet">-</span> 但是仅仅引入sentinel还不够 我们还需要在sentinel dashboard配置资源和规则对应关系</span><br><span class="line"><span class="bullet">-</span> 流程：我们在sentinel dashboard配置规则 ,sentinel dashboard会和sentinel组件进行通信 ,会把规则传给sentinel,当sentinel感知到规则就会在内存中形成这个规则，当我们日后运行该服务时就会运用该规则</span><br></pre></td></tr></table></figure>

<h3 id="sentinel-dashboard使用"><a href="#sentinel-dashboard使用" class="headerlink" title="sentinel dashboard使用"></a>sentinel dashboard使用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># sentinel dashboard下载 sentinel仓库--》tags选择版本下载jar包</span></span><br><span class="line"><span class="bullet">-</span> 网址：https://github.com/alibaba/Sentinel/tags</span><br><span class="line"><span class="section"># 上传到linux服务器</span></span><br><span class="line"><span class="section"># 环境</span></span><br><span class="line"><span class="bullet">-</span> 必须安装jdk 配置环境变量 jdk8+</span><br><span class="line"><span class="section"># 直接启动springbootjar包运行  默认端口8080 推荐指定端口启动</span></span><br><span class="line"><span class="bullet">-</span> java -jar -Dserver.port=7777 sentinel-dashboard-1.8.7.jar</span><br><span class="line"><span class="section"># 访问dashboard管理界面</span></span><br><span class="line"><span class="bullet">-</span> http://47.115.221.37:7777</span><br><span class="line"><span class="bullet">-</span> 默认账号密码sentinel</span><br><span class="line">界面如下：</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240422001038282.png" alt="image-20240422001038282"></p>
<h3 id="sentinel组件使用"><a href="#sentinel组件使用" class="headerlink" title="sentinel组件使用"></a>sentinel组件使用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 服务器启动服务注册中nacos 单例即可</span></span><br><span class="line"><span class="section"># 开发微服务</span></span><br><span class="line"><span class="bullet">-</span> 新建一个独立springboot应用 并注册到nacos server</span><br><span class="line">   a.新建一个maven空项目 sentinel 我们这里只是为了方便学习 真正业务要见名知意</span><br><span class="line">   b.引入springboot web和nacos client依赖 import changes</span><br><span class="line">   c.引入配置文件 配置服务端口号 名称 服务注册中心地址</span><br><span class="line">   d.编写启动类并加注解@EnableDiscoveryClient测试springboot是否可以成功启动和查看微服务在注册中心是否成功注册</span><br><span class="line"><span class="bullet">-</span> 给外部暴漏一个rest接口用于测试 作为sentinel资源</span><br><span class="line"><span class="code">    @RestController</span></span><br><span class="line"><span class="code">    public class DemoController &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        private static final Logger log = LoggerFactory.getLogger(DemoController.class);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        @GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="code">        public String demo()&#123;</span></span><br><span class="line"><span class="code">            log.info(&quot;demo ok&quot;);</span></span><br><span class="line"><span class="code">            return &quot;demo ok&quot;;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">- 测试接口是否可以正常访问 http://localhost:8842/demo</span></span><br><span class="line"><span class="code"># 在微服务引入sentinel依赖</span></span><br><span class="line"><span class="code">        &lt;!--引入sentinel--&gt;</span></span><br><span class="line"><span class="code">        &lt;dependency&gt;</span></span><br><span class="line"><span class="code">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="code">            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span></span><br><span class="line"><span class="code">        &lt;/dependency&gt;</span></span><br><span class="line"><span class="code"># 服务器开启7777端口 </span></span><br><span class="line"><span class="code"># 服务器启动sentinel dashboard</span></span><br><span class="line"><span class="code"># 写配置文件连接到sentinel dashboard 告诉sentinel 它的dashboard ip 和 端口  以实现两者通信</span></span><br><span class="line"><span class="code">    #sentinel dashboard</span></span><br><span class="line"><span class="code">    #开启sentinel保护</span></span><br><span class="line"><span class="code">    spring.cloud.sentinel.enabled=true</span></span><br><span class="line"><span class="code">    #指定sentinel dashboard web地址 控制台地址</span></span><br><span class="line"><span class="code">    spring.cloud.sentinel.transport.dashboard=47.115.221.37:7777</span></span><br><span class="line"><span class="code">    # 应用与Sentinel控制台交互的端口，应用本地会起一个该端口占用的HttpServer</span></span><br><span class="line"><span class="code">    # 若不配置，会自动扫猫从8719开始扫猫，依次+1，知道值找到未被占用的端口</span></span><br><span class="line"><span class="code">    spring.cloud.sentinel.transport.port=8719</span></span><br><span class="line"><span class="code"># 访问http://47.115.221.37:7777发现还是没有监控到</span></span><br><span class="line"><span class="code">- Sentinel采用懒加载机制 dashboard信息必须在指定服务进行资源调用后才能初始化</span></span><br><span class="line"><span class="code">- 必须经过一次调用才能监控到</span></span><br><span class="line"><span class="code"># 再次访问接口http://localhost:8842/demo</span></span><br><span class="line"><span class="code"># 刷新dashboard发现已监控到 成功建立连接</span></span><br><span class="line"><span class="code"># 问题发现没有实时监控到服务</span></span><br><span class="line"><span class="code">- 原因是本机网络是局域网，sentinel部署在服务器的话是无法访问到本机网络的，所以要么sentinel和应用都部署上服务器，要么都在本地运行。</span></span><br><span class="line"><span class="code">- 必须本地跟服务器能ping通才行，它这个机制是双方要能互相传递数据的，应该是因为不仅需要sentinel客户端能访问sentinel-dashboard，同时sentinel-dashboard还需要能访问到sentinel客户端，所以在同一台机器上是能够正常访问的，但是由于本机ip不是公网ip，在未进行设置的情况下服务器端是无法访问到的，所以会报错。</span></span><br><span class="line"><span class="code">- `查阅资料后暂未解决后边转为本地启动sentinel dashboard` 并修改相关服务配置</span></span><br><span class="line"><span class="code">    #开启sentinel保护</span></span><br><span class="line"><span class="code">    spring.cloud.sentinel.enabled=true</span></span><br><span class="line"><span class="code">    #指定sentinel dashboard web地址 控制台地址</span></span><br><span class="line"><span class="code">    spring.cloud.sentinel.transport.dashboard=localhost:7777</span></span><br><span class="line"><span class="code">    #应用与Sentinel控制台交互的端口，应用本地会起一个该端口占用的HttpServer</span></span><br><span class="line"><span class="code">    #若不配置，会自动扫猫从8719开始扫猫，依次+1，知道值找到未被占用的端口</span></span><br><span class="line"><span class="code">    spring.cloud.sentinel.transport.port=8719</span></span><br><span class="line"><span class="code"># 关于系统吞吐量相关概念</span></span><br><span class="line"><span class="code">- 1.QPS(Query-Per-Second): 称之为系统每秒的请求数</span></span><br><span class="line"><span class="code">- 2.RT(Response Time): 每个请求的响应时间 单位ms</span></span><br><span class="line"><span class="code"># 到这里为止我们在微服务引入了sentinel即有了资源 并且通过sentienl和dashboard间建立通信实现了对资源的实时监控 但是我们并没有起到保护作用 我们缺少两大概念之一的规则 我们必须在dashboard建立规则并通过通信传给sentinel才能实现保护</span></span><br></pre></td></tr></table></figure>

<h3 id="sentinel规则介绍"><a href="#sentinel规则介绍" class="headerlink" title="sentinel规则介绍"></a>sentinel规则介绍</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.五大规则 网站:https://github.com/alibaba/Sentinel/wiki 我们这里只记录前三个规则 后边两个可自行看文档使用</span></span><br><span class="line"><span class="bullet">-</span> a.流控规则:流量控制（flow control）</span><br><span class="line"><span class="code">    定义：其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</span></span><br><span class="line"><span class="code">- b.降级规则: 熔断降级（DegradeRule）</span></span><br><span class="line"><span class="code">    定义: 其原理是监控应用中资源调用请求，达到指定阈值时自动触发熔断降级</span></span><br><span class="line"><span class="code">- c.热点规则：热点参数限流(ParamFlow)</span></span><br><span class="line"><span class="code">    何为热点？热点即经常访问的数据。    </span></span><br><span class="line"><span class="code">    定义:很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：</span></span><br><span class="line"><span class="code">    	商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制</span></span><br><span class="line"><span class="code">        用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制</span></span><br><span class="line"><span class="code">- d.系统规则:系统自适应限流(SystemFlow)</span></span><br><span class="line"><span class="code">    定义:Sentinel 系统自适应过载保护从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</span></span><br><span class="line"><span class="code">- e.授权规则:黑白名单控制(AuthorityController)</span></span><br><span class="line"><span class="code">    定义:很多时候，我们需要根据调用来源来判断该次请求是否允许放行，这时候可以使用 Sentinel 的来源访问控制（黑白名单控制）的功能。来源访问控制根据资源的请求来源（origin）限制资源是否通过，若配置白名单则只有请求来源位于白名单内时才可通过；若配置黑名单则请求来源位于黑名单时不通过，其余的请求通过。</span></span><br></pre></td></tr></table></figure>

<h3 id="sentinel流量控制"><a href="#sentinel流量控制" class="headerlink" title="sentinel流量控制"></a>sentinel流量控制</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 流控规则:流量控制（flow control）</span></span><br><span class="line"><span class="bullet">-</span> 定义：其原理是监控应用流量的 <span class="code">`QPS`</span> 或<span class="code">`并发线程数`</span>等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</span><br><span class="line"><span class="section"># 流量控制种类</span></span><br><span class="line"><span class="bullet">-</span> 基于QPS控制 当每秒的请求数超过指定阈值之后对当前请求限流            超过阈值请求进行限流后续的请求不处理</span><br><span class="line"><span class="bullet">-</span> 基于并发线程数流量控制  当tomcat服务器创建的线程数超过指定的阈值之后对当前请求限流  不管多少请求都放进来都处理 只兼顾自己的线程数</span><br></pre></td></tr></table></figure>

<blockquote>
<p>基于QPS流量控制测试</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">`测试环境</span><br><span class="line"><span class="bullet">-</span> 1.服务器启动单例nacos server 本地配置端口号启动sentinel dashboard(服务器使用有点问题 暂用本地启动)</span><br><span class="line"><span class="bullet">-</span> 2.访问：http://localhost:7777/  http://47.115.221.37:8848/nacos/ 测试是否成功启动上述</span><br><span class="line"><span class="bullet">-</span> 3.启动上边写的微服务</span><br><span class="line"><span class="bullet">-</span> 4.访问服务暴漏的接口http://localhost:8842/demo测试接口是否正常 同时访问：http://localhost:7777/  http://47.115.221.37:8848/nacos/ 查看微服务是否成功注册 和 服务里的sentienl组件是否和dashboard间建立通信实现了对资源的实时监控</span><br><span class="line"><span class="bullet">-</span> 5.开始配置保护规则</span><br><span class="line">  一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</span><br><span class="line"><span class="bullet">    -</span> resource：资源名，即限流规则的作用对象</span><br><span class="line"><span class="bullet">    -</span> count: 限流阈值</span><br><span class="line"><span class="bullet">    -</span> grade: 限流阈值类型（QPS 或并发线程数）</span><br><span class="line"><span class="bullet">    -</span> limitApp: 流控针对的调用来源，若为 default 则不区分调用来源</span><br><span class="line"><span class="bullet">    -</span> strategy: 调用关系限流策略</span><br><span class="line"><span class="bullet">    -</span> controlBehavior: 流量控制效果（直接拒绝、Warm Up、匀速排队）</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240422210946971.png" alt="image-20240422210946971"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240422211036994.png" alt="image-20240422211036994"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240422211235754.png" alt="image-20240422211235754"></p>
<blockquote>
<p>基于并发线程数流量控制</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240422211325276.png" alt="image-20240422211325276"></p>
<p><strong>注：这个我们手动测试可不行了，要用到压力测试工具测试</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`压测工具下载 </span><br><span class="line"><span class="bullet">-</span> 网址：https://jmeter.apache.org/download<span class="emphasis">_jmeter.cgi</span></span><br><span class="line"><span class="emphasis">`环境要求：使用此工具必须配置java环境java8+</span></span><br><span class="line"><span class="emphasis">`jmeter apache-jmeter-5.6.3.tgz 解压使用 虽然下载的是linux包我们windows也是直接可以用的</span></span><br><span class="line"><span class="emphasis">- 启动：在bin目录双击jmeter.bat 就会给我们打开一个图形化界面 小黑框别关</span></span><br><span class="line"><span class="emphasis">- 使用：先给测试计划写个名字 ---》右键添加线程组----》配置如下</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240422214912915.png" alt="image-20240422214912915"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240422212921212.png" alt="image-20240422212921212"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240422213027799.png" alt="image-20240422213027799"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240422213058360.png" alt="image-20240422213058360"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240422213738129.png" alt="image-20240422213738129"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240422213807914.png" alt="image-20240422213807914"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240422214524864.png" alt="image-20240422214524864"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 高级选项  即我们编辑流量控制规则里的高级选项 注：配置并发线程数 高级选项没有流控效果</span></span><br><span class="line"><span class="bullet">-</span> 1.流控模式</span><br><span class="line"><span class="code">      a.直接模式：当前配置资源在运行过程超过当前规则配置的阈值之后对该资源的请求做的处理是什么</span></span><br><span class="line"><span class="code">      b.关联模式：当前配置资源在运行过程超过当前规则配置的阈值之后对它所关联的资源进行请求做什么样的处理</span></span><br><span class="line"><span class="code">      c.链路模式(暂无法测试)：当前配置资源在运行过程超过当前规则配置的阈值之后对它它链路中的资源请求做什么                             处理</span></span><br><span class="line"><span class="code">- 流控模式详细介绍如下：</span></span><br><span class="line"><span class="code">- 实际演示（略）：一些场景需要结合压测工具实现</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>直接模式+快速失败                              资源名: &#x2F;demo    针对来源: default   阈值类型:  QPS    单机阈值 : 2</p>
</blockquote>
<p>解释：对于demo的请求每秒请求超过2这个阈值之后对后续请求做直接失败处理</p>
<blockquote>
<p>关联模式+快速失败  关联资源: &#x2F;aa     资源名: &#x2F;demo   针对来源: default   阈值类型:  QPS    单机阈值 : 2</p>
<p>注：关联是反向关联 即被关联的影响原本的</p>
</blockquote>
<p>解释：如果在这一时刻每秒对aa的请求数超过2这个阈值，本身没有影响  但会导致这个时候对demo的请求是失败的</p>
<blockquote>
<p>链路模式+快速失败  入口资源: &#x2F;product     资源名: &#x2F;demo   针对来源: default   阈值类型:  QPS    单机阈值 : 2</p>
</blockquote>
<p>解释：如果在这一时刻每秒对demo的请求数超过2这个阈值，对于demo调用的product<code>整条链路</code>是失败的,别的服务也是无法请求该product链路的</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 2.流控效果 只适用于QPS限流</span><br><span class="line"><span class="code">     a.快速失败：直接拒绝请求 并抛出相应异常</span></span><br><span class="line"><span class="code">     b.warm up：（冷启动|预热）</span></span><br><span class="line"><span class="code">     c.排队等待：(始终匀速通过)</span></span><br><span class="line"><span class="code">- 官方解释和使用场景如下：</span></span><br><span class="line"><span class="code">- 实际演示（略）：一些场景需要结合压测工具实现</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>快速失败</p>
</blockquote>
<p><strong>直接拒绝</strong>（<code>RuleConstant.CONTROL_BEHAVIOR_DEFAULT</code>）方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出<code>FlowException</code>。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。</p>
<blockquote>
<p>warm up</p>
</blockquote>
<p>Warm Up（<code>RuleConstant.CONTROL_BEHAVIOR_WARM_UP</code>）方式，即预热&#x2F;冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。</p>
<p>通常冷启动的过程系统允许通过的 QPS 曲线如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240422230349104.png" alt="image-20240422230349104"></p>
<blockquote>
<p>排队等待</p>
<p>注意：匀速排队模式暂时不支持 QPS &gt; 1000 的场景。</p>
</blockquote>
<p>匀速排队（<code>RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER</code>）方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p>
<p>该方式的作用如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240422230401698.png" alt="image-20240422230401698"></p>
<h3 id="sentinel熔断规则"><a href="#sentinel熔断规则" class="headerlink" title="sentinel熔断规则"></a>sentinel熔断规则</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 熔断降级</span></span><br><span class="line">   熔断:用来避免微服务架构中雪崩现象  达到某个阈值条件自动触发熔断</span><br><span class="line">   原理:当监控到调用链路中某个服务，出现异常(10s出现20个异常)自动触发熔断，在触发熔断期间对于该服务的调用是不可用的</span><br><span class="line"><span class="section"># sentinel提供的熔断策略</span></span><br><span class="line"><span class="bullet">-</span> 慢调用比例  </span><br><span class="line">   官方定义：慢调用比例 (SLOW<span class="emphasis">_REQUEST_</span>RATIO)：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。</span><br><span class="line">   通俗定义：</span><br><span class="line">   </span><br><span class="line"><span class="bullet">-</span> 异常比例 </span><br><span class="line">   官方定义：异常比例 (ERROR<span class="emphasis">_RATIO)：当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</span></span><br><span class="line"><span class="emphasis">   通俗定义：根据请求调用过程出现异常百分比进行熔断</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">- 异常数</span></span><br><span class="line"><span class="emphasis">   官方定义：异常数 (ERROR_</span>COUNT)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</span><br><span class="line">   通俗定义：根据请求调用过程中异常数进行熔断</span><br><span class="line"><span class="section"># 熔断降级规则（DegradeRule）包含下面几个重要的属性：</span></span><br><span class="line"><span class="section"># 实际演示（略）：一些场景需要结合压测工具实现</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240422233649920.png" alt="image-20240422233649920"></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>resource</td>
<td>资源名，即规则的作用对象</td>
<td></td>
</tr>
<tr>
<td>grade</td>
<td>熔断策略，支持慢调用比例&#x2F;异常比例&#x2F;异常数策略</td>
<td>慢调用比例</td>
</tr>
<tr>
<td>count</td>
<td>慢调用比例模式下为慢调用临界 RT（超出该值计为慢调用）；异常比例&#x2F;异常数模式下为对应的阈值</td>
<td></td>
</tr>
<tr>
<td>timeWindow</td>
<td>熔断时长，单位为 s</td>
<td></td>
</tr>
<tr>
<td>minRequestAmount</td>
<td>熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断（1.7.0 引入）</td>
<td>5</td>
</tr>
<tr>
<td>statIntervalMs</td>
<td>统计时长（单位为 ms），如 60*1000 代表分钟级（1.8.0 引入）</td>
<td>1000 ms</td>
</tr>
<tr>
<td>slowRatioThreshold</td>
<td>慢调用比例阈值，仅慢调用比例模式有效（1.8.0 引入）</td>
<td></td>
</tr>
</tbody></table>
<h3 id="热点参数限流（还需理解）"><a href="#热点参数限流（还需理解）" class="headerlink" title="热点参数限流（还需理解）"></a>热点参数限流（还需理解）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 官方概述</span></span><br><span class="line"><span class="bullet">-</span> 何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：</span><br><span class="line"><span class="code">    商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制</span></span><br><span class="line"><span class="code">    用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制</span></span><br><span class="line"><span class="code">- 热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。</span></span><br><span class="line"><span class="code">- Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。热点参数限流支持集群模式。</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240422235428057.png" alt="image-20240422235428057"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 基本使用</span></span><br><span class="line"><span class="section"># 必要配置</span></span><br><span class="line"><span class="bullet">-</span> 要使用热点参数限流功能，需要引入以下依赖：</span><br><span class="line"><span class="code">    &lt;dependency&gt;</span></span><br><span class="line"><span class="code">        &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span></span><br><span class="line"><span class="code">        &lt;artifactId&gt;sentinel-parameter-flow-control&lt;/artifactId&gt;</span></span><br><span class="line"><span class="code">        &lt;version&gt;x.y.z&lt;/version&gt;</span></span><br><span class="line"><span class="code">    &lt;/dependency&gt;</span></span><br><span class="line"><span class="code">- 注意使用热点参数限流时，不能使用资源路径，必须使用资源别名</span></span><br><span class="line"><span class="code">     @SentinelResource(value=&quot;aaa&quot;,)</span></span><br><span class="line"><span class="code">     @GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="code">        public String demo()&#123;</span></span><br><span class="line"><span class="code">            log.info(&quot;demo ok&quot;);</span></span><br><span class="line"><span class="code">            return &quot;demo ok&quot;;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code"># @SentinelResource注解详解</span></span><br><span class="line"><span class="code">- value：资源名称，必需项（不能为空）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> entryType：entry 类型，可选项（默认为 EntryType.OUT）</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> blockHandler / blockHandlerClass: blockHandler 对应处理 BlockException 的函数名称，可选项。blockHandler 函数访问范围需要是 public，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 blockHandlerClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> fallback / fallbackClass：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求：</span><br><span class="line"><span class="bullet">    -</span> 返回值类型必须与原函数返回值类型一致；</span><br><span class="line"><span class="bullet">    -</span> 方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。</span><br><span class="line"><span class="bullet">    -</span> fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应		 的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">- defaultFallback（since 1.6.0）：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求：</span></span><br><span class="line"><span class="code">    - 返回值类型必须与原函数返回值类型一致；</span></span><br><span class="line"><span class="code">    - 方法参数列表需要为空，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。</span></span><br><span class="line"><span class="code">    - defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</span></span><br><span class="line"><span class="code">    - exceptionsToIgnore（since 1.6.0）：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">`简单概括：blockHandler使用sentinel进行不同规则控制时的默认处理方案、fallback自定义业务出错时默认处理方案、defaultFallback指定一个业务错误时默认方案</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">`特别地，若 blockHandler 和 fallback 都进行了配置，则被限流降级而抛出 BlockException 时只会进入 blockHandler 处理逻辑。若未配置 blockHandler、fallback 和 defaultFallback，则被限流降级时会将 BlockException 直接抛出（若方法本身未定义 throws BlockException 则会被 JVM 包装一层 UndeclaredThrowableException）</span></span><br><span class="line"><span class="code"># 热点参数规则</span></span><br><span class="line"><span class="code">- 然后为对应的资源配置热点参数限流规则</span></span><br></pre></td></tr></table></figure>

<p>热点参数规则（<code>ParamFlowRule</code>）类似于流量控制规则（<code>FlowRule</code>）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/springcloudPictures/image-20240422235710776.png" alt="image-20240422235710776"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>resource</td>
<td>资源名，必填</td>
<td></td>
</tr>
<tr>
<td>count</td>
<td>限流阈值，必填</td>
<td></td>
</tr>
<tr>
<td>grade</td>
<td>限流模式</td>
<td>QPS 模式</td>
</tr>
<tr>
<td>durationInSec</td>
<td>统计窗口时间长度（单位为秒），1.6.0 版本开始支持</td>
<td>1s</td>
</tr>
<tr>
<td>controlBehavior</td>
<td>流控效果（支持快速失败和匀速排队模式），1.6.0 版本开始支持</td>
<td>快速失败</td>
</tr>
<tr>
<td>maxQueueingTimeMs</td>
<td>最大排队等待时长（仅在匀速排队模式生效），1.6.0 版本开始支持</td>
<td>0ms</td>
</tr>
<tr>
<td>paramIdx</td>
<td>热点参数的索引，必填，对应 <code>SphU.entry(xxx, args)</code> 中的参数索引位置</td>
<td></td>
</tr>
<tr>
<td>paramFlowItemList</td>
<td>参数例外项，可以针对指定的参数值单独设置限流阈值，不受前面 <code>count</code> 阈值的限制。<strong>仅支持基本类型和字符串类型</strong></td>
<td></td>
</tr>
<tr>
<td>clusterMode</td>
<td>是否是集群参数流控规则</td>
<td><code>false</code></td>
</tr>
<tr>
<td>clusterConfig</td>
<td>集群流控相关配置</td>
<td></td>
</tr>
</tbody></table>
<h3 id="系统自适应限流"><a href="#系统自适应限流" class="headerlink" title="系统自适应限流"></a>系统自适应限流</h3><h3 id="黑白名单限流"><a href="#黑白名单限流" class="headerlink" title="黑白名单限流"></a>黑白名单限流</h3><h1 id="springcloud整合alibaba"><a href="#springcloud整合alibaba" class="headerlink" title="springcloud整合alibaba"></a>springcloud整合alibaba</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chabai000.github.io">茶白</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chabai000.github.io/posts/41300/">https://chabai000.github.io/posts/41300/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chabai000.github.io" target="_blank">茶白的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></div><div class="post_share"><div class="social-share" data-image="/UpPictures/UpCover/springcloud.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/%E8%B5%9E%E8%B5%8F%E7%A0%81.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E8%B5%9E%E8%B5%8F%E7%A0%81.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/37899/" title="mybatis-plus"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/mysql-plus.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">mybatis-plus</div></div></a></div><div class="next-post pull-right"><a href="/posts/44296/" title="redis"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/redis.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">redis</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">茶白</div><div class="author-info__description">不论你在什么时候开始，重要的是开始之后就不要停止；不论你在什么时候结束，重要的是结束之后就不要悔恨</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/chabai000"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chabai000" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1693522579@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#springcloud"><span class="toc-number">1.</span> <span class="toc-text">springcloud</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.1.</span> <span class="toc-text">什么是微服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">为什么微服务？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">单体应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">微服务架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">微服务架构特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98"><span class="toc-number">1.2.3.</span> <span class="toc-text">架构的演变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.4.</span> <span class="toc-text">微服务的解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Cloud%E5%BC%95%E8%A8%80"><span class="toc-number">1.3.</span> <span class="toc-text">Spring Cloud引言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">官方定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.2.</span> <span class="toc-text">核心架构及其组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#springcloud%E5%91%BD%E5%90%8D%E5%92%8Cspringboot%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9"><span class="toc-number">1.3.3.</span> <span class="toc-text">springcloud命名和springboot版本选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.4.</span> <span class="toc-text">提供者与消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">服务调用关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.5.</span> <span class="toc-text">环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E6%95%B4%E7%90%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">思路整理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">具体实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">1.6.</span> <span class="toc-text">服务注册中心组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">1.6.1.</span> <span class="toc-text">常用的服务注册中心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Eureka"><span class="toc-number">1.6.2.</span> <span class="toc-text">Eureka</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91Eureka-Server%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">开发Eureka Server服务注册中心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Eureka-Client%E5%BC%80%E5%8F%91"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">Eureka Client开发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">eureka自我保护机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eureka%E5%81%9C%E6%AD%A2%E6%9B%B4%E6%96%B0"><span class="toc-number">1.6.2.5.</span> <span class="toc-text">eureka停止更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%AE%A2%E6%88%B7%E7%AB%AFip-%E7%AB%AF%E5%8F%A3%E6%98%BE%E7%A4%BA"><span class="toc-number">1.6.2.6.</span> <span class="toc-text">管理界面客户端ip+端口显示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Eureka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="toc-number">1.6.2.7.</span> <span class="toc-text">Eureka集群搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Eureka-Server%E9%9B%86%E7%BE%A4"><span class="toc-number">1.6.2.7.1.</span> <span class="toc-text">Eureka Server集群</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Eureka-Client%E9%9B%86%E7%BE%A4"><span class="toc-number">1.6.2.7.2.</span> <span class="toc-text">Eureka Client集群</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#idea%E6%8F%90%E4%BE%9B%E7%9A%84%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.2.7.3.</span> <span class="toc-text">idea提供的简单搭建方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Eureka%E7%BC%BA%E7%82%B9"><span class="toc-number">1.6.2.8.</span> <span class="toc-text">Eureka缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Consul"><span class="toc-number">1.6.3.</span> <span class="toc-text">Consul</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E8%A8%80%E5%92%8C%E5%AE%89%E8%A3%85"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">引言和安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8consul%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">启动consul服务注册中心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91consul-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8D%B3%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">开发consul 客户端即微服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.4.</span> <span class="toc-text">不同注册中心区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">微服务间通信方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Rest-Template"><span class="toc-number">1.7.1.</span> <span class="toc-text">Rest Template</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Rest-Template%E9%80%9A%E4%BF%A1"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">Rest Template通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8RestTemplate%E9%80%9A%E4%BF%A1%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">使用RestTemplate通信存在的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">解决负载均衡问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.7.1.3.1.</span> <span class="toc-text">自定义负载均衡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%84%E4%BB%B6"><span class="toc-number">1.7.1.3.2.</span> <span class="toc-text">Ribbon负载均衡客户端组件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ribbon%E7%BB%84%E4%BB%B6%E7%BB%86%E8%8A%82"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">Ribbon组件细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ribbon%E7%BB%84%E4%BB%B6%E5%81%9C%E6%AD%A2%E7%BB%B4%E6%8A%A4"><span class="toc-number">1.7.1.5.</span> <span class="toc-text">Ribbon组件停止维护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AA%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BB%A3%E7%A0%81%E5%86%99%E6%AD%BB"><span class="toc-number">1.7.1.6.</span> <span class="toc-text">未解决问题:代码写死</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E8%BE%B9%E4%B8%A4%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.7.1.7.</span> <span class="toc-text">前边两大组件快速回顾</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenFeign-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.7.2.</span> <span class="toc-text">OpenFeign 组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OpenFeign%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">OpenFeign组件使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">服务间通信之参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%B6%E6%95%A3%E7%B1%BB%E5%9E%8B%E4%BC%A0%E9%80%92"><span class="toc-number">1.7.2.3.1.</span> <span class="toc-text">零散类型传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.7.2.3.2.</span> <span class="toc-text">对象类型参数传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88"><span class="toc-number">1.7.2.3.3.</span> <span class="toc-text">数组和集合</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">服务间通信之响应处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8openfeign%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%B9%B6%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.2.4.1.</span> <span class="toc-text">使用openfeign调用服务并返回对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8openfeign%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%B9%B6%E8%BF%94%E5%9B%9E%E6%89%80%E6%9C%89list%E9%9B%86%E5%90%88"><span class="toc-number">1.7.2.4.2.</span> <span class="toc-text">使用openfeign调用服务并返回所有list集合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8openfeign%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%B9%B6%E8%BF%94%E5%9B%9E%E6%89%80%E6%9C%89Map%E9%9B%86%E5%90%88"><span class="toc-number">1.7.2.4.3.</span> <span class="toc-text">使用openfeign调用服务并返回所有Map集合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90json%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.7.2.4.4.</span> <span class="toc-text">自定义格式解析json字符串</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#openfeign%E7%BB%86%E8%8A%82"><span class="toc-number">1.7.2.5.</span> <span class="toc-text">openfeign细节</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#openfeign%E9%BB%98%E8%AE%A4%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86"><span class="toc-number">1.7.2.5.1.</span> <span class="toc-text">openfeign默认超时处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OpenFeign%E8%B0%83%E7%94%A8%E8%AF%A6%E7%BB%86%E6%97%A5%E5%BF%97%E5%B1%95%E7%A4%BA"><span class="toc-number">1.7.2.5.2.</span> <span class="toc-text">OpenFeign调用详细日志展示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Feign%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96-%E6%9A%82%E6%94%BE"><span class="toc-number">1.7.2.5.3.</span> <span class="toc-text">Feign使用优化(暂放)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hystrix%E7%BB%84%E4%BB%B6"><span class="toc-number">1.8.</span> <span class="toc-text">Hystrix组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9"><span class="toc-number">1.8.1.</span> <span class="toc-text">服务雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD"><span class="toc-number">1.8.2.</span> <span class="toc-text">服务熔断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="toc-number">1.8.3.</span> <span class="toc-text">服务降级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%8D%E7%BA%A7%E5%92%8C%E7%86%94%E6%96%AD%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.4.</span> <span class="toc-text">降级和熔断总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%AE%9A%E4%B9%89"><span class="toc-number">1.8.5.</span> <span class="toc-text">组件定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.8.6.</span> <span class="toc-text">服务熔断的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E8%B7%AF%E5%99%A8%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.8.6.1.</span> <span class="toc-text">断路器打开关闭的条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E5%A4%87%E9%80%89%E5%A4%84%E7%90%86"><span class="toc-number">1.8.6.2.</span> <span class="toc-text">服务熔断备选处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.8.7.</span> <span class="toc-text">服务降级的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#feign%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E5%A4%87%E9%80%89%E5%A4%84%E7%90%86"><span class="toc-number">1.8.7.1.</span> <span class="toc-text">feign服务降级备选处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hystrix-Dashboard-%E6%9A%82%E6%94%BE"><span class="toc-number">1.8.8.</span> <span class="toc-text">Hystrix Dashboard(暂放)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E7%BB%B4%E6%8A%A4"><span class="toc-number">1.8.9.</span> <span class="toc-text">停止维护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Gateway%E7%BB%84%E4%BB%B6"><span class="toc-number">1.9.</span> <span class="toc-text">Gateway组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E5%85%B3"><span class="toc-number">1.9.1.</span> <span class="toc-text">网关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zuul"><span class="toc-number">1.9.2.</span> <span class="toc-text">zuul</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gateway"><span class="toc-number">1.9.3.</span> <span class="toc-text">gateway</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gateway%E7%BD%91%E5%85%B3%E4%BD%BF%E7%94%A8"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">gateway网关使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91"><span class="toc-number">1.9.3.2.1.</span> <span class="toc-text">路由转发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E5%85%B3%E7%9A%84%E8%B7%AF%E7%94%B1%E8%A7%A3%E6%9E%90%E8%A7%84%E5%88%99%E4%BB%A5%E5%8F%8A%E6%9F%A5%E7%9C%8B"><span class="toc-number">1.9.3.2.2.</span> <span class="toc-text">网关的路由解析规则以及查看</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E7%AE%A1%E5%9C%A8%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91%E6%97%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.9.3.2.3.</span> <span class="toc-text">网管在路由转发时如何实现请求的负载均衡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E8%B7%AF%E7%94%B1predicate-%E6%96%AD%E8%A8%80-%E9%AA%8C%E8%AF%81"><span class="toc-number">1.9.3.2.4.</span> <span class="toc-text">常用路由predicate(断言,验证)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E5%85%B3%E7%9A%84%E8%BF%87%E6%BB%A4-Filter"><span class="toc-number">1.9.3.2.5.</span> <span class="toc-text">网关的过滤 Filter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E5%85%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.3.2.6.</span> <span class="toc-text">网关跨域问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Config%E7%BB%84%E4%BB%B6"><span class="toc-number">1.10.</span> <span class="toc-text">Config组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Config-Server-%E5%BC%80%E5%8F%91"><span class="toc-number">1.10.1.</span> <span class="toc-text">Config Server 开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">引入依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">开启统一配置中心服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.10.1.3.</span> <span class="toc-text">修改配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E6%8A%A5%E9%94%99"><span class="toc-number">1.10.1.4.</span> <span class="toc-text">直接启动服务报错</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">1.10.1.5.</span> <span class="toc-text">创建远程仓库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%89%E5%8F%96%E8%BF%9C%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99"><span class="toc-number">1.10.1.6.</span> <span class="toc-text">拉取远端配置规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Config-Client-%E5%BC%80%E5%8F%91"><span class="toc-number">1.10.2.</span> <span class="toc-text">Config Client 开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%95%E5%85%A5config-client%E4%BE%9D%E8%B5%96"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">项目中引入config client依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">编写配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">远程仓库配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9B%B4%E6%8E%A5%E6%8A%A5%E9%94%99"><span class="toc-number">1.10.2.4.</span> <span class="toc-text">直接启动过程中发现无法启动直接报错</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%A5%E9%94%99%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.10.2.4.1.</span> <span class="toc-text">报错原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.10.2.4.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%88%B7%E6%96%B0"><span class="toc-number">1.10.2.5.</span> <span class="toc-text">手动配置刷新</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E5%85%A5actuator%E7%9B%91%E6%8E%A7%E4%BE%9D%E8%B5%96"><span class="toc-number">1.10.2.5.1.</span> <span class="toc-text">引入actuator监控依赖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8config-client%E7%AB%AF%E5%8A%A0%E5%85%A5%E5%88%B7%E6%96%B0%E6%9A%B4%E9%9C%B2%E7%AB%AF%E7%82%B9"><span class="toc-number">1.10.2.5.2.</span> <span class="toc-text">在config client端加入刷新暴露端点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E9%9C%80%E8%A6%81%E5%88%B7%E6%96%B0%E4%BB%A3%E7%A0%81%E7%9A%84%E7%B1%BB%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%88%B7%E6%96%B0%E9%85%8D%E7%BD%AE%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.10.2.5.3.</span> <span class="toc-text">在需要刷新代码的类中加入刷新配置的注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E5%8F%91%E9%80%81post%E8%AF%B7%E6%B1%82%E6%89%8D%E4%BC%9A%E5%88%B7%E6%96%B0%E9%85%8D%E7%BD%AE"><span class="toc-number">1.10.2.5.4.</span> <span class="toc-text">需要手动发送post请求才会刷新配置</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#springcloudalibaba"><span class="toc-number">2.</span> <span class="toc-text">springcloudalibaba</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B%E5%92%8C%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">简介和组件介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-1"><span class="toc-number">2.2.</span> <span class="toc-text">环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E6%95%B4%E7%90%86-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">思路整理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">具体实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nacos%E7%BB%84%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">nacos组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nacos%E7%AE%80%E4%BB%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">nacos简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nacos%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="toc-number">2.3.2.</span> <span class="toc-text">nacos安装和配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nacos-client%E5%BC%80%E5%8F%91"><span class="toc-number">2.3.3.</span> <span class="toc-text">nacos client开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nacos%E7%BB%86%E8%8A%82"><span class="toc-number">2.3.4.</span> <span class="toc-text">nacos细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.</span> <span class="toc-text">服务间通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-number">2.5.</span> <span class="toc-text">统一配置中心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nacos%E4%BD%9C%E4%B8%BA%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BD%BF%E7%94%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text">nacos作为统一配置中心使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nacos%E4%BD%9C%E4%B8%BA%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%BB%86%E8%8A%82"><span class="toc-number">2.5.2.</span> <span class="toc-text">nacos作为统一配置中心细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nacos%E7%9A%84mysql%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">2.5.3.</span> <span class="toc-text">nacos的mysql数据持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nacos%E9%9B%86%E7%BE%A4"><span class="toc-number">2.5.4.</span> <span class="toc-text">nacos集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.5.</span> <span class="toc-text">集群搭建遇到问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sentinel%E7%BB%84%E4%BB%B6"><span class="toc-number">2.6.</span> <span class="toc-text">sentinel组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinel-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.6.1.</span> <span class="toc-text">sentinel 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.2.</span> <span class="toc-text">sentinel实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinel-dashboard%E4%BD%BF%E7%94%A8"><span class="toc-number">2.6.3.</span> <span class="toc-text">sentinel dashboard使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinel%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">2.6.4.</span> <span class="toc-text">sentinel组件使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinel%E8%A7%84%E5%88%99%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.6.5.</span> <span class="toc-text">sentinel规则介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinel%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">2.6.6.</span> <span class="toc-text">sentinel流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinel%E7%86%94%E6%96%AD%E8%A7%84%E5%88%99"><span class="toc-number">2.6.7.</span> <span class="toc-text">sentinel熔断规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81%EF%BC%88%E8%BF%98%E9%9C%80%E7%90%86%E8%A7%A3%EF%BC%89"><span class="toc-number">2.6.8.</span> <span class="toc-text">热点参数限流（还需理解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81"><span class="toc-number">2.6.9.</span> <span class="toc-text">系统自适应限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E9%99%90%E6%B5%81"><span class="toc-number">2.6.10.</span> <span class="toc-text">黑白名单限流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#springcloud%E6%95%B4%E5%90%88alibaba"><span class="toc-number">3.</span> <span class="toc-text">springcloud整合alibaba</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/12796/" title="centos7"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/centos.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="centos7"/></a><div class="content"><a class="title" href="/posts/12796/" title="centos7">centos7</a><time datetime="2022-05-18T07:14:53.000Z" title="发表于 2022-05-18 15:14:53">2022-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/49176/" title="docker"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/docker.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="docker"/></a><div class="content"><a class="title" href="/posts/49176/" title="docker">docker</a><time datetime="2022-05-17T07:52:50.000Z" title="发表于 2022-05-17 15:52:50">2022-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/22256/" title="swagger"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/swagger.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="swagger"/></a><div class="content"><a class="title" href="/posts/22256/" title="swagger">swagger</a><time datetime="2022-05-17T07:23:44.000Z" title="发表于 2022-05-17 15:23:44">2022-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/43167/" title="git"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/git.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git"/></a><div class="content"><a class="title" href="/posts/43167/" title="git">git</a><time datetime="2022-05-17T07:23:16.000Z" title="发表于 2022-05-17 15:23:16">2022-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/17327/" title="rabbitMq"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/rabbitmq.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="rabbitMq"/></a><div class="content"><a class="title" href="/posts/17327/" title="rabbitMq">rabbitMq</a><time datetime="2022-05-17T07:07:36.000Z" title="发表于 2022-05-17 15:07:36">2022-05-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 茶白</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const disqus_config = function () {
    this.page.url = 'https://chabai000.github.io/posts/41300/'
    this.page.identifier = '/posts/41300/'
    this.page.title = 'springcloud'
  }

  const disqusReset = () => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addGlobalFn('themeChange', disqusReset, 'disqus')

  const loadDisqus = () =>{
    if (window.DISQUS) disqusReset()
    else {
      const script = document.createElement('script')
      script.src = 'https://lchabai.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=lchabai&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if ('Disqus' === 'Disqus' || !true) {
    if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    fetch('https://disqus.com/api/3.0/forums/listPosts.json?forum=lchabai&related=thread&limit=6&api_key=')
      .then(response => response.json())
      .then(data => {
        const disqusArray = data.response.map(item => {
          return {
            'avatar': item.author.avatar.cache,
            'content': changeContent(item.message),
            'nick': item.author.name,
            'url': item.url,
            'date': item.createdAt
          }
        })

        saveToLocal.set('disqus-newest-comments', JSON.stringify(disqusArray), 10/(60*24))
        generateHtml(disqusArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (false) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick}</span><time> / ${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('disqus-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9310458102" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-lrcType="0"> </div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>