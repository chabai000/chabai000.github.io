<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java八股文-高级篇 | 茶白的博客</title><meta name="author" content="茶白"><meta name="copyright" content="茶白"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="锁锁的概念单线程的情况，下面代码中的count，始终只会被一个线程累加，调用addOne()10次，count的值一定就累加了10。 123456789101112131415public class Test &#123;    &#x2F;&#x2F; 计数器    private Integer count &#x3D; 0;        &#x2F;&#x2F; 累加操作    public void addOne() &#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="java八股文-高级篇">
<meta property="og:url" content="https://chabai000.github.io/posts/7648/index.html">
<meta property="og:site_name" content="茶白的博客">
<meta property="og:description" content="锁锁的概念单线程的情况，下面代码中的count，始终只会被一个线程累加，调用addOne()10次，count的值一定就累加了10。 123456789101112131415public class Test &#123;    &#x2F;&#x2F; 计数器    private Integer count &#x3D; 0;        &#x2F;&#x2F; 累加操作    public void addOne() &#123;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.dujin.org/bing/1366.php">
<meta property="article:published_time" content="2023-06-11T14:12:54.000Z">
<meta property="article:modified_time" content="2024-09-05T13:43:05.841Z">
<meta property="article:author" content="茶白">
<meta property="article:tag" content="博客 Java Linux 服务器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.dujin.org/bing/1366.php"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chabai000.github.io/posts/7648/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 茶白","link":"链接: ","source":"来源: 茶白的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java八股文-高级篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-05 21:43:05'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><style type="text/css">.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{left:-66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{left:0!important}</style><meta name="generator" content="Hexo 7.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://api.dujin.org/bing/1366.php')"><nav id="nav"><span id="blog-info"><a href="/" title="茶白的博客"><span class="site-name">茶白的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java八股文-高级篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-11T14:12:54.000Z" title="发表于 2023-06-11 22:12:54">2023-06-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-05T13:43:05.841Z" title="更新于 2024-09-05 21:43:05">2024-09-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>96分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java八股文-高级篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a>锁的概念</h3><p>单线程的情况，下面代码中的count，始终只会被一个线程累加，调用addOne()10次，count的值一定就累加了10。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// 计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 累加操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取计算器的值</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而多线程情况下，有一个线程A调用addOne()10次的中间，就很可能会有另外一个线程B也在调用addOne()方法，这就会导致线程A调用getCount()的结果发现count的累加值会大于10。此时线程A就会觉得莫名其妙。所以对线程A来讲，count是线程不安全的。</p>
<p>要保证线程A调用10次，count的累加值也是10，则需要保证线程A在累加时，其他线程先排队等着。这就是多线程间的同步操作。</p>
<p>同步操作的实现，需要给对象关联一个互斥体，这个互斥体就可以叫做锁。不同的锁的实现方式不一样，这个后面会讲到。java当中的锁、是在多线程环境下为保证共享资源健康、线程安全的一种手段。</p>
<p>线程操作某个共享资源之前，先对资源加一层锁，保证操作期间没有其他线程访问资源，当操作完成后，再释放锁。</p>
<h3 id="java锁的实现"><a href="#java锁的实现" class="headerlink" title="java锁的实现"></a>java锁的实现</h3><h4 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedTest</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">// 同步代码块      </span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">      <span class="comment">// 一些业务操作         </span></span><br><span class="line">      System.out.println(<span class="string">&quot; synchronizedTest&quot;</span>);     </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized这个同步关键字以前性能不是太理想，在随着不停的优化后，它已经成了同步的首先。</p>
<h4 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h4><p>开始讲一个后面要用到的概念，临界区：被同步保护的代码区域。也就是下面字节码中monitorenter和monitorexit指令之间的区域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; synchronizedTest&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述同步代码块对应的字节码：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/java%E5%85%AB%E8%82%A1%E6%96%87-%E9%AB%98%E7%BA%A7%E7%AF%87Pictures/image-20240629160322042.png" alt="image-20240629160322042"></p>
<p>在字节码中，位置3处有个monitorenter就是申请锁的指令，位置19处有个monitorexit就是释放锁的指令。</p>
<p>监视锁monitor 是每个对象都有的一个隐藏字段。申请锁成功之后，monitor就会成为当前线程的唯一持有者。线程第一次执行monitorenter指令后，monitor的值由0变为1。当该线程再次遇到monitorenter指令后，就会将monitor继续累加1。这也是synchronized实现重入锁的原理。</p>
<p>我们知道，JVM会有指令重排序的操作。Java会在位置3和位置4之间插入一个获取屏障，在位置18和19之间插入一个释放屏障，这两个屏障保证临界区内的任何操作都不会被指令重排序到临界区之外。加上锁的排他性，临界区内的操作便具有了原子性。</p>
<p>在monitorexit指令后还会插入一个StoreLoad屏障，该屏障保证了monitorenter和monitorexit指令是成对不混乱的，从而保证了synchronized既可并列又可嵌套。</p>
<h4 id="并发包中的锁类"><a href="#并发包中的锁类" class="headerlink" title="并发包中的锁类"></a>并发包中的锁类</h4><p>并发包中的锁类基本上都是在JDK1.5以后才有的。如下面的可重入锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;test ReentrantLock &quot;</span>);</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注：synchronized也属于可重入锁。</p>
<h3 id="锁涉及的几个重要概念"><a href="#锁涉及的几个重要概念" class="headerlink" title="锁涉及的几个重要概念"></a>锁涉及的几个重要概念</h3><p><strong>死锁</strong></p>
<p>线程之间相互等着对方释放资源，而自己的资源又不释放给别人，这种情况就是死锁。所以，只要其中一线程释放了资源，死锁就会被解除。</p>
<p><strong>重入锁</strong></p>
<p>重入锁指的是，一个线程在拥有了当前资源的锁之后，可以再次拿到该锁而不被阻塞。在后面会讲到synchronized的重入锁原理。</p>
<p><strong>自旋锁</strong></p>
<p>自旋锁指的是，线程在没有获得锁时，不是被直接挂起，而是执行一个空循环（自旋）。默认是循环10次。</p>
<p>自旋锁的目的也就是为了减少线程被挂起的几率，因为线程的挂起和唤醒也都是耗资源的操作。</p>
<p>如果锁被另一个线程占用的时间比较长，即使自旋了之后当前线程还是会被挂起，空循环就会变成浪费系统资源的操作，反而降低了整体性能。所以，自旋锁是不适应锁占用时间长的并发情况的。</p>
<p><strong>自适应自旋锁</strong></p>
<p>自适应自旋锁是对自锁锁的一种优化。当一个线程自旋后成功获得了锁，那么下次自旋的次数就会增加。因为虚拟机认为，既然上次自旋期间成功拿到了锁，那么后面的自旋会有很大几率拿到锁。相反，如果对于某个锁，很少有自旋能够成功获得的，那么后面就会减少自旋次数，甚至省略掉自旋过程，以免浪费处理器资源。</p>
<p>这种锁是默认开启的。</p>
<p><strong>锁消除</strong></p>
<p>锁消除指的是，在编译期间利用“逃逸分析技术”分析出那些不存在竞争却加了锁的代码的锁失效。这样就减少了锁的请求与释放操作，因为锁的请求与释放都会消耗系统资源。</p>
<p>锁消除也是默认开启的。我们知道StringBuffer的append方法是加了锁的，但在下面的情况，它的锁就会失效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        sb.append(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逃逸分析技术，还会将确定不会发生逃逸的对象放在栈内存中而不是堆内存中，所以说，并不是所有的对象都存在堆内存中的。</p>
<p><strong>锁偏向</strong></p>
<p>偏向锁指的是，当第一个线程请求时，会判断锁的对象头里的ThreadId字段的值，如果为空，则让该线程持有偏向锁，并将ThreadId的值置为当前线程ID。当前线程再次进入时，如果线程ID与ThreadId的值相等，则该线程就不会再重复获取锁了。因为锁的请求与释放是要消耗系统资源的。</p>
<p>如果有其他线程也来请求该锁，则偏向锁就会撤销，然后升级为轻量级锁。如果锁的竞争十分激烈，则轻量级锁又会升级为重量级锁。</p>
<p><strong>锁粗化</strong></p>
<p>锁粗化指的是，在编译期间将相邻的同步代码块合并成一个大同步块。这样做可以减少反复申请和释放同一个锁对象导致的系统开销。锁粗化也是默认开启的。</p>
<p>粗化前伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(monitor)&#123;</span><br><span class="line">    method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(monitor)&#123;</span><br><span class="line">    method2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>粗化后伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(monitor)&#123;</span><br><span class="line">    method1();</span><br><span class="line">    method2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁粗化也提醒了我们平时写代码时，尽量不要在循环内使用锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 粗化前</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">    <span class="comment">// 这会导致频繁同步代码，无谓的消耗系统资源</span></span><br><span class="line">    <span class="keyword">synchronized</span>(monitor)&#123;</span><br><span class="line">        doSomething...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 粗化后</span></span><br><span class="line"><span class="keyword">synchronized</span>(monitor)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;    </span><br><span class="line">        doSomething...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类锁和对象锁（重要）"><a href="#类锁和对象锁（重要）" class="headerlink" title="类锁和对象锁（重要）"></a>类锁和对象锁（重要）</h3><p>如果你分不清类锁和对象锁，那你在代码中对于锁的使用和分析就很容易出问题。</p>
<p>对象锁占用的资源是对象级别，类锁占有的资源是类级别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">       <span class="comment">// ==&gt;对象锁：普通实例方法默认同步监视器就是this，</span></span><br><span class="line">    <span class="comment">// 即调用该方法的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ==&gt;对象锁：this表示是对象锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==&gt;类锁：修饰静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodD</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ==&gt;类锁：A.class说明是类锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (A.class) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通方法：任何情况下调用时，都不会发生竞争</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">common</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>methodA,和methodB都是对当前对象加锁，即如果有两个线程同时访问同一个对象的methoA或methodB会发生竞争。如果两个线程访问的是不同对象的methodA和methodB则不会发生竞争。</p>
<p>methodC和methodD是对类加锁，即如果两个线程同时访问同一个对象的methodC和methodD会发生竞争，且两个线程同时访问不同对象的methodC和methodD是也会发生竞争。</p>
<p>如果一个线程访问methodA或methodB，另一个线程访问methodC或methodD，则这两个线程不会发生竞争。因为一个是类锁另一个是对象锁。类锁和对象锁是两个不一样的锁，控制着不同的区域，它们互不干扰。<br><strong>5种类锁示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">        <span class="comment">// 普通字符串属性</span></span><br><span class="line">    <span class="keyword">private</span> String val= <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 静态属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object staticObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==&gt;类锁情况1：synchronized修饰静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ==&gt;类锁情况2：同步块里的对象是类</span></span><br><span class="line">        <span class="keyword">synchronized</span> (A.class) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ==&gt;类锁情况3：同步块里的对象是字符串</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;A&quot;</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodD</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ==&gt;类锁情况4：同步块里的对象是静态属性</span></span><br><span class="line">        <span class="keyword">synchronized</span> (staticObj) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodE</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ==&gt;类锁情况5：同步块里的对象是字符串属性</span></span><br><span class="line">        <span class="keyword">synchronized</span> (val) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：<br>两个线程分别访问一个类的静态synchronized和一个静态不加锁方法时，不阻塞。<br>两个线程分别访问一个类的静态synchronized和一个非静态synchronized方法时，不阻塞。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>同步操作的实现，需要给对象关联一个互斥体，这个互斥体就可以叫做锁</p>
<p>锁的作用是，保证同一竞争资源在同一时刻只会有一个线程占有</p>
<p>Java中锁的实现方式有两种：synchronized关键字和并发包中的锁类</p>
<p>锁的优化策略有：锁消除、锁偏向、自适应自旋锁、锁粗化</p>
<p>尽量不要在循环内使用锁，以减少资源消耗</p>
<p>后面会接着介绍并发包里的几个锁，以及它们之间的区别</p>
<h2 id="多线程和异步"><a href="#多线程和异步" class="headerlink" title="多线程和异步"></a>多线程和异步</h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><blockquote>
<p>程序</p>
</blockquote>
<p>定义：</p>
<blockquote>
<p>进程(现在操作系统都是多进程的)</p>
</blockquote>
<p>定义：</p>
<h3 id="并行和并发区别"><a href="#并行和并发区别" class="headerlink" title="并行和并发区别"></a>并行和并发区别</h3><blockquote>
<p>并行</p>
</blockquote>
<p>并行是指在同一时间内同时执行多个任务。通常，只有在有多个处理器或多核处理器的情况下才能实现并行。</p>
<p>例子：</p>
<p>假设你有两只手需要同时完成两项任务：一只手刷牙，另一只手梳头。两只手同时动作，这就是并行。</p>
<p>编程中的例子：在一个多核CPU上，两个线程同时计算复杂的数学运算。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ParallelExample &#123;</span><br><span class="line"><span class="code">    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="code">        Runnable task1 = () -&gt; &#123;</span></span><br><span class="line"><span class="code">            for (int i = 0; i &lt; 10; i++) &#123;</span></span><br><span class="line"><span class="code">                System.out.println(&quot;Task 1 - &quot; + i);</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;;</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">        Runnable task2 = () -&gt; &#123;</span></span><br><span class="line"><span class="code">            for (int i = 0; i &lt; 10; i++) &#123;</span></span><br><span class="line"><span class="code">                System.out.println(&quot;Task 2 - &quot; + i);</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;;</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">        Thread thread1 = new Thread(task1);</span></span><br><span class="line"><span class="code">        Thread thread2 = new Thread(task2);</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">        thread1.start();</span></span><br><span class="line"><span class="code">        thread2.start();</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>串行</p>
</blockquote>
<p>串行是指在同一时间内只能执行一个任务，完成一个任务后再执行下一个任务。</p>
<p>例子：</p>
<p>假设你有两项任务：先刷牙，再梳头。你必须先完成刷牙，然后才能开始梳头。这就是串行。</p>
<p>编程中的例子：在单线程中依次执行两个任务。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SerialExample &#123;</span><br><span class="line"><span class="code">    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="code">        for (int i = 0; i &lt; 10; i++) &#123;</span></span><br><span class="line"><span class="code">            System.out.println(&quot;Task 1 - &quot; + i);</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">        for (int i = 0; i &lt; 10; i++) &#123;</span></span><br><span class="line"><span class="code">            System.out.println(&quot;Task 2 - &quot; + i);</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>并发</p>
</blockquote>
<p>并发是指在同一时间内可以处理多个任务，但这些任务不一定同时进行。它们可能在时间片之间切换，看起来像是同时进行。</p>
<p>例子：</p>
<p>假设你有两项任务：刷牙和梳头。你先刷几下牙，然后暂停一下去梳几下头，再回过头来继续刷牙，如此交替进行。这就是并发。</p>
<p>编程中的例子：在单核CPU上，通过时间片轮转来执行多个任务。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ConcurrencyExample &#123;</span><br><span class="line"><span class="code">    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="code">        Runnable task1 = () -&gt; &#123;</span></span><br><span class="line"><span class="code">            for (int i = 0; i &lt; 10; i++) &#123;</span></span><br><span class="line"><span class="code">                System.out.println(&quot;Task 1 - &quot; + i);</span></span><br><span class="line"><span class="code">                try &#123;</span></span><br><span class="line"><span class="code">                    Thread.sleep(50); // Simulate time-consuming task</span></span><br><span class="line"><span class="code">                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="code">                    e.printStackTrace();</span></span><br><span class="line"><span class="code">                &#125;</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;;</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">        Runnable task2 = () -&gt; &#123;</span></span><br><span class="line"><span class="code">            for (int i = 0; i &lt; 10; i++) &#123;</span></span><br><span class="line"><span class="code">                System.out.println(&quot;Task 2 - &quot; + i);</span></span><br><span class="line"><span class="code">                try &#123;</span></span><br><span class="line"><span class="code">                    Thread.sleep(50); // Simulate time-consuming task</span></span><br><span class="line"><span class="code">                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="code">                    e.printStackTrace();</span></span><br><span class="line"><span class="code">                &#125;</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;;</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">        Thread thread1 = new Thread(task1);</span></span><br><span class="line"><span class="code">        Thread thread2 = new Thread(task2);</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">        thread1.start();</span></span><br><span class="line"><span class="code">        thread2.start();</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结</p>
</blockquote>
<ul>
<li><strong>并行</strong>：多个任务同时进行（多个处理器）。</li>
<li><strong>串行</strong>：一个任务完成后再进行下一个任务（单个处理器）。</li>
<li><strong>并发</strong>：多个任务交替进行，看起来像是同时进行（单个处理器通过时间片轮转）。</li>
</ul>
<h3 id="并发的实现"><a href="#并发的实现" class="headerlink" title="并发的实现"></a>并发的实现</h3><blockquote>
<p>时间片</p>
</blockquote>
<h3 id="并发作用"><a href="#并发作用" class="headerlink" title="并发作用"></a>并发作用</h3><blockquote>
<p>减少cpu闲置</p>
</blockquote>
<blockquote>
<p>提高系统响应</p>
</blockquote>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><blockquote>
<p>线程</p>
</blockquote>
<p>进程的最小调度单位是线程，可以简单的把进程看做是一些线程的集合，一个进程最少有一个线程，也可能有很多线程。</p>
<p>所以：1、多核CPU同时可以执行多个线程，有几个核就能执行几个线程(但注意一个cpu核一个时刻就只能干一件事)。2、这些线程分属不同进程的话就是执行了多个进程。3、这些线程分属同一个进程的话就是只执行了一个进程的不同线程。4、多核CPU和多个CPU运行机制相同也不同，单就运行多线程任务来讲原理是差不多的。</p>
<p>以上所有答案就是建立在没有线程切换执行的情况下</p>
<p><strong>延申</strong></p>
<p><strong>CPU核数（Cores）</strong>：CPU的核数决定了可以同时执行多少个线程。一个8核的CPU可以同时执行8个线程。但操作系统和调度程序能够在时间片的基础上管理数千个线程的执行，即使你的CPU只有8个核心，操作系统仍然可以通过快速切换上下文来管理和执行大量线程。</p>
<blockquote>
<p>什么是多线程</p>
</blockquote>
<p>多线程（Multithreading）是指在一个进程（Process）中同时执行多个线程（Thread）的技术。每个线程是一个独立的执行路径，可以看作是程序的一部分，并且能够独立执行，同时共享进程的资源。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 以java为例讲解多线程</span></span><br><span class="line"><span class="bullet">-</span> 进程（Process）：当你运行一个Java程序时，操作系统会为该程序创建一个进程。这个进程包含了程序的代码、数据、和资源（如内存、文件句柄等）。</span><br><span class="line"><span class="bullet">-</span> 主线程（Main Thread）：每个Java程序在启动时会默认创建一个线程，这个线程通常被称为主线程（Main Thread），它运行main方法中的代码。</span><br><span class="line"><span class="bullet">-</span> 多线程（Multithreading）：在开发Java程序时，你可以在主线程之外创建额外的线程来并发执行任务。这样，你的程序中就包含了多个线程，同时运行不同的代码块。</span><br><span class="line"><span class="section"># 配合代码讲解(单核cpu为例)</span></span><br><span class="line"><span class="code">        public class MultiThreadExample &#123;</span></span><br><span class="line"><span class="code">            public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="code">                // 主线程执行</span></span><br><span class="line"><span class="code">                System.out.println(&quot;Main thread is running&quot;);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">                // 创建并启动第一个线程</span></span><br><span class="line"><span class="code">                Thread thread1 = new Thread(new Task(), &quot;Thread-1&quot;);</span></span><br><span class="line"><span class="code">                thread1.start();</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">                // 创建并启动第二个线程</span></span><br><span class="line"><span class="code">                Thread thread2 = new Thread(new Task(), &quot;Thread-2&quot;);</span></span><br><span class="line"><span class="code">                thread2.start();</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">                // 主线程的任务</span></span><br><span class="line"><span class="code">                System.out.println(&quot;Main thread is finished&quot;);</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        class Task implements Runnable &#123;</span></span><br><span class="line"><span class="code">            @Override</span></span><br><span class="line"><span class="code">            public void run() &#123;</span></span><br><span class="line"><span class="code">                // 线程执行的任务</span></span><br><span class="line"><span class="code">                System.out.println(Thread.currentThread().getName() + &quot; is running&quot;);</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">- 主线程：main方法中的代码在主线程中执行。当你运行这个程序时，&quot;Main thread is running&quot;和&quot;Main thread is finished&quot;会在主线程中打印。</span></span><br><span class="line"><span class="code">- 线程创建：通过创建Thread对象并传入Runnable接口实现的实例，我们定义了新的线程。在这个示例中，Task类实现了Runnable接口，并在run方法中定义了线程执行的任务。</span></span><br><span class="line"><span class="code">- 启动线程：调用thread1.start()和thread2.start()启动新线程。每个线程会`并发`地执行其run方法中的代码，并打印相应的消息。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么需要多线程</p>
</blockquote>
<p><strong>并行处理</strong>：在多核CPU上，多个线程可以并行执行任务，提高计算效率。</p>
<p><strong>异步操作</strong>：在执行耗时操作（如I&#x2F;O操作、网络请求）时，可以使用线程避免阻塞主线程，从而保持程序的响应性。</p>
<p><strong>资源共享</strong>：多个线程可以共享相同的资源（如内存、文件），提高资源利用率。</p>
<h3 id="同步vs异步"><a href="#同步vs异步" class="headerlink" title="同步vs异步"></a>同步vs异步</h3><p><strong>同步</strong>和<strong>异步</strong>是两种不同的执行模式，尤其在处理I&#x2F;O操作、网络请求和其他耗时任务时，它们表现得尤为不同。</p>
<blockquote>
<p>同步(sync)</p>
</blockquote>
<p>同步操作是指任务按顺序执行，一个任务必须等待前一个任务完成后才能开始。换句话说，后续任务的执行依赖于前一任务的完成。</p>
<p>例子：</p>
<p>你在餐馆点了一份牛排，必须等待厨师做好牛排后才能继续点饮料。</p>
<p>编程中的例子：</p>
<p>在Java中，读取文件内容的同步操作：在这个例子中，程序在读取文件内容时会阻塞，直到文件读取完成后才会继续执行后续代码。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.file.<span class="emphasis">*;</span></span><br><span class="line"><span class="emphasis">import java.io.IOException;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">public class SynchronousExample &#123;</span></span><br><span class="line"><span class="emphasis">    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="emphasis">        try &#123;</span></span><br><span class="line"><span class="emphasis">            String content = new String(Files.readAllBytes(Paths.get(&quot;example.txt&quot;)));</span></span><br><span class="line"><span class="emphasis">            System.out.println(content);</span></span><br><span class="line"><span class="emphasis">        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="emphasis">            e.printStackTrace();</span></span><br><span class="line"><span class="emphasis">        &#125;</span></span><br><span class="line"><span class="emphasis">    &#125;</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>异步(async)</p>
</blockquote>
<p>异步操作是指任务可以独立执行，不必等待其他任务完成。在发起异步操作后，程序可以立即继续执行后续代码，异步任务在后台完成后通知主程序。</p>
<p>例子：</p>
<p>你在餐馆点了一份牛排，并告诉服务员在牛排准备好时通知你，然后你可以继续点饮料或者进行其他操作。</p>
<p>编程中的例子：</p>
<p>在Java中，使用<code>CompletableFuture</code>进行异步操作：在这个例子中，异步任务在后台运行，主程序不会阻塞，可以继续执行其他操作。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CompletableFuture;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line">public class AsynchronousExample &#123;</span><br><span class="line"><span class="code">    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="code">        // 创建一个CompletableFuture对象，异步执行一个任务</span></span><br><span class="line"><span class="code">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span></span><br><span class="line"><span class="code">            try &#123;</span></span><br><span class="line"><span class="code">                // 模拟一个耗时任务，暂停2秒</span></span><br><span class="line"><span class="code">                Thread.sleep(2000);</span></span><br><span class="line"><span class="code">                System.out.println(&quot;Task completed!&quot;); // 任务完成后打印信息</span></span><br><span class="line"><span class="code">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="code">                e.printStackTrace();</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        // 不用等待异步执行完主线程继续执行其他任务</span></span><br><span class="line"><span class="code">        System.out.println(&quot;Continue with other tasks...&quot;);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        try &#123;</span></span><br><span class="line"><span class="code">            // 可选地等待异步任务完成</span></span><br><span class="line"><span class="code">            future.get();</span></span><br><span class="line"><span class="code">        &#125; catch (InterruptedException | ExecutionException e) &#123;</span></span><br><span class="line"><span class="code">            e.printStackTrace();</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">总结：在Java中，使用CompletableFuture.runAsync()方法时，异步任务通常会被分配给一个新的线程来完成。这个线程与主线程是并行运行的，因此主线程不会被阻塞，可以继续执行其他任务。</span></span><br><span class="line"><span class="code">当你调用CompletableFuture.runAsync()时，实际上是将任务提交给一个ForkJoinPool.commonPool()，这是一个默认的线程池。这个线程池包含多个线程，可以用来并行执行异步任务。</span></span><br><span class="line"><span class="code">总之，异步任务在Java中通常是通过线程池分配给其他线程来完成的，这样可以避免阻塞主线程，提高程序的并发能力和响应性。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么需要异步</p>
</blockquote>
<p><strong>提高性能和响应速度</strong>：异步操作可以避免阻塞主线程，特别是在处理I&#x2F;O操作（如网络请求、文件读取）时，可以大大提高程序的响应速度和性能。</p>
<p><strong>增强用户体验</strong>：在用户界面程序中，异步操作可以确保界面在后台任务执行时仍然响应用户输入，避免“卡顿”现象。例如，网页在加载数据时可以继续响应用户的点击和滚动操作。</p>
<p><strong>资源高效利用</strong>：通过异步操作，可以在等待I&#x2F;O操作完成时继续执行其他任务，提高CPU的利用率。</p>
<p><strong>并发执行</strong>：异步编程模型使得处理多个任务更加自然和高效，特别是对于需要并发执行的任务。</p>
<blockquote>
<p>异步操作的应用场景</p>
</blockquote>
<p><strong>网络请求</strong>：发送HTTP请求时，使用异步操作可以在等待服务器响应时继续处理其他逻辑。</p>
<p><strong>文件操作</strong>：读取或写入大文件时，使用异步操作可以避免阻塞主线程，提高程序的整体性能。</p>
<p><strong>数据库查询</strong>：执行长时间运行的数据库查询时，使用异步操作可以提高应用程序的响应速度和并发能力。</p>
<p><strong>用户界面</strong>：在图形用户界面程序中，使用异步操作可以在后台处理任务的同时保持界面的响应性。</p>
<p>通过理解同步和异步的概念及其应用场景，可以更好地设计和优化程序，提高性能和用户体验。</p>
<blockquote>
<p>异步带来的问题(即多线程带来的问题)</p>
</blockquote>
<ol>
<li>复杂性增加</li>
</ol>
<p><strong>问题</strong>：异步代码往往比同步代码更复杂，难以理解和维护。调试异步代码也更加困难，因为任务是在不同线程中执行的，导致栈跟踪和日志记录变得不直观。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用明确的代码结构和清晰的注释。</li>
<li>利用现代IDE的调试工具。</li>
<li>使用合适的日志框架，确保日志信息完整且易于追踪。</li>
</ul>
<ol start="2">
<li>线程安全问题</li>
</ol>
<p><strong>问题</strong>：由于多个线程同时运行，可能会导致数据竞争和不一致的问题，特别是在访问共享资源时。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用同步机制（如<code>sychronized</code>关键字、锁、信号量等）来保护共享资源。</li>
<li>使用线程安全的数据结构（如<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>等）。</li>
</ul>
<ol start="3">
<li>死锁</li>
</ol>
<p><strong>问题</strong>：多个线程互相等待对方释放资源，导致程序无法继续执行。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>尽量减少锁的使用。</li>
<li>避免嵌套锁，或者使用锁的顺序来防止死锁。</li>
<li>使用超时机制，例如<code>tryLock</code>方法，避免永久等待。</li>
</ul>
<ol start="4">
<li>资源泄漏</li>
</ol>
<p><strong>问题</strong>：线程和任务需要消耗系统资源（如内存、文件句柄等）。如果没有正确管理，可能会导致资源泄漏。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用适当的资源管理工具，如<code>try-with-resources</code>语句来自动管理资源。</li>
<li>定期监控和回收不再使用的资源。</li>
<li>正确关闭线程池和异步任务。</li>
</ul>
<ol start="5">
<li>回调地狱（Callback Hell）</li>
</ol>
<p><strong>问题</strong>：在异步编程中，嵌套过多的回调函数会导致代码结构复杂和难以维护，这种情况通常被称为“回调地狱”。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用更高级的抽象，如<code>CompletableFuture</code>或其他异步框架（如RxJava、Akka）来处理异步逻辑。</li>
<li>将复杂的回调链拆分为单独的方法或类。</li>
</ul>
<ol start="6">
<li>错误处理困难</li>
</ol>
<p><strong>问题</strong>：异步任务的错误处理比同步任务复杂，因为错误可能发生在不同的线程中，且错误信息可能难以传递和处理。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用<code>CompletableFuture</code>提供的异常处理方法，如<code>exceptionally</code>、<code>handle</code>和<code>whenComplete</code>。</li>
<li>确保所有异步任务都有适当的异常处理逻辑。</li>
</ul>
<ol start="7">
<li>状态管理复杂</li>
</ol>
<p><strong>问题</strong>：异步任务的状态管理比同步任务复杂，因为任务可能在不同的时间和不同的线程中运行。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用不可变对象或线程安全的数据结构来管理状态。</li>
<li>使用状态机或其他模式来管理复杂的状态转换。</li>
</ul>
<blockquote>
<p>DMA </p>
</blockquote>
<p>通过硬件完成异步 不需要通过新建线程</p>
<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><blockquote>
<p>阻塞</p>
</blockquote>
<blockquote>
<p>非阻塞</p>
</blockquote>
<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h5 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h5><p>我们根据id查询文章我们业务层代码会这么写，先去查询redis缓存，查询到直接返回结果，没有在缓存再去查询mysql数据库返回结果并且把数据写到缓存里。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/java%E5%85%AB%E8%82%A1%E6%96%87-%E9%AB%98%E7%BA%A7%E7%AF%87Pictures/image-20240611174207119.png" alt="image-20240611174207119"></p>
<p><strong>示例代码：</strong></p>
<p><strong>查询Redis缓存</strong>：</p>
<ul>
<li>在<code>ArticleService</code>类中，使用<code>redisTemplate</code>从Redis缓存中查询文章。</li>
<li>如果在缓存中找到文章，直接返回结果。</li>
</ul>
<p><strong>查询MySQL数据库</strong>：</p>
<ul>
<li>如果缓存未命中，使用<code>articleRepository</code>从MySQL数据库中查询文章。</li>
<li>如果查询到结果，将文章存储到Redis缓存中，并设置缓存时间（例如1小时）。</li>
<li>最后返回查询结果。</li>
</ul>
<p>以下是一个简单的Java示例代码，展示了上述流程的实现。假设你使用Spring Boot框架，并且已经配置好了Redis和MySQL连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在pom.xml中添加所需的依赖：</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- Spring Boot Starter Data JPA --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- MySQL Connector --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Spring Boot Starter Data Redis --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Spring Boot Starter Web --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>Redis配置</span><br><span class="line">在application.properties中配置Redis：</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line">spring.redis.port=<span class="number">6379</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>实体类和存储库</span><br><span class="line">Article实体类：</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>ArticleRepository接口：</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ArticleRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Article, Long&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>Redis配置类</span><br><span class="line">RedisConfig类：</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>服务层代码</span><br><span class="line">ArticleService类：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleRepository articleRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ARTICLE_CACHE_KEY</span> <span class="operator">=</span> <span class="string">&quot;article:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Article <span class="title function_">getArticleById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> ARTICLE_CACHE_KEY + id;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从Redis缓存中查询</span></span><br><span class="line">        <span class="type">Article</span> <span class="variable">article</span> <span class="operator">=</span> (Article) redisTemplate.opsForValue().get(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (article != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> article;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存未命中，从数据库中查询</span></span><br><span class="line">        article = articleRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (article != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将查询结果存储到Redis缓存中，设置缓存时间为1小时</span></span><br><span class="line">            redisTemplate.opsForValue().set(cacheKey, article, <span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> article;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>控制层代码</span><br><span class="line">ArticleController类：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleService articleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/articles/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Article <span class="title function_">getArticleById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> articleService.getArticleById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述代码，可以有效实现根据ID查询文章的功能，优先从Redis缓存中获取数据，避免频繁访问数据库，提升系统性能。同时确保缓存未命中时，从数据库中查询并更新缓存，保证数据的及时性。</p>
<h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h5><blockquote>
<p>定义</p>
</blockquote>
<p>缓存穿透是指查询一个一定不存在的数据，由于缓存中没有该数据，数据库也查不到，导致每次请求都要到数据库去查询，失去了缓存的意义。</p>
<blockquote>
<p>可能影响</p>
</blockquote>
<p><strong>数据库压力</strong>：由于查询不存在的数据，每次请求都会直接访问数据库，可能导致数据库压力增大，影响其他正常查询。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>缓存空对象</strong>：如果查询结果为空（null 或者空字符串），仍然将该结果缓存起来，但设置一个较短的过期时间。</p>
<p><strong>布隆过滤器</strong>：利用布隆过滤器对所有可能存在的数据进行预先判定，查询前先判断是否存在，从而避免大量无效查询落入数据库。</p>
<h5 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h5><blockquote>
<p>定义</p>
</blockquote>
<p>缓存击穿是指某个热点数据的缓存失效，在高并发情况下，多个请求同时击中数据库，造成数据库压力骤增。</p>
<blockquote>
<p>可能影响</p>
</blockquote>
<p><strong>短时间内数据库负载剧增</strong>：热点数据失效后，高并发请求直接打到数据库，可能导致数据库负载剧增，甚至崩溃。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>互斥锁</strong>：使用分布式锁（如Redis的SETNX）来确保同一时间只有一个请求能查询数据库并刷新缓存。</p>
<p><strong>预热</strong>：在缓存失效前主动刷新缓存。</p>
<h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><blockquote>
<p>定义</p>
</blockquote>
<p>缓存雪崩是指缓存服务器宕机或大批量缓存同时失效，导致大量请求直接访问数据库，数据库瞬间压力过大，甚至宕机。</p>
<blockquote>
<p>可能影响</p>
</blockquote>
<p><strong>大面积数据库负载剧增</strong>：大量缓存同时失效，所有请求直接打到数据库，可能导致数据库和应用崩溃。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>缓存设置不同的过期时间</strong>：避免缓存同时失效。</p>
<p><strong>限流和降级</strong>：设置接口的限流策略，在缓存失效时进行流量控制和服务降级。</p>
<p><strong>高可用部署</strong>：通过Redis集群或者哨兵模式保证缓存服务的高可用性。</p>
<h5 id="双写一致"><a href="#双写一致" class="headerlink" title="双写一致"></a>双写一致</h5><blockquote>
<p>定义</p>
</blockquote>
<p>双写一致是指在缓存和数据库同时更新数据时，确保数据一致性。</p>
<blockquote>
<p>可能影响</p>
</blockquote>
<p><strong>数据不一致</strong>：如果缓存和数据库中的数据不同步，可能导致读取到过期数据或脏数据，影响系统一致性。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>先删除缓存，再更新数据库</strong>：这样避免了缓存脏数据的问题，但可能出现短暂的缓存不一致。</p>
<p><strong>延时双删</strong>：更新数据库后，删除缓存，等待一定时间后再次删除缓存，确保数据一致性。</p>
<p><strong>使用消息队列</strong>：数据库更新后，发送消息通知缓存更新，从而确保缓存和数据库的一致性。</p>
<h5 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h5><blockquote>
<p>定义</p>
</blockquote>
<p>Redis提供了两种持久化机制：RDB和AOF。</p>
<p><strong>RDB</strong>（Redis DataBase）：将数据快照保存到磁盘，恢复时加载到内存。适合数据不太重要且需要快速恢复的场景。</p>
<p><strong>AOF</strong>（Append Only File）：将每次写操作记录到日志文件，可以更细粒度地恢复数据，适合数据重要且要求高可靠性的场景。</p>
<blockquote>
<p>可能影响</p>
</blockquote>
<p><strong>数据丢失风险</strong>：如果持久化机制没有及时备份数据，可能会导致数据丢失，影响数据安全。</p>
<p><strong>性能影响</strong>：持久化操作可能会影响Redis的性能，尤其是AOF在写入大量数据时。</p>
<h5 id="数据过期"><a href="#数据过期" class="headerlink" title="数据过期"></a>数据过期</h5><blockquote>
<p>定义</p>
</blockquote>
<p>设置数据过期时间，使得不再需要的数据自动删除，释放内存。</p>
<p><strong>常见方式</strong>：</p>
<ul>
<li><strong>SETEX key seconds value</strong>：设置键值对并设置过期时间。</li>
<li><strong>EXPIRE key seconds</strong>：设置已有键的过期时间。</li>
</ul>
<blockquote>
<p>可能影响</p>
</blockquote>
<p><strong>数据不准确</strong>：过期策略不当可能导致重要数据被误删除，影响系统功能和用户体验</p>
<h5 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h5><blockquote>
<p>定义</p>
</blockquote>
<p>Redis提供了多种淘汰策略，来处理内存满时的数据清理。</p>
<p><strong>常见策略</strong>：</p>
<ul>
<li><strong>volatile-lru</strong>：从设置了过期时间的数据集中淘汰最近最少使用的数据。</li>
<li><strong>allkeys-lru</strong>：从数据集中淘汰最近最少使用的数据。</li>
<li><strong>volatile-ttl</strong>：从设置了过期时间的数据集中淘汰将要过期的数据。</li>
<li><strong>noeviction</strong>：禁止驱逐数据，写操作会报错</li>
</ul>
<blockquote>
<p>可能影响</p>
</blockquote>
<p><strong>关键数据被淘汰</strong>：如果淘汰策略不当，可能导致关键数据被淘汰，影响系统正常运行</p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><h5 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a>setnx</h5><blockquote>
<p>定义</p>
</blockquote>
<p>SETNX（SET if Not eXists）是Redis实现分布式锁的基本命令，通过它可以确保只有一个客户端能设置成功，从而获得锁。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SETNX lock<span class="emphasis">_key lock_</span>value</span><br><span class="line">EXPIRE lock<span class="emphasis">_key timeout</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能影响</p>
</blockquote>
<p><strong>锁失效风险</strong>：如果锁在执行任务前失效，可能导致多个客户端同时执行任务，破坏数据一致性。</p>
<p><strong>锁争用</strong>：高并发情况下，多个客户端争抢锁，可能导致性能下降。</p>
<h5 id="redisson"><a href="#redisson" class="headerlink" title="redisson"></a>redisson</h5><blockquote>
<p>定义</p>
</blockquote>
<p>Redisson是一个Java的Redis客户端，它提供了分布式锁的高层抽象，使用方便，支持多种锁机制（如可重入锁、公平锁、读写锁等）。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RedissonClient redisson = Redisson.create(config);</span><br><span class="line">RLock lock = redisson.getLock(&quot;myLock&quot;);</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line"><span class="code">    // critical section</span></span><br><span class="line"><span class="code">&#125; finally &#123;</span></span><br><span class="line"><span class="code">    lock.unlock();</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能影响</p>
</blockquote>
<p><strong>依赖性</strong>：引入第三方库可能增加系统复杂性，需要依赖Redisson的稳定性和更新。</p>
<p><strong>性能开销</strong>：Redisson提供了高级锁机制，但也可能带来额外的性能开销。</p>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><h5 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h5><blockquote>
<p>定义</p>
</blockquote>
<p>Redis可以实现高效的计数器，通过INCR命令来增加计数。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR counter<span class="emphasis">_key</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能影响</p>
</blockquote>
<p><strong>热点问题</strong>：高并发情况下，计数器可能成为热点，导致Redis性能下降。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="保存token"><a href="#保存token" class="headerlink" title="保存token"></a>保存token</h5><blockquote>
<p>定义</p>
</blockquote>
<p>可以使用Redis的String类型保存token，并设置过期时间。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET token<span class="emphasis">_key token_</span>value EX 3600</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能影响</p>
</blockquote>
<p><strong>安全性问题</strong>：如果token没有合理的过期时间和安全机制，可能被恶意使用，导致安全问题。</p>
<h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><blockquote>
<p>定义</p>
</blockquote>
<p>可以使用Redis的List数据结构实现简单的消息队列。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSH queue<span class="emphasis">_key message</span></span><br><span class="line"><span class="emphasis">BRPOP queue_</span>key timeout</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能影响</p>
</blockquote>
<p><strong>数据丢失</strong>：Redis重启或崩溃可能导致队列中的消息丢失，影响业务流程。</p>
<h5 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h5><blockquote>
<p>定义</p>
</blockquote>
<p>可以使用Redis的Sorted Set实现延迟队列，通过score来标记消息的处理时间。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZADD delay<span class="emphasis">_queue score message</span></span><br><span class="line"><span class="emphasis">ZRANGEBYSCORE delay_</span>queue 0 current<span class="emphasis">_time</span></span><br><span class="line"><span class="emphasis">ZREM delay_</span>queue message</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能影响</p>
</blockquote>
<p><strong>时间精度</strong>：延迟队列中的消息处理时间精度可能受到影响，导致业务延迟处理。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><h5 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h5><blockquote>
<p>定义</p>
</blockquote>
<p>Redis的主从复制可以通过配置文件或者命令实现，从节点复制主节点的数据。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF master<span class="emphasis">_host master_</span>port</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能影响</p>
</blockquote>
<p><strong>数据延迟</strong>：主从复制存在延迟，可能导致从节点读取到旧数据。</p>
<p><strong>单点故障</strong>：主节点故障会影响从节点的复制和数据一致性</p>
<h5 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h5><blockquote>
<p>定义</p>
</blockquote>
<p>Redis哨兵模式可以实现高可用性，通过监控主节点的状态，当主节点宕机时，自动提升从节点为主节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster master_host master_port quorum</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能影响</p>
</blockquote>
<p><strong>复杂性增加</strong>：哨兵模式增加了系统的复杂性，需要额外的配置和维护。</p>
<p><strong>切换延迟</strong>：主节点故障时，哨兵切换到从节点存在一定延迟，影响服务可用性。</p>
<h5 id="集群-1"><a href="#集群-1" class="headerlink" title="集群"></a>集群</h5><blockquote>
<p>定义</p>
</blockquote>
<p>Redis集群实现数据分片，将数据分布在多个节点上，提供更高的可扩展性和容错性。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create node1:port node2:port ... --cluster-replicas 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能影响</p>
</blockquote>
<p><strong>数据分片问题</strong>：数据在多个节点间分片，可能导致某些节点负载过高，影响性能。</p>
<p><strong>复杂性增加</strong>：集群模式增加了配置和维护的复杂性，需要对数据分片和节点状态进行监控</p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><blockquote>
<p>定义</p>
</blockquote>
<p>Redis事务通过MULTI、EXEC、DISCARD命令实现，可以将多个命令打包成一个事务。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">SET key1 value1</span><br><span class="line">SET key2 value2</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能影响</p>
</blockquote>
<p><strong>有限的原子性</strong>：Redis事务没有回滚机制，部分命令执行失败不会回滚已经成功的命令。</p>
<p><strong>性能开销</strong>：事务操作会增加Redis的性能开销，特别是在高并发情况下。</p>
<h4 id="redis为什么快"><a href="#redis为什么快" class="headerlink" title="redis为什么快"></a>redis为什么快</h4><blockquote>
<p>定义</p>
</blockquote>
<p><strong>内存操作</strong>：Redis是内存数据库，所有数据都存储在内存中，读写速度非常快。</p>
<p><strong>单线程模型</strong>：Redis采用单线程模型，避免了多线程的上下文切换和锁竞争，处理请求更加高效。</p>
<p><strong>非阻塞I&#x2F;O</strong>：使用了非阻塞I&#x2F;O多路复用技术，可以高效地处理大量客户端请求。</p>
<p><strong>数据结构优化</strong>：Redis内置了多种高效的数据结构（如字符串、列表、集合、有序集合、哈希等），针对不同的使用场景进行了优化。</p>
<p><strong>紧凑的数据编码</strong>：Redis对存储的数据进行了紧凑编码，减少了内存的占用，提高了数据访问的效率。</p>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="定位慢查询"><a href="#定位慢查询" class="headerlink" title="定位慢查询"></a>定位慢查询</h4><p><strong>工具</strong></p>
<p>用运维工具Skywalking监测接口</p>
<p><strong>慢查询日志</strong></p>
<ul>
<li><strong>开启慢查询日志</strong>：在MySQL配置文件中，开启慢查询日志记录，设置<code>slow_query_log</code>和<code>long_query_time</code>参数。</li>
<li><strong>查看慢查询日志</strong>：通过分析慢查询日志，定位执行时间较长的SQL语句。</li>
</ul>
<p><strong>查询性能分析工具</strong></p>
<ul>
<li><strong>EXPLAIN</strong>：使用<code>EXPLAIN</code>命令查看SQL执行计划，了解查询的执行流程和索引使用情况。</li>
<li><strong>SHOW PROFILE</strong>：开启<code>profiling</code>，使用<code>SHOW PROFILE</code>查看查询各阶段的耗时情况。</li>
<li><strong>pt-query-digest</strong>：使用<code>pt-query-digest</code>工具分析慢查询日志，生成详细的分析报告。</li>
</ul>
<h4 id="sql执行计划"><a href="#sql执行计划" class="headerlink" title="sql执行计划"></a>sql执行计划</h4><p><strong>EXPLAIN 命令</strong></p>
<ul>
<li><strong>id</strong>：查询的序列号，表示查询中执行的顺序。</li>
<li><strong>select_type</strong>：查询的类型，如SIMPLE、PRIMARY、SUBQUERY等。</li>
<li><strong>table</strong>：显示这一行所访问的表。</li>
<li><strong>type</strong>：连接类型，如ALL、index、range、ref、eq_ref、const、system等，反映查询的效率。</li>
<li><strong>possible_keys</strong>：查询可能使用的索引。</li>
<li><strong>key</strong>：实际使用的索引。</li>
<li><strong>key_len</strong>：使用索引的长度。</li>
<li><strong>ref</strong>：列出使用哪个列与索引一起从表中选取行。</li>
<li><strong>rows</strong>：估计要读取的行数。</li>
<li><strong>Extra</strong>：附加信息，如Using index、Using temporary、Using filesort等。</li>
</ul>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h5 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h5><ul>
<li><strong>InnoDB</strong>：支持事务、行级锁、外键约束，采用B+树索引，适用于高并发和高可靠性要求的场景。</li>
<li><strong>MyISAM</strong>：不支持事务，采用表级锁，适用于读多写少的场景。</li>
<li><strong>Memory</strong>：数据存储在内存中，速度快，但不持久化，适用于临时表或中间结果存储。</li>
<li><strong>Merge</strong>：多个MyISAM表的组合，适用于分区表场景。</li>
<li><strong>Archive</strong>：用于存储历史数据和归档数据，支持高压缩和只支持INSERT和SELECT操作。</li>
</ul>
<h5 id="索引底层数据结构"><a href="#索引底层数据结构" class="headerlink" title="索引底层数据结构"></a>索引底层数据结构</h5><p><strong>B+树</strong>：InnoDB的默认索引结构，具有高效的范围查询和顺序访问性能。</p>
<p><strong>哈希索引</strong>：基于哈希表的索引，适用于等值查询，但不支持范围查询。</p>
<p><strong>全文索引</strong>：用于全文搜索，适用于大文本字段的快速匹配。</p>
<p><strong>R树</strong>：用于地理空间数据存储和查询。</p>
<h5 id="聚簇和非聚簇索引"><a href="#聚簇和非聚簇索引" class="headerlink" title="聚簇和非聚簇索引"></a>聚簇和非聚簇索引</h5><p><strong>聚簇索引</strong>（Clustered Index）：数据行的物理顺序与索引的顺序一致，InnoDB表的主键索引是聚簇索引。</p>
<p><strong>非聚簇索引</strong>（Non-Clustered Index）：索引和数据存储是分开的，索引指向数据的存储位置。</p>
<h5 id="索引创建原则"><a href="#索引创建原则" class="headerlink" title="索引创建原则"></a>索引创建原则</h5><p><strong>选择高选择性的列</strong>：优先为高选择性的列创建索引，能够有效减少扫描的行数。</p>
<p><strong>频繁作为查询条件的列</strong>：对常用作查询条件的列创建索引，提高查询效率。</p>
<p><strong>短字段索引</strong>：对于较长的字符串字段，创建前缀索引，可以减少索引大小。</p>
<p><strong>联合索引</strong>：对于多个条件的查询，可以创建联合索引（复合索引），注意索引的顺序</p>
<h5 id="索引失效场景"><a href="#索引失效场景" class="headerlink" title="索引失效场景"></a>索引失效场景</h5><p><strong>查询条件不符合最左前缀匹配</strong>：联合索引查询时，不符合最左前缀原则，索引会失效。</p>
<p><strong>使用函数操作列</strong>：在查询条件中对索引列使用函数，索引会失效。</p>
<p><strong>类型不一致</strong>：查询条件的类型和索引列类型不一致，可能导致索引失效。</p>
<p><strong>模糊查询</strong>：在LIKE条件中，使用通配符%开头，索引会失效。</p>
<p><strong>范围查询后使用索引列</strong>：在联合索引中，范围查询后的索引列不会被使用。</p>
<h4 id="sql优化经验"><a href="#sql优化经验" class="headerlink" title="sql优化经验"></a>sql优化经验</h4><p><strong>减少查询的列数</strong>：只查询需要的列，减少返回数据量。</p>
<p>**避免SELECT **：避免使用SELECT *，明确指定需要的列。</p>
<p><strong>使用JOIN替代子查询</strong>：JOIN操作通常比子查询更高效。</p>
<p><strong>合理使用索引</strong>：创建和使用合适的索引，避免过多和无效的索引。</p>
<p><strong>分页查询优化</strong>：使用LIMIT结合WHERE条件优化分页查询。</p>
<p><strong>避免复杂的计算和函数</strong>：在查询中避免复杂的计算和函数操作。</p>
<h3 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h3><h4 id="事务相关"><a href="#事务相关" class="headerlink" title="事务相关"></a>事务相关</h4><h5 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h5><p><strong>原子性（Atomicity）</strong>：事务中的所有操作要么全部成功，要么全部失败。</p>
<p><strong>一致性（Consistency）</strong>：事务执行前后，数据库的状态保持一致。</p>
<p><strong>隔离性（Isolation）</strong>：事务之间相互隔离，不能互相干扰。</p>
<p><strong>持久性（Durability）</strong>：事务一旦提交，数据将被永久保存，即使系统崩溃。</p>
<h5 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h5><p><strong>读未提交（Read Uncommitted）</strong>：事务可以读取到其他事务未提交的数据，存在脏读问题。</p>
<p><strong>读已提交（Read Committed）</strong>：事务只能读取到其他事务已提交的数据，解决脏读问题，但可能出现不可重复读。</p>
<p><strong>可重复读（Repeatable Read）</strong>：事务在执行过程中看到的数据是一致的，解决不可重复读问题，但可能出现幻读。</p>
<p><strong>可序列化（Serializable）</strong>：最高的隔离级别，通过加锁保证事务完全隔离，解决所有并发问题，但性能较低。</p>
<h5 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h5><p><strong>多版本并发控制</strong>：通过保存数据的多个版本，实现高效的读写并发。</p>
<p><strong>实现机制</strong>：InnoDB使用隐藏的事务ID和回滚日志来实现MVCC。</p>
<p><strong>优点</strong>：提供一致性读，避免加锁，提高并发性能。</p>
<h4 id="主存同步"><a href="#主存同步" class="headerlink" title="主存同步"></a>主存同步</h4><p><strong>二级缓冲池</strong>：InnoDB使用缓冲池来减少对磁盘的访问，并通过刷新脏页机制保持数据的一致性。</p>
<p><strong>WAL（Write-Ahead Logging）</strong>：在对数据页进行修改前，先将日志写入磁盘，确保数据的持久性。</p>
<p><strong>检查点机制</strong>：定期将内存中的数据页和日志刷到磁盘，确保数据的一致性。</p>
<p><strong>主存同步的具体实现</strong></p>
<h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>读写分离是一种数据库优化技术，主要用于提高数据库系统的性能和扩展性。通过将读操作和写操作分离到不同的数据库实例上，减轻单个数据库实例的压力，提高系统的并发处理能力。</p>
<p><strong>读写分离的基本原理</strong></p>
<ul>
<li><strong>主库（Master）</strong>：负责处理写操作（INSERT、UPDATE、DELETE）和事务操作。</li>
<li><strong>从库（Slave）</strong>：负责处理读操作（SELECT），从主库同步数据，保证数据的一致性。</li>
<li><strong>复制机制</strong>：主库将数据变更通过复制机制同步到从库，保证从库的数据是主库数据的副本。</li>
</ul>
<p><strong>读写分离的具体实现</strong></p>
<h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><p><strong>水平分表</strong>：将一张大表的数据分成多个小表存储，每个小表包含相同的列，但数据范围不同。</p>
<p><strong>垂直分表</strong>：将一张表按列拆分为多个子表，每个子表包含不同的列。</p>
<p><strong>分库</strong>：将数据分散到多个数据库实例中，每个实例存储部分数据。</p>
<p><strong>分片键选择</strong>：根据业务逻辑选择合适的分片键，确保数据均匀分布，减少热点问题。</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h3><h4 id="Bean线程安全问题"><a href="#Bean线程安全问题" class="headerlink" title="Bean线程安全问题"></a>Bean线程安全问题</h4><p>Spring框架的默认配置下，Spring管理的Bean是单例模式的（即一个Bean定义对应一个对象实例），这意味着在多线程环境中，多个线程会共享同一个Bean实例。这可能导致线程安全问题。</p>
<p><strong>示例：</strong></p>
<p>假设一个Bean有一个可变状态的字段，多个线程同时访问并修改这个字段时，可能会出现数据不一致的情况。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><strong>无状态Bean</strong>：尽量设计成无状态Bean，即Bean不存储可变的状态。</li>
<li><strong>Thread-Scope</strong>：使用Spring的Scope机制，将Bean定义为线程作用域（<code>@Scope(&quot;prototype&quot;)</code>或者<code>@Scope(&quot;request&quot;)</code>等）。</li>
<li><strong>线程安全的数据结构</strong>：在Bean中使用线程安全的数据结构，如<code>ConcurrentHashMap</code>。</li>
</ol>
<h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>AOP（Aspect-Oriented Programming，面向切面编程）是Spring中的一个核心特性，用于在不修改源代码的情况下增加功能。它主要包括以下概念：</p>
<ul>
<li><strong>切点（Pointcut）</strong>：定义在什么地方应用通知。</li>
<li><strong>通知（Advice）</strong>：在切点处执行的代码。</li>
<li><strong>切面（Aspect）</strong>：切点和通知的结合。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* your.package.name.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* your.package.name.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfter</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After method: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h4><p>Spring中的事务管理基于AOP。通过声明式事务管理（使用注解或XML配置），Spring会在方法开始前开启一个事务，在方法结束后提交或回滚事务。</p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Spring的事务管理器（<code>PlatformTransactionManager</code>）负责具体的事务处理，包括事务的开启、提交和回滚。</p>
<h4 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h4><p>务失效的原因包括：</p>
<ol>
<li><strong>方法内部调用</strong>：<code>@Transactional</code>注解的方法被同类中的其他方法调用时，事务不会生效。</li>
<li><strong>非公共方法</strong>：<code>@Transactional</code>只能应用于公共方法。</li>
<li><strong>异常未捕获</strong>：只有未捕获的运行时异常才会导致事务回滚。</li>
<li><strong>代理类问题</strong>：Spring AOP默认使用JDK动态代理，只有接口方法会被代理，若使用CGLIB代理，非接口方法也会被代理。</li>
</ol>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="built_in">this</span>.logUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 内部调用，不会触发事务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>Spring管理的Bean生命周期主要包括以下几个阶段：</p>
<ol>
<li><strong>实例化</strong>：使用构造器或工厂方法创建Bean实例。</li>
<li><strong>属性赋值</strong>：Spring将依赖注入到Bean中。</li>
<li><strong>初始化</strong>：调用<code>InitializingBean</code>的<code>afterPropertiesSet()</code>方法或自定义的初始化方法（通过<code>@PostConstruct</code>或XML配置）。</li>
<li><strong>使用</strong>：Bean可以被应用程序使用。</li>
<li><strong>销毁</strong>：应用程序关闭时，调用<code>DisposableBean</code>的<code>destroy()</code>方法或自定义的销毁方法（通过<code>@PreDestroy</code>或XML配置）。</li>
</ol>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean is going through init.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean will destroy now.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="循序依赖"><a href="#循序依赖" class="headerlink" title="循序依赖"></a>循序依赖</h4><p>Spring通过三级缓存（singletonFactories、earlySingletonObjects、singletonObjects）解决Bean的循环依赖问题。具体步骤如下：</p>
<ol>
<li><strong>singletonFactories</strong>：存储Bean的工厂方法。</li>
<li><strong>earlySingletonObjects</strong>：存储早期暴露的Bean。</li>
<li><strong>singletonObjects</strong>：存储完全初始化的Bean。</li>
</ol>
<p>当Spring检测到循环依赖时，会提前暴露一个未完全初始化的Bean到<code>earlySingletonObjects</code>中，以便其他Bean可以引用。</p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="springmvc"><a href="#springmvc" class="headerlink" title="springmvc"></a>springmvc</h3><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>Spring MVC的执行流程如下：</p>
<ol>
<li><strong>客户端请求</strong>：客户端发送请求到服务器。</li>
<li><strong>DispatcherServlet</strong>：Spring MVC的前端控制器（<code>DispatcherServlet</code>）接收请求。</li>
<li><strong>HandlerMapping</strong>：<code>DispatcherServlet</code>通过<code>HandlerMapping</code>确定请求的处理器（Controller）。</li>
<li><strong>HandlerAdapter</strong>：<code>DispatcherServlet</code>通过<code>HandlerAdapter</code>调用处理器方法。</li>
<li><strong>处理请求</strong>：处理器（Controller）处理请求，返回<code>ModelAndView</code>对象。</li>
<li><strong>视图解析</strong>：<code>DispatcherServlet</code>通过<code>ViewResolver</code>解析视图。</li>
<li><strong>视图渲染</strong>：视图渲染数据并返回响应给客户端。</li>
</ol>
<h3 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h3><h4 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h4><p>Spring Boot的自动配置基于<code>@EnableAutoConfiguration</code>注解和<code>spring.factories</code>文件。它通过条件注解（如<code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>等）自动配置各种Spring组件。</p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h3><h4 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h4><p>MyBatis的执行流程如下：</p>
<ol>
<li><strong>SqlSession</strong>：从<code>SqlSessionFactory</code>中获取<code>SqlSession</code>。</li>
<li><strong>执行SQL</strong>：通过<code>SqlSession</code>执行映射的SQL语句。</li>
<li><strong>处理结果</strong>：将SQL执行结果映射成POJO对象。</li>
<li><strong>关闭会话</strong>：关闭<code>SqlSession</code>。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.findById(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><p>MyBatis的延迟加载通过<code>&lt;resultMap&gt;</code>中的<code>&lt;association&gt;</code>和<code>&lt;collection&gt;</code>标签实现，使用<code>lazyLoadingEnabled</code>配置开启延迟加载。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=<span class="string">&quot;userMap&quot;</span> type=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">    &lt;id property=<span class="string">&quot;id&quot;</span> column=<span class="string">&quot;id&quot;</span>/&gt;</span><br><span class="line">    &lt;result property=<span class="string">&quot;name&quot;</span> column=<span class="string">&quot;name&quot;</span>/&gt;</span><br><span class="line">    &lt;association property=<span class="string">&quot;address&quot;</span> javaType=<span class="string">&quot;Address&quot;</span> column=<span class="string">&quot;address_id&quot;</span></span><br><span class="line">                 select=<span class="string">&quot;selectAddressById&quot;</span> fetchType=<span class="string">&quot;lazy&quot;</span>/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="一二级缓存"><a href="#一二级缓存" class="headerlink" title="一二级缓存"></a>一二级缓存</h4><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><p>一级缓存是SqlSession级别的缓存。默认情况下，MyBatis会在同一个SqlSession中缓存查询结果，直到SqlSession被关闭。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.findById(<span class="number">1L</span>); <span class="comment">// 从数据库中查询</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> mapper.findById(<span class="number">1L</span>); <span class="comment">// 从一级缓存中获取</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><p>二级缓存是Mapper级别的缓存。需要在MyBatis配置文件中启用二级缓存，并在Mapper中进行配置。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;setting name=<span class="string">&quot;cacheEnabled&quot;</span> value=<span class="string">&quot;true&quot;</span>/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;your.package.name.mapper.UserMapper&quot;</span>&gt;</span><br><span class="line">    &lt;cache/&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;findById&quot;</span> resultType=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">        SELECT * FROM users <span class="type">WHERE</span> <span class="variable">id</span> <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="消息中间件——RabbitMQ"><a href="#消息中间件——RabbitMQ" class="headerlink" title="消息中间件——RabbitMQ"></a>消息中间件——RabbitMQ</h2><h3 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h3><p>RabbitMQ 提供了多种消息模型，它们是通过生产者，消费者，通道，消息队列、交换机等组件组合而成的。这些模型都具备消息中间件的所有特性，根据具体的业务需求选择合适的模型至关重要。以下是 RabbitMQ 常见的五种消息模型：</p>
<ol>
<li><strong>简单队列模式 (Simple Queue Model)</strong>:<ul>
<li>生产者将消息发送到队列，消费者从队列中接收和处理消息。</li>
<li>适用于单个消费者处理任务的场景。</li>
</ul>
</li>
<li><strong>工作队列模式 (Work Queue Model)</strong>:<ul>
<li>多个消费者从同一个队列中接收消息，每个消息只会被一个消费者处理。</li>
<li>适用于任务分发、负载均衡的场景。</li>
</ul>
</li>
<li><strong>发布&#x2F;订阅模式 (Publish&#x2F;Subscribe Model)</strong>:<ul>
<li>消息被发送到一个交换机，多个队列绑定到该交换机，每个队列接收一份消息副本。</li>
<li>适用于广播消息给多个消费者的场景。</li>
</ul>
</li>
<li><strong>路由模式 (Routing Model)</strong>:<ul>
<li>消息被发送到一个交换机，并根据路由键 (Routing Key) 将消息路由到绑定了相应路由键的队列。</li>
<li>适用于消息需要根据特定条件分发的场景。</li>
</ul>
</li>
<li><strong>主题模式 (Topic Model)</strong>:<ul>
<li>消息被发送到一个交换机，并根据模式匹配 (Wildcard) 将消息路由到相应的队列。</li>
<li>适用于消息需要根据多种条件组合进行分发的场景。</li>
</ul>
</li>
</ol>
<p>在选择消息模型时，应根据具体业务需求进行选择。例如，工作队列模式适合需要并行处理大量任务的场景，而发布&#x2F;订阅模式适合将同一消息广播给多个消费者的场景。了解每种模式的特点和适用场景，可以帮助更好地设计和实现高效的消息处理系统</p>
<h3 id="常用优化特性"><a href="#常用优化特性" class="headerlink" title="常用优化特性"></a>常用优化特性</h3><h4 id="消息不丢失"><a href="#消息不丢失" class="headerlink" title="消息不丢失"></a>消息不丢失</h4><p><strong>实现方法：</strong></p>
<ul>
<li><strong>持久化队列</strong>：队列在声明时设置为持久化，使队列元数据存储在磁盘上。</li>
<li><strong>持久化消息</strong>：消息在发送时标记为持久化，使消息内容存储在磁盘上。</li>
<li>**消息确认 (ACK)**：消费者在处理完消息后发送确认 (ACK)，如果消费者崩溃，RabbitMQ 会重新投递该消息。</li>
</ul>
<p><strong>示例代码:</strong></p>
<p>生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.MessageProperties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DurableProducer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;durable_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Persistent message&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DurableConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;durable_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            channel.basicConsume(QUEUE_NAME, <span class="literal">false</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="消息不重复"><a href="#消息不重复" class="headerlink" title="消息不重复"></a>消息不重复</h4><p><strong>实现方法：</strong></p>
<ul>
<li>使用唯一的消息ID，并在消费者端进行去重处理。</li>
<li>利用数据库或内存结构（如Set）记录处理过的消息ID。</li>
</ul>
<p><strong>示例代码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdempotentConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;durable_queue&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;String&gt; processedMessageIds = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> delivery.getProperties().getMessageId();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (messageId != <span class="literal">null</span> &amp;&amp; !processedMessageIds.contains(messageId)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    processedMessageIds.add(messageId);</span><br><span class="line">                    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot; [x] Duplicate message &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            channel.basicConsume(QUEUE_NAME, <span class="literal">false</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h4><p><strong>实现方法：</strong></p>
<ul>
<li><strong>设置队列长度限制</strong>：通过设置队列的最大长度，防止消息无限积压。</li>
<li><strong>扩展消费者</strong>：增加消费者实例，提高消息处理速度。</li>
<li><strong>消息优先级</strong>：使用消息优先级处理更紧急的消息。</li>
</ul>
<p><strong>示例代码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-max-length&quot;</span>, <span class="number">1000</span>); <span class="comment">// 设置队列的最大长度为1000</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;limited_queue&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="延迟队列-1"><a href="#延迟队列-1" class="headerlink" title="延迟队列"></a>延迟队列</h4><p><strong>实现方法：</strong></p>
<ul>
<li>使用 RabbitMQ 插件 <code>rabbitmq-delayed-message-exchange</code> 实现延迟队列。</li>
<li>消息在延迟一段时间后才被投递到队列。</li>
</ul>
<p><strong>示例代码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueueProducer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delay_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, Map.of(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;delay_queue&quot;</span>;</span><br><span class="line">            channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Delayed message&quot;</span>;</span><br><span class="line">            Map&lt;String, Object&gt; headers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            headers.put(<span class="string">&quot;x-delay&quot;</span>, <span class="number">5000</span>); <span class="comment">// 5秒延迟</span></span><br><span class="line">            AMQP.<span class="type">BasicProperties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties.Builder()</span><br><span class="line">                    .headers(headers)</span><br><span class="line">                    .build();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, props, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27; with delay&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h4><p><strong>实现方法：</strong></p>
<ul>
<li>配置队列，使消息在一定条件下（如被拒绝、TTL过期、队列满）转移到死信队列。</li>
</ul>
<p><strong>示例代码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DLXProducer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">DLX_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;dlx_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明死信交换机</span></span><br><span class="line">            channel.exchangeDeclare(DLX_EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置队列的参数，使其具备死信功能</span></span><br><span class="line">            Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DLX_EXCHANGE_NAME);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 声明普通队列并绑定死信交换机</span></span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br><span class="line">            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 声明死信队列并绑定死信交换机</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">dlxQueueName</span> <span class="operator">=</span> <span class="string">&quot;dlx_queue&quot;</span>;</span><br><span class="line">            channel.queueDeclare(dlxQueueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            channel.queueBind(dlxQueueName, DLX_EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Message with potential to be dead letter&quot;</span>;</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高可用机制"><a href="#高可用机制" class="headerlink" title="高可用机制"></a>高可用机制</h4><p><strong>实现方法：</strong></p>
<ul>
<li>配置队列，使消息在一定条件下（如被拒绝、TTL过期、队列满）转移到死信队列。</li>
</ul>
<p><strong>示例代码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-all <span class="string">&quot;^&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="应用场景（todo）"><a href="#应用场景（todo）" class="headerlink" title="应用场景（todo）"></a>应用场景（todo）</h3><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>五种消息模型加上我们的优化特性基本可适用于我们在工作时遇到的各种业务。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="collection单列集合"><a href="#collection单列集合" class="headerlink" title="collection单列集合"></a>collection单列集合</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><p><strong>定义</strong>：<code>Vector</code>是一个同步（线程安全）的动态数组。它类似于<code>ArrayList</code>，但每个方法都是同步的。</p>
<p><strong>数据结构</strong>：<code>Vector</code>内部使用动态数组实现。当数组容量不足时，它会按一定的增量（默认是原容量的两倍）增加容量。</p>
<p><strong>使用</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">vector.add(<span class="string">&quot;Element 1&quot;</span>);</span><br><span class="line">vector.add(<span class="string">&quot;Element 2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：适用于多线程环境中需要同步的动态数组，但由于同步的开销较大，通常更推荐使用<code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code>。</p>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p><strong>定义</strong>：<code>ArrayList</code>是一个非同步的动态数组，基于数组实现，支持快速随机访问和遍历。</p>
<p><strong>数据结构</strong>：<code>ArrayList</code>内部使用动态数组实现。当数组容量不足时，它会按1.5倍的比例扩容。</p>
<p><strong>使用</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">arrayList.add(&quot;Element 1&quot;);</span><br><span class="line">arrayList.add(&quot;Element 2&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：适用于大多数需要动态数组的场景，特别是在需要快速访问元素的场合。</p>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p><strong>定义</strong>：<code>LinkedList</code>是一个基于双向链表实现的集合，既可以作为列表使用，也可以作为队列或双端队列使用。</p>
<p><strong>数据结构</strong>：<code>LinkedList</code>内部使用双向链表实现，每个节点都包含一个数据元素和指向前后节点的引用。</p>
<p><strong>使用</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();</span><br><span class="line">linkedList.add(&quot;Element 1&quot;);</span><br><span class="line">linkedList.add(&quot;Element 2&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：适用于需要频繁插入和删除元素的场景，例如实现队列、栈或双端队列。</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p><strong>定义</strong>：<code>LinkedList</code>是一个基于双向链表实现的集合，既可以作为列表使用，也可以作为队列或双端队列使用。</p>
<p><strong>数据结构</strong>：<code>HashSet</code>内部使用哈希表（通常是<code>HashMap</code>）实现。元素通过计算哈希值存储在不同的桶中。</p>
<p><strong>使用</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();</span><br><span class="line">linkedList.add(&quot;Element 1&quot;);</span><br><span class="line">linkedList.add(&quot;Element 2&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：适用于需要频繁插入和删除元素的场景，例如实现队列、栈或双端队列。</p>
<h6 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h6><p><strong>定义</strong>：<code>LinkedHashSet</code>继承自<code>HashSet</code>，并且内部使用链表维护插入顺序。</p>
<p><strong>数据结构</strong>：<code>LinkedHashSet</code>继承自<code>HashSet</code>，但内部使用了双向链表来维护插入顺序。</p>
<p><strong>使用</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet&lt;String&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();</span><br><span class="line">linkedHashSet.add(&quot;Element 1&quot;);</span><br><span class="line">linkedHashSet.add(&quot;Element 2&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：适用于既需要快速判断元素是否存在，又需要维护插入顺序的场景。</p>
<h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p><strong>定义</strong>：<code>TreeSet</code>是一个基于红黑树实现的集合，存储元素是有序的，不允许存储重复元素。</p>
<p><strong>数据结构</strong>：<code>TreeSet</code>内部使用红黑树（自平衡二叉搜索树）实现。</p>
<p><strong>使用</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;();</span><br><span class="line">treeSet.add(&quot;Element 1&quot;);</span><br><span class="line">treeSet.add(&quot;Element 2&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：适用于需要自动排序的集合，例如需要按自然顺序或自定义排序规则存储元素。</p>
<h3 id="Map双列集合"><a href="#Map双列集合" class="headerlink" title="Map双列集合"></a>Map双列集合</h3><h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><p><strong>定义</strong>：<code>Hashtable</code>是一个线程安全的哈希表实现，不允许存储<code>null</code>键或值。</p>
<p><strong>数据结构</strong>：<code>Hashtable</code>使用哈希表实现，不允许<code>null</code>键或值。</p>
<p><strong>使用</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hashtable&lt;String, String&gt; hashtable = new Hashtable&lt;&gt;();</span><br><span class="line">hashtable.put(&quot;Key 1&quot;, &quot;Value 1&quot;);</span><br><span class="line">hashtable.put(&quot;Key 2&quot;, &quot;Value 2&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：适用于多线程环境中需要同步的哈希表，但由于同步开销较大，通常更推荐使用<code>ConcurrentHashMap</code>。</p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p><strong>定义</strong>：<code>HashMap</code>是一个非线程安全的哈希表实现，允许存储<code>null</code>键和值。</p>
<p><strong>数据结构</strong>：<code>HashMap</code>使用哈希表实现，允许<code>null</code>键和值。</p>
<p><strong>使用</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">hashMap.put(&quot;Key 1&quot;, &quot;Value 1&quot;);</span><br><span class="line">hashMap.put(&quot;Key 2&quot;, &quot;Value 2&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：适用于大多数需要键值对存储的场景，尤其是在单线程环境中。</p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p><strong>定义</strong>：<code>ConcurrentHashMap</code>是一个线程安全的哈希表实现，支持高并发，通过分段锁机制提高性能。</p>
<p><strong>数据结构</strong>：<code>ConcurrentHashMap</code>使用分段锁机制（Java 8之前）或CAS（Java 8之后）实现，允许高并发访问。</p>
<p><strong>使用</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; concurrentHashMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">concurrentHashMap.put(&quot;Key 1&quot;, &quot;Value 1&quot;);</span><br><span class="line">concurrentHashMap.put(&quot;Key 2&quot;, &quot;Value 2&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：适用于高并发环境中需要同步的哈希表。</p>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p><strong>定义</strong>：<code>TreeMap</code>是一个基于红黑树实现的有序键值对集合，键的排序可以是自然顺序或自定义顺序。</p>
<p><strong>数据结构</strong>：<code>TreeMap</code>使用红黑树（自平衡二叉搜索树）实现。</p>
<p><strong>使用</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;String, String&gt; treeMap = new TreeMap&lt;&gt;();</span><br><span class="line">treeMap.put(&quot;Key 1&quot;, &quot;Value 1&quot;);</span><br><span class="line">treeMap.put(&quot;Key 2&quot;, &quot;Value 2&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：适用于需要自动排序键值对的场景，例如按字母顺序或自定义排序规则存储键值对。</p>
<h2 id="并发编程篇"><a href="#并发编程篇" class="headerlink" title="并发编程篇"></a>并发编程篇</h2><h3 id="线程的基础知识"><a href="#线程的基础知识" class="headerlink" title="线程的基础知识"></a>线程的基础知识</h3><h4 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h4><ul>
<li><strong>进程</strong>：操作系统分配资源的基本单位，每个进程都有独立的内存空间、文件描述符和其他资源。</li>
<li><strong>线程</strong>：进程中的一个执行单元，共享进程的内存空间和资源，但有自己的栈空间和寄存器。</li>
</ul>
<p><strong>区别</strong>：</p>
<ol>
<li>进程间相互独立，线程共享进程的资源。</li>
<li>进程切换开销大，线程切换开销小。</li>
<li>进程有独立的地址空间，线程共享地址空间。</li>
</ol>
<h4 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h4><p><strong>并发</strong>：在一个处理器上，多个任务通过时间分片快速切换，使得宏观上看起来是同时进行的。</p>
<p><strong>并行</strong>：在多个处理器上，多个任务同时进行，是真正意义上的同时执行。</p>
<h4 id="创建线程的方式有哪些"><a href="#创建线程的方式有哪些" class="headerlink" title="创建线程的方式有哪些"></a>创建线程的方式有哪些</h4><p><strong>继承<code>Thread</code>类</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Thread is running&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyThread thread = new MyThread();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p><strong>实现<code>Runnable</code>接口</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Thread is running&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread thread = new Thread(new MyRunnable());</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p><strong>实现<code>Callable</code>接口</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">public class MyCallable implements Callable&lt;String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String call() &#123;</span><br><span class="line">        return &quot;Thread is running&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(new MyCallable());</span><br><span class="line">Thread thread = new Thread(task);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p><strong>线程池</strong></p>
<p>创建线程池可以使用<code>java.util.concurrent.Executors</code>工厂类提供的静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建固定大小的线程池，包含5个线程</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务给线程池执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> <span class="title class_">Task</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> taskId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(<span class="type">int</span> taskId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskId = taskId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running on thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个示例中，首先通过<code>Executors.newFixedThreadPool(5)</code>方法创建一个固定大小为5的线程池。然后，通过循环提交了10个任务给线程池执行，每个任务都是一个实现了<code>Runnable</code>接口的<code>Task</code>对象。最后，调用<code>executor.shutdown()</code>方法关闭线程池。</p>
<p>这样，线程池就会自动管理这些任务的执行，使用线程池可以避免频繁地创建和销毁线程，提高了程序的性能和效率。</p>
<h4 id="runnable和callable有什么区别"><a href="#runnable和callable有什么区别" class="headerlink" title="runnable和callable有什么区别"></a>runnable和callable有什么区别</h4><p><strong>Runnable</strong>：不返回结果，不能抛出检查异常。</p>
<p><strong>Callable</strong>：有返回结果，可以抛出检查异常。</p>
<h4 id="线程包括哪些状态，状态之间是如何变化的"><a href="#线程包括哪些状态，状态之间是如何变化的" class="headerlink" title="线程包括哪些状态，状态之间是如何变化的"></a>线程包括哪些状态，状态之间是如何变化的</h4><p><strong>NEW</strong>：新建状态，线程被创建但未启动。</p>
<p><strong>RUNNABLE</strong>：可运行状态，线程正在运行或等待资源。</p>
<p><strong>BLOCKED</strong>：阻塞状态，等待获取锁。</p>
<p><strong>WAITING</strong>：等待状态，等待另一个线程的通知或唤醒。</p>
<p><strong>TIMED_WAITING</strong>：计时等待状态，等待指定时间后被唤醒。</p>
<p><strong>TERMINATED</strong>：终止状态，线程已结束。</p>
<p><strong>状态变化</strong>：</p>
<ul>
<li><code>NEW</code> -&gt; <code>RUNNABLE</code>：调用<code>start()</code>方法。</li>
<li><code>RUNNABLE</code> -&gt; <code>BLOCKED</code>：等待获取锁。</li>
<li><code>RUNNABLE</code> -&gt; <code>WAITING</code>：调用<code>wait()</code>、<code>join()</code>或<code>LockSupport.park()</code>。</li>
<li><code>RUNNABLE</code> -&gt; <code>TIMED_WAITING</code>：调用<code>sleep()</code>、<code>wait(timeout)</code>、<code>join(timeout)</code>或<code>LockSupport.parkNanos()</code>。</li>
<li><code>RUNNABLE</code> -&gt; <code>TERMINATED</code>：线程执行完毕或抛出异常。</li>
</ul>
<h4 id="在java中wait和sleep方法的不同"><a href="#在java中wait和sleep方法的不同" class="headerlink" title="在java中wait和sleep方法的不同"></a>在java中wait和sleep方法的不同</h4><p>**<code>wait</code>**：用于线程间通信，释放锁，必须在同步块或同步方法中调用。</p>
<p>**<code>sleep</code>**：用于暂停当前线程，不释放锁，可以在任何地方调用。</p>
<h4 id="新建三个线程，如何保证它们按顺序执行"><a href="#新建三个线程，如何保证它们按顺序执行" class="headerlink" title="新建三个线程，如何保证它们按顺序执行"></a>新建三个线程，如何保证它们按顺序执行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderedThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread previousThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderedThread</span><span class="params">(Thread previousThread)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.previousThread = previousThread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (previousThread != <span class="literal">null</span>) &#123;</span><br><span class="line">                previousThread.join();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderedThread</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderedThread</span>(t1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderedThread</span>(t2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="notify-和notifyAll-有什么区别"><a href="#notify-和notifyAll-有什么区别" class="headerlink" title="notify()和notifyAll()有什么区别"></a>notify()和notifyAll()有什么区别</h4><p>**<code>notify()</code>**：唤醒一个等待该对象监视器的线程。</p>
<p>**<code>notifyAll()</code>**：唤醒所有等待该对象监视器的线程。</p>
<h4 id="线程的run-和start-有什么区别"><a href="#线程的run-和start-有什么区别" class="headerlink" title="线程的run()和start()有什么区别"></a>线程的run()和start()有什么区别</h4><p>**<code>notify()</code>**：唤醒一个等待该对象监视器的线程。</p>
<p>**<code>notifyAll()</code>**：唤醒所有等待该对象监视器的线程。</p>
<h4 id="如何停止一个正在运行的战程"><a href="#如何停止一个正在运行的战程" class="headerlink" title="如何停止一个正在运行的战程"></a>如何停止一个正在运行的战程</h4><p><strong>使用标志位</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    private volatile boolean running = true;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (running) &#123;</span><br><span class="line">            // 执行任务</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void stopThread() &#123;</span><br><span class="line">        running = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用中断</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            // 执行任务</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyThread thread = new MyThread();</span><br><span class="line">thread.start();</span><br><span class="line">thread.interrupt();</span><br></pre></td></tr></table></figure>

<h3 id="线程中的并发安全"><a href="#线程中的并发安全" class="headerlink" title="线程中的并发安全"></a>线程中的并发安全</h3><h4 id="synchronized关键字的底展原理"><a href="#synchronized关键字的底展原理" class="headerlink" title="synchronized关键字的底展原理"></a>synchronized关键字的底展原理</h4><p><strong>Monitor</strong>：每个对象都有一个监视器锁，<code>synchronized</code>块或方法会获取对象的监视器锁。</p>
<p><strong>JVM指令</strong>：</p>
<ul>
<li><code>synchronized</code>方法：使用<code>ACC_SYNCHRONIZED</code>标记方法。</li>
<li><code>synchronized</code>块：使用<code>monitorenter</code>和<code>monitorexit</code>指令。</li>
</ul>
<h4 id="你谈谈JMM-Java-内存模型"><a href="#你谈谈JMM-Java-内存模型" class="headerlink" title="你谈谈JMM (Java 内存模型)"></a>你谈谈JMM (Java 内存模型)</h4><p>Java 内存模型（Java Memory Model, JMM）规定了线程如何与内存交互，保证内存的可见性和有序性。JMM提供了以下保证：</p>
<ol>
<li><strong>可见性</strong>：一个线程对变量的修改对其他线程可见，使用<code>volatile</code>、<code>synchronized</code>和显式锁来保证。</li>
<li><strong>有序性</strong>：保证指令执行的顺序，使用<code>volatile</code>和<code>synchronized</code>来保证。</li>
<li><strong>原子性</strong>：基本操作（如读写变量）是原子的。</li>
</ol>
<h4 id="CAS你知道吗"><a href="#CAS你知道吗" class="headerlink" title="CAS你知道吗"></a>CAS你知道吗</h4><p>CAS（Compare-And-Swap）是一种无锁算法，用于实现原子操作。CAS操作包括三个操作数：内存位置（V）、预期值（A）和新值（B），只有当V的值等于A时，才会将V的值更新为B。</p>
<h4 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h4><p>AQS（AbstractQueuedSynchronizer）是一个用于构建锁和同步器的框架，它通过一个FIFO队列实现线程的排队，并通过状态值（state）控制线程的访问。</p>
<h4 id="ReentrantLock的实现原理"><a href="#ReentrantLock的实现原理" class="headerlink" title="ReentrantLock的实现原理"></a>ReentrantLock的实现原理</h4><p><code>ReentrantLock</code>是基于AQS实现的可重入锁，通过CAS操作和AQS的状态值来实现锁的获取和释放。<code>ReentrantLock</code>有两种模式：</p>
<ol>
<li><strong>公平锁</strong>：先来先得。</li>
<li><strong>非公平锁</strong>：可能导致后来的线程先获取锁。</li>
</ol>
<h4 id="synchronized和Lock有什么区别"><a href="#synchronized和Lock有什么区别" class="headerlink" title="synchronized和Lock有什么区别"></a>synchronized和Lock有什么区别</h4><p>**<code>synchronized</code>**：JVM层面的同步机制，自动释放锁，性能较低。</p>
<p>**<code>Lock</code>**：Java层面的同步机制，需要手动释放锁，提供更多功能（如公平锁、可中断锁）。</p>
<h4 id="死锁产生的条件是什么"><a href="#死锁产生的条件是什么" class="headerlink" title="死锁产生的条件是什么"></a>死锁产生的条件是什么</h4><p><strong>互斥</strong>：一个资源每次只能被一个线程占用。</p>
<p><strong>占有并等待</strong>：一个线程占有资源的同时，等待其他资源。</p>
<p><strong>不可剥夺</strong>：线程占有的资源在未使用完之前不能被强制剥夺。</p>
<p><strong>循环等待</strong>：存在一个线程循环等待的资源链。</p>
<h4 id="如何进行死锁诊断"><a href="#如何进行死锁诊断" class="headerlink" title="如何进行死锁诊断"></a>如何进行死锁诊断</h4><p><strong>线程转储（Thread Dump）</strong>：分析线程转储信息，寻找死锁。</p>
<p><strong>死锁检测工具</strong>：使用JDK自带的工具（如jconsole、jstack）或第三方工具（如VisualVM）。</p>
<h4 id="请谈谈你对volatile的理解"><a href="#请谈谈你对volatile的理解" class="headerlink" title="请谈谈你对volatile的理解"></a>请谈谈你对volatile的理解</h4><p><strong>线程转储（Thread Dump）</strong>：分析线程转储信息，寻找死锁。</p>
<p><strong>死锁检测工具</strong>：使用JDK自带的工具（如jconsole、jstack）或第三方工具（如VisualVM）。</p>
<h4 id="聊一下ConcurrentHashMap"><a href="#聊一下ConcurrentHashMap" class="headerlink" title="聊一下ConcurrentHashMap"></a>聊一下ConcurrentHashMap</h4><p><code>ConcurrentHashMap</code>是一个线程安全的哈希表，通过分段锁机制或CAS操作提高并发性能。每个桶（Java 8之前）或每个节点（Java 8之后）独立加锁，减少锁竞争。</p>
<h4 id="导致井发程序出现问题的根本原因是什么"><a href="#导致井发程序出现问题的根本原因是什么" class="headerlink" title="导致井发程序出现问题的根本原因是什么"></a>导致井发程序出现问题的根本原因是什么</h4><p><strong>共享状态</strong>：多个线程同时读写共享变量，可能导致数据不一致。</p>
<p><strong>缺乏同步</strong>：没有适当地同步访问共享资源，导致竞态条件。</p>
<p><strong>可见性问题</strong>：一个线程对变量的修改，其他线程不可见。</p>
<p><strong>原子性问题</strong>：复合操作（如i++）在多线程环境下不是原子的，可能导致数据错误。</p>
<p><strong>指令重排序</strong>：编译器和处理器优化可能导致指令执行顺序与预期不同，破坏线程间的协作。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="说一下线程池的核心参数-线程池的执行原理知道嘛"><a href="#说一下线程池的核心参数-线程池的执行原理知道嘛" class="headerlink" title="说一下线程池的核心参数(线程池的执行原理知道嘛)"></a>说一下线程池的核心参数(线程池的执行原理知道嘛)</h4><ol>
<li><strong>corePoolSize</strong>：核心线程数，线程池维护的最小线程数。</li>
<li><strong>maximumPoolSize</strong>：最大线程数，线程池能创建的最大线程数。</li>
<li><strong>keepAliveTime</strong>：线程空闲时间，当线程数超过核心线程数时，多余的线程在此时间后被终止。</li>
<li><strong>unit</strong>：keepAliveTime的时间单位。</li>
<li><strong>workQueue</strong>：任务队列，用于存储等待执行的任务。</li>
<li><strong>threadFactory</strong>：线程工厂，用于创建新线程。</li>
<li><strong>handler</strong>：拒绝策略，当任务无法提交到线程池时的处理方式。</li>
</ol>
<p>线程池的执行原理：</p>
<ol>
<li>当提交任务时，如果线程数小于corePoolSize，创建新线程执行任务。</li>
<li>如果线程数达到corePoolSize，任务进入队列等待。</li>
<li>如果队列满了且线程数小于maximumPoolSize，创建新线程执行任务。</li>
<li>如果队列满了且线程数达到maximumPoolSize，执行拒绝策略。</li>
</ol>
<h4 id="线程池中有哪些常见的阻塞队列"><a href="#线程池中有哪些常见的阻塞队列" class="headerlink" title="线程池中有哪些常见的阻塞队列"></a>线程池中有哪些常见的阻塞队列</h4><p><strong>ArrayBlockingQueue</strong>：有界阻塞队列，数组实现，按FIFO顺序。</p>
<p><strong>LinkedBlockingQueue</strong>：有界或无界阻塞队列，链表实现，按FIFO顺序。</p>
<p><strong>SynchronousQueue</strong>：无缓冲队列，每个插入操作必须等待对应的移除操作。</p>
<p><strong>PriorityBlockingQueue</strong>：无界优先级队列，按优先级顺序。</p>
<h4 id="如何确定核心线程数"><a href="#如何确定核心线程数" class="headerlink" title="如何确定核心线程数"></a>如何确定核心线程数</h4><p><strong>CPU密集型任务</strong>：核心线程数设置为CPU核心数，例如，使用<code>Runtime.getRuntime().availableProcessors()</code>获取CPU核心数。</p>
<p><strong>IO密集型任务</strong>：核心线程数设置为CPU核心数的2倍或更多，确保有足够的线程处理IO操作。</p>
<h4 id="线程池的种类有哪些"><a href="#线程池的种类有哪些" class="headerlink" title="线程池的种类有哪些"></a>线程池的种类有哪些</h4><p><strong>FixedThreadPool</strong>：固定大小的线程池。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);</span><br></pre></td></tr></table></figure>

<p><strong>CachedThreadPool</strong>：可缓存的线程池，适用于短时间大量任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>

<p><strong>SingleThreadExecutor</strong>：单线程的线程池，确保任务顺序执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>

<p><strong>ScheduledThreadPool</strong>：定时任务线程池。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);</span><br></pre></td></tr></table></figure>

<h4 id="为什么不建议用Executors创建线程池"><a href="#为什么不建议用Executors创建线程池" class="headerlink" title="为什么不建议用Executors创建线程池"></a>为什么不建议用Executors创建线程池</h4><p><code>Executors</code>创建的线程池有以下问题：</p>
<ol>
<li><strong>FixedThreadPool和SingleThreadExecutor</strong>：队列长度为Integer.MAX_VALUE，可能导致OOM（内存溢出）。</li>
<li><strong>CachedThreadPool和ScheduledThreadPool</strong>：线程数可能无限增长，可能导致OOM（内存溢出）。</li>
</ol>
<p>建议使用<code>ThreadPoolExecutor</code>的构造方法，自定义线程池参数，避免上述问题。</p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="线程池使用场景-你们项目中哪里用到了线程池）"><a href="#线程池使用场景-你们项目中哪里用到了线程池）" class="headerlink" title="线程池使用场景(你们项目中哪里用到了线程池）"></a>线程池使用场景(你们项目中哪里用到了线程池）</h4><p><strong>Web服务器</strong>：处理客户端请求。</p>
<p><strong>异步任务处理</strong>：后台任务处理，如日志记录、数据同步。</p>
<p><strong>定时任务</strong>：定时执行任务，如定时备份、定时清理。</p>
<p>项目中的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeTask</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        executorService.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExample</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            example.executeTask(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is executing task.&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        example.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="如何控制某个方法允许并发访问线程的数量"><a href="#如何控制某个方法允许并发访问线程的数量" class="headerlink" title="如何控制某个方法允许并发访问线程的数量"></a>如何控制某个方法允许并发访问线程的数量</h4><p>可以使用信号量（<code>Semaphore</code>）来限制并发访问线程的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">public class SemaphoreExample &#123;</span><br><span class="line">    private final Semaphore semaphore = new Semaphore(3);</span><br><span class="line"></span><br><span class="line">    public void limitedAccessMethod() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            // 执行任务</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; is executing.&quot;);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SemaphoreExample example = new SemaphoreExample();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(example::limitedAccessMethod).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="谈谈-你对ThreadLocal的理解"><a href="#谈谈-你对ThreadLocal的理解" class="headerlink" title="谈谈 你对ThreadLocal的理解"></a>谈谈 你对ThreadLocal的理解</h4><p><code>ThreadLocal</code>提供了线程本地变量，每个线程访问该变量时都有独立的副本，互不影响，适用于需要隔离线程间共享数据的场景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalExample &#123;</span><br><span class="line">    private static final ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; 1);</span><br><span class="line"></span><br><span class="line">    public void increment() &#123;</span><br><span class="line">        threadLocal.set(threadLocal.get() + 1);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; : &quot; + threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadLocalExample example = new ThreadLocalExample();</span><br><span class="line"></span><br><span class="line">        Runnable task = () -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                example.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = new Thread(task);</span><br><span class="line">        Thread thread2 = new Thread(task);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><h3 id="JVM-概述"><a href="#JVM-概述" class="headerlink" title="JVM 概述"></a>JVM 概述</h3><p>JVM（Java Virtual Machine）是Java程序执行的基础，它提供了一个运行时环境，用于执行Java字节码。JVM将Java代码转换为机器指令，使Java程序能够在不同的平台上运行，实现“一次编写，到处运行”。</p>
<h3 id="JVM-构成"><a href="#JVM-构成" class="headerlink" title="JVM 构成"></a>JVM 构成</h3><ol>
<li><strong>类加载器（Class Loader）</strong>：负责将Java字节码加载到JVM中。</li>
<li><strong>运行时数据区（Runtime Data Areas）</strong>：JVM在运行Java程序时管理的内存区域。</li>
<li><strong>执行引擎（Execution Engine）</strong>：负责执行字节码，包括解释器和即时编译器（JIT）。</li>
<li><strong>本地接口（Native Interface）</strong>：用于与本地方法库（如C&#x2F;C++）交互。</li>
</ol>
<h3 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h3><p>JVM将其内存划分为若干区域，每个区域用于不同的用途：</p>
<ol>
<li><strong>堆（Heap）</strong>：<ul>
<li>存储所有的对象实例和数组。</li>
<li>分为新生代和老年代。</li>
<li>新生代又分为Eden区和两个Survivor区。</li>
</ul>
</li>
<li><strong>方法区（Method Area）</strong>：<ul>
<li>存储已加载的类信息、常量、静态变量和即时编译器编译后的代码。</li>
<li>在JDK 8之前称为永久代（Permanent Generation），在JDK 8之后称为元空间（Metaspace）。</li>
</ul>
</li>
<li><strong>虚拟机栈（JVM Stack）</strong>：<ul>
<li>每个线程都有一个虚拟机栈，存储方法调用的局部变量、操作数栈、动态链接和方法出口。</li>
<li>每个方法调用对应一个栈帧。</li>
</ul>
</li>
<li><strong>本地方法栈（Native Method Stack）</strong>：<ul>
<li>与虚拟机栈类似，但用于存储本地方法调用。</li>
</ul>
</li>
<li><strong>程序计数器（Program Counter Register）</strong>：<ul>
<li>当前线程所执行字节码的行号指示器。</li>
<li>如果执行的是本地方法，则这个计数器值为未指定（undefined）。</li>
</ul>
</li>
</ol>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>类加载过程包括以下几个步骤：</p>
<ol>
<li><strong>加载（Loading）</strong>：<ul>
<li>将类的二进制数据读入内存，生成Class对象。</li>
</ul>
</li>
<li><strong>验证（Verification）</strong>：<ul>
<li>确保字节码符合JVM规范，没有安全问题。</li>
</ul>
</li>
<li><strong>准备（Preparation）</strong>：<ul>
<li>为类的静态变量分配内存，并将其初始化为默认值。</li>
</ul>
</li>
<li><strong>解析（Resolution）</strong>：<ul>
<li>将符号引用转为直接引用。</li>
</ul>
</li>
<li><strong>初始化（Initialization）</strong>：<ul>
<li>执行类构造器<clinit>()方法，初始化静态变量和静态代码块。</li>
</ul>
</li>
</ol>
<h3 id="垃圾收集（Garbage-Collection）"><a href="#垃圾收集（Garbage-Collection）" class="headerlink" title="垃圾收集（Garbage Collection）"></a>垃圾收集（Garbage Collection）</h3><p>JVM使用垃圾收集机制自动管理内存，释放不再使用的对象。常见的垃圾收集算法包括：</p>
<ol>
<li><strong>标记-清除（Mark-Sweep）</strong>：<ul>
<li>标记所有可达对象，清除所有未标记的对象。</li>
</ul>
</li>
<li><strong>复制算法（Copying）</strong>：<ul>
<li>将存活的对象从一块内存复制到另一块内存，适用于新生代。</li>
</ul>
</li>
<li><strong>标记-整理（Mark-Compact）</strong>：<ul>
<li>标记所有可达对象，然后将存活的对象整理到内存一端，适用于老年代。</li>
</ul>
</li>
<li><strong>分代收集（Generational Collection）</strong>：<ul>
<li>根据对象的存活时间将堆分为新生代和老年代，分别使用不同的算法。</li>
</ul>
</li>
</ol>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>不同的垃圾收集器适用于不同的应用场景：</p>
<ol>
<li><strong>Serial GC</strong>：单线程，适用于客户端应用。</li>
<li><strong>Parallel GC（Throughput Collector）</strong>：多线程，适用于多核服务器。</li>
<li><strong>CMS GC（Concurrent Mark-Sweep）</strong>：并发收集，适用于低停顿需求的应用。</li>
<li><strong>G1 GC（Garbage-First）</strong>：适用于大内存、低停顿需求的应用。</li>
</ol>
<h3 id="JVM-参数调优"><a href="#JVM-参数调优" class="headerlink" title="JVM 参数调优"></a>JVM 参数调优</h3><p>通过调整JVM参数，可以优化Java应用的性能。常用的JVM参数包括：</p>
<ol>
<li><strong>堆内存设置</strong>：<ul>
<li><code>-Xms</code>：设置堆的初始大小。</li>
<li><code>-Xmx</code>：设置堆的最大大小。</li>
</ul>
</li>
<li><strong>新生代内存设置</strong>：<ul>
<li><code>-Xmn</code>：设置新生代的大小。</li>
<li><code>-XX:NewRatio</code>：设置新生代与老年代的比例。</li>
</ul>
</li>
<li><strong>垃圾收集器设置</strong>：<ul>
<li><code>-XX:+UseSerialGC</code>：使用Serial垃圾收集器。</li>
<li><code>-XX:+UseParallelGC</code>：使用Parallel垃圾收集器。</li>
<li><code>-XX:+UseConcMarkSweepGC</code>：使用CMS垃圾收集器。</li>
<li><code>-XX:+UseG1GC</code>：使用G1垃圾收集器。</li>
</ul>
</li>
<li><strong>其他常用参数</strong>：<ul>
<li><code>-XX:SurvivorRatio</code>：设置Eden区与Survivor区的比例。</li>
<li><code>-XX:MaxTenuringThreshold</code>：设置对象在新生代的最大年龄。</li>
<li><code>-XX:+PrintGCDetails</code>：打印GC详细日志。</li>
<li><code>-XX:+HeapDumpOnOutOfMemoryError</code>：在OOM时生成堆转储。</li>
</ul>
</li>
</ol>
<h3 id="性能监控工具"><a href="#性能监控工具" class="headerlink" title="性能监控工具"></a>性能监控工具</h3><ol>
<li><strong>JVisualVM</strong>：Java虚拟机监视和性能分析工具。</li>
<li><strong>JConsole</strong>：Java监视和管理控制台。</li>
<li><strong>GC日志</strong>：通过参数配置，分析GC行为和性能。</li>
<li><strong>Java Mission Control（JMC）</strong>：性能监控和分析工具。</li>
</ol>
<h3 id="类加载器机制"><a href="#类加载器机制" class="headerlink" title="类加载器机制"></a>类加载器机制</h3><p>JVM使用类加载器来动态加载类。类加载器有以下几种类型：</p>
<ol>
<li><strong>Bootstrap ClassLoader</strong>：引导类加载器，加载核心类库（如rt.jar）。</li>
<li><strong>Extension ClassLoader</strong>：扩展类加载器，加载扩展类库（如lib&#x2F;ext目录下的类）。</li>
<li><strong>Application ClassLoader</strong>：应用类加载器，加载用户类路径上的类。</li>
</ol>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>双亲委派模型是一种类加载机制，类加载请求首先委派给父加载器处理，只有在父加载器无法完成加载任务时，子加载器才会尝试加载。这种机制避免了类的重复加载。</p>
<h3 id="JIT-编译与-AOT-编译"><a href="#JIT-编译与-AOT-编译" class="headerlink" title="JIT 编译与 AOT 编译"></a>JIT 编译与 AOT 编译</h3><ol>
<li><strong>JIT编译</strong>：即时编译，将热点代码（频繁执行的代码）编译为本地机器码，提升运行时性能。</li>
<li><strong>AOT编译</strong>：提前编译，将字节码在程序运行之前编译为本地代码，缩短启动时间。</li>
</ol>
<h3 id="常见问题及面试题"><a href="#常见问题及面试题" class="headerlink" title="常见问题及面试题"></a>常见问题及面试题</h3><ol>
<li><strong>JVM的内存模型包含哪些区域？</strong><ul>
<li>堆、方法区、虚拟机栈、本地方法栈、程序计数器。</li>
</ul>
</li>
<li><strong>类加载的过程是怎样的？</strong><ul>
<li>加载、验证、准备、解析、初始化。</li>
</ul>
</li>
<li><strong>什么是双亲委派模型？如何打破双亲委派？</strong><ul>
<li>双亲委派模型是类加载请求先委派给父加载器处理。可以通过自定义类加载器打破双亲委派。</li>
</ul>
</li>
<li><strong>描述几种垃圾收集器及其适用场景。</strong><ul>
<li>Serial GC、Parallel GC、CMS GC、G1 GC，各有适用的场景，如低停顿、低延迟、吞吐量需求等。</li>
</ul>
</li>
<li><strong>如何通过JVM参数调整内存设置？</strong><ul>
<li>使用<code>-Xms</code>、<code>-Xmx</code>设置堆内存，<code>-Xmn</code>设置新生代大小等。</li>
</ul>
</li>
<li><strong>你遇到过内存泄漏吗？如何排查和解决？</strong><ul>
<li>使用工具如MAT分析堆转储，找出长时间占用内存的对象。</li>
</ul>
</li>
<li><strong>什么是GC停顿？如何减少GC停顿？</strong><ul>
<li>GC停顿是垃圾收集导致的应用暂停时间。可以通过选择合适的垃圾收集器和参数调优来减少。</li>
</ul>
</li>
<li><strong>如何选择合适的垃圾收集器？</strong><ul>
<li>根据应用的响应时间需求、吞吐量需求和内存大小选择合适的垃圾收集器。</li>
</ul>
</li>
<li><strong>解释一下什么是JIT编译？它如何提升Java应用的性能？</strong><ul>
<li>JIT编译将热点代码编译为本地机器码，减少解释执行的开销，提高性能。</li>
</ul>
</li>
<li><strong>你对G1垃圾收集器了解多少？它与CMS相比有哪些优势？</strong><ul>
<li>G1 GC是面向大内存、低停顿的垃圾收集器，能更好地控制GC停顿时间，避免CMS的碎片问题。</li>
</ul>
</li>
</ol>
<h2 id="企业场景篇-3-5"><a href="#企业场景篇-3-5" class="headerlink" title="企业场景篇(3.5)"></a>企业场景篇(3.5)</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h4><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>简单工厂模式是一种创建型设计模式，它通过一个工厂类来创建不同类型的对象，而不需要在客户端直接实例化这些对象。</p>
<p><strong>解释</strong>：</p>
<p>在简单工厂模式中，客户端只需要提供给工厂类一个参数，工厂类根据这个参数的不同来创建不同的对象，并将创建的对象返回给客户端。</p>
<p><strong>Java 代码示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 抽象产品类</span><br><span class="line">interface Product &#123;</span><br><span class="line">    void operation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品类A</span><br><span class="line">class ConcreteProductA implements Product &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        System.out.println(&quot;Product A operation.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品类B</span><br><span class="line">class ConcreteProductB implements Product &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        System.out.println(&quot;Product B operation.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 简单工厂类</span><br><span class="line">class SimpleFactory &#123;</span><br><span class="line">    public static Product createProduct(String type) &#123;</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">            case &quot;A&quot;:</span><br><span class="line">                return new ConcreteProductA();</span><br><span class="line">            case &quot;B&quot;:</span><br><span class="line">                return new ConcreteProductB();</span><br><span class="line">            default:</span><br><span class="line">                throw new IllegalArgumentException(&quot;Invalid product type: &quot; + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Product productA = SimpleFactory.createProduct(&quot;A&quot;);</span><br><span class="line">        productA.operation(); // Output: Product A operation.</span><br><span class="line"></span><br><span class="line">        Product productB = SimpleFactory.createProduct(&quot;B&quot;);</span><br><span class="line">        productB.operation(); // Output: Product B operation.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong>：</p>
<ol>
<li>当需要根据输入参数来决定创建哪个对象时，可以使用简单工厂模式。</li>
<li>当需要将对象的创建与对象的使用分离时，可以使用简单工厂模式。</li>
<li>当创建的对象较少且不会频繁变动时，可以使用简单工厂模式。</li>
</ol>
<h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>工厂方法模式是一种创建型设计模式，它定义了一个用于创建对象的接口，但由子类决定要实例化的类是哪一个。</p>
<p><strong>解释</strong>：</p>
<p>工厂方法模式通过定义一个抽象的工厂接口和多个具体的工厂类来实现。每个具体的工厂类负责创建一种具体的产品对象。</p>
<p><strong>Java 代码示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// 抽象产品类</span><br><span class="line">interface Product &#123;</span><br><span class="line">    void operation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品类A</span><br><span class="line">class ConcreteProductA implements Product &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        System.out.println(&quot;Product A operation.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品类B</span><br><span class="line">class ConcreteProductB implements Product &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        System.out.println(&quot;Product B operation.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象工厂接口</span><br><span class="line">interface Factory &#123;</span><br><span class="line">    Product createProduct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体工厂类A</span><br><span class="line">class ConcreteFactoryA implements Factory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product createProduct() &#123;</span><br><span class="line">        return new ConcreteProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体工厂类B</span><br><span class="line">class ConcreteFactoryB implements Factory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product createProduct() &#123;</span><br><span class="line">        return new ConcreteProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Factory factoryA = new ConcreteFactoryA();</span><br><span class="line">        Product productA = factoryA.createProduct();</span><br><span class="line">        productA.operation(); // Output: Product A operation.</span><br><span class="line"></span><br><span class="line">        Factory factoryB = new ConcreteFactoryB();</span><br><span class="line">        Product productB = factoryB.createProduct();</span><br><span class="line">        productB.operation(); // Output: Product B operation.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong>：</p>
<ol>
<li>当需要根据不同的条件来创建不同类型的对象时，可以使用工厂方法模式。</li>
<li>当需要将对象的创建延迟到子类时，可以使用工厂方法模式。</li>
<li>当需要解耦对象的创建和使用时，可以使用工厂方法模式。</li>
</ol>
<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>抽象工厂模式是一种创建型设计模式，它提供一个接口来创建一系列相关或依赖对象的家族，而不需要指定具体的类。</p>
<p><strong>解释</strong>：</p>
<p>抽象工厂模式通过定义一个抽象工厂接口和多个具体工厂类来实现。每个具体工厂类负责创建一组相关的产品对象。</p>
<p><strong>Java 代码示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 抽象产品A</span><br><span class="line">interface ProductA &#123;</span><br><span class="line">    void operationA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品A1</span><br><span class="line">class ConcreteProductA1 implements ProductA &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operationA() &#123;</span><br><span class="line">        System.out.println(&quot;Product A1 operation.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品A2</span><br><span class="line">class ConcreteProductA2 implements ProductA &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operationA() &#123;</span><br><span class="line">        System.out.println(&quot;Product A2 operation.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象产品B</span><br><span class="line">interface ProductB &#123;</span><br><span class="line">    void operationB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品B1</span><br><span class="line">class ConcreteProductB1 implements ProductB &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operationB() &#123;</span><br><span class="line">        System.out.println(&quot;Product B1 operation.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体</span><br></pre></td></tr></table></figure>

<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p><strong>解释</strong></p>
<p>策略模式是一种行为设计模式，它定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，而不影响客户端的使用。</p>
<p>策略模式通过定义一个抽象策略接口和多个具体策略类来实现。每个具体策略类都实现了抽象策略接口中定义的算法，客户端根据需要选择不同的策略来执行相应的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象策略接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing strategy A.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing strategy B.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Strategy</span> <span class="variable">strategyA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>();</span><br><span class="line">        <span class="type">Context</span> <span class="variable">contextA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(strategyA);</span><br><span class="line">        contextA.executeStrategy(); <span class="comment">// Output: Executing strategy A.</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Strategy</span> <span class="variable">strategyB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>();</span><br><span class="line">        <span class="type">Context</span> <span class="variable">contextB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(strategyB);</span><br><span class="line">        contextB.executeStrategy(); <span class="comment">// Output: Executing strategy B.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p><strong>解释</strong>： 责任链模式是一种行为设计模式，它允许将请求沿着处理者链进行传递，直到有一个处理者能够处理该请求为止。</p>
<p>责任链模式通过将多个处理者对象链接在一起形成一条链，然后将请求在链上传递，直到某个处理者能够处理该请求。每个处理者对象都包含一个对下一个处理者对象的引用。</p>
<p><strong>Java 代码示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 请求类</span><br><span class="line">class Request &#123;</span><br><span class="line">    private int value;</span><br><span class="line"></span><br><span class="line">    public Request(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象处理者类</span><br><span class="line">abstract class Handler &#123;</span><br><span class="line">    protected Handler successor;</span><br><span class="line"></span><br><span class="line">    public void setSuccessor(Handler successor) &#123;</span><br><span class="line">        this.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void handleRequest(Request request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体处理者类A</span><br><span class="line">class ConcreteHandlerA extends Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleRequest(Request request) &#123;</span><br><span class="line">        if (request.getValue() &lt; 10) &#123;</span><br><span class="line">            System.out.println(&quot;Request handled by ConcreteHandlerA.&quot;);</span><br><span class="line">        &#125; else if (successor != null) &#123;</span><br><span class="line">            successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体处理者类B</span><br><span class="line">class ConcreteHandlerB extends Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleRequest(Request request) &#123;</span><br><span class="line">        if (request.getValue() &gt;= 10 &amp;&amp; request.getValue() &lt; 20) &#123;</span><br><span class="line">            System.out.println(&quot;Request handled by ConcreteHandlerB.&quot;);</span><br><span class="line">        &#125; else if (successor != null) &#123;</span><br><span class="line">            successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体处理者类C</span><br><span class="line">class ConcreteHandlerC extends</span><br></pre></td></tr></table></figure>

<h3 id="技术场景1"><a href="#技术场景1" class="headerlink" title="技术场景1"></a>技术场景1</h3><h4 id="单点登录这块怎么实现"><a href="#单点登录这块怎么实现" class="headerlink" title="单点登录这块怎么实现"></a>单点登录这块怎么实现</h4><p>单点登录（SSO）是一种身份认证技术，允许用户在多个应用系统中使用单一的身份凭证（用户名和密码）登录，而不需要在每个系统中单独进行登录。以下是一种简单的SSO实现方式：</p>
<ol>
<li><strong>认证中心（Authentication Center）</strong>：创建一个独立的认证中心，用于处理用户的登录和认证操作。认证中心负责验证用户提供的身份凭证，并生成相应的令牌。</li>
<li><strong>令牌（Token）生成</strong>：在用户成功登录后，认证中心生成一个令牌，并将其返回给用户。该令牌包含有关用户身份的信息，以及访问权限等相关信息。</li>
<li><strong>令牌验证</strong>：在其他应用系统中，用户在访问受保护资源时，将令牌随请求一起发送给应用系统。应用系统接收到请求后，将令牌发送给认证中心进行验证。</li>
<li><strong>访问控制</strong>：认证中心验证令牌的有效性，并根据令牌中包含的信息来判断用户是否具有访问受保护资源的权限。如果令牌有效且用户有权限访问资源，则应用系统允许用户访问。</li>
</ol>
<p>这种方式下，用户只需要登录一次，在认证中心获得令牌后，就可以在其他应用系统中无需重新登录即可访问受保护资源。</p>
<h4 id="权限认证如何实现"><a href="#权限认证如何实现" class="headerlink" title="权限认证如何实现"></a>权限认证如何实现</h4><p>权限认证是确保用户只能访问其被授权的资源的过程。以下是一种简单的权限认证实现方式：</p>
<ol>
<li><strong>用户角色管理</strong>：在系统中定义不同的用户角色，每个角色具有不同的权限和访问控制策略。</li>
<li><strong>资源访问控制</strong>：为系统中的每个资源定义访问控制列表（ACL），明确哪些角色具有访问该资源的权限。</li>
<li><strong>登录认证</strong>：当用户登录系统时，系统对用户进行身份认证，并确定其所属的角色。</li>
<li><strong>权限验证</strong>：在用户访问受保护资源时，系统根据用户所属的角色和资源的访问控制列表，验证用户是否有权限访问该资源。</li>
<li><strong>异常处理</strong>：如果用户无权限访问资源，则系统应该返回相应的错误提示或页面，阻止用户继续访问。</li>
</ol>
<h4 id="上传数据的安全性你们如何控制"><a href="#上传数据的安全性你们如何控制" class="headerlink" title="上传数据的安全性你们如何控制"></a>上传数据的安全性你们如何控制</h4><p>数据上传的安全性控制是确保上传的数据不被篡改或者上传过程中不被窃取的措施。以下是一些常见的安全性控制措施：</p>
<ol>
<li><strong>数据加密</strong>：在数据上传之前，对数据进行加密处理，以防止数据在传输过程中被窃取。</li>
<li><strong>传输协议安全</strong>：使用安全的传输协议（如HTTPS）来传输数据，确保数据在传输过程中的机密性和完整性。</li>
<li><strong>身份验证</strong>：对上传数据的来源进行身份验证，确保上传者是合法的用户或系统。</li>
<li><strong>数据校验</strong>：在接收到上传数据后，进行数据校验和验证，以确保数据的完整性和合法性。</li>
<li><strong>访问控制</strong>：对上传的数据进行访问控制，限制只有授权的用户或系统才能访问和处理上传的数据。</li>
</ol>
<h4 id="你负责项目的时候遇到了哪些比较棘手的问题"><a href="#你负责项目的时候遇到了哪些比较棘手的问题" class="headerlink" title="你负责项目的时候遇到了哪些比较棘手的问题"></a>你负责项目的时候遇到了哪些比较棘手的问题</h4><p>在项目中可能会遇到一些棘手的问题，例如性能瓶颈、系统崩溃等。处理这些问题的一般步骤包括：</p>
<ol>
<li><strong>问题定位</strong>：首先需要分析和定位问题的根本原因，可能涉及系统日志、性能监控数据、代码审查等方式来找出问题。</li>
<li><strong>问题解决</strong>：根据问题的定位结果，采取相应的措施来解决问题，可能包括优化代码、调整系统配置、增加硬件资源等。</li>
<li><strong>测试验证</strong>：对解决方案进行测试验证，确保问题得到了有效的解决，并且不会引入新的问题。</li>
<li><strong>监控维护</strong>：持续监控系统的运行状态，确保问题不会再次出现，并及时处理系统中出现的异常情况。</li>
</ol>
<h4 id="你们怎么做压测的（性能测试的）"><a href="#你们怎么做压测的（性能测试的）" class="headerlink" title="你们怎么做压测的（性能测试的）"></a>你们怎么做压测的（性能测试的）</h4><p>在项目中进行压力测试（性能测试）是为了评估系统在不同负载条件下的性能表现，以及系统的稳定性和可靠性。以下是一些常见的压力测试步骤和方法：</p>
<ol>
<li><strong>制定测试计划</strong>：确定压力测试的目标、范围和测试用例，包括模拟用户行为、定义负载模型等。</li>
<li><strong>环境准备</strong>：搭建测试环境，包括硬件资源、网络环境、数据库等，确保测试环境与生产环境尽可能一致。</li>
<li><strong>场景设计</strong>：设计不同负载下的测试场景，包括并发用户数、请求频率、数据量等，并考虑真实场景中的业务流程。</li>
<li><strong>执行测试</strong>：根据测试计划执行压力测试，收集系统的性能数据和监控指标，如响应时间、吞吐量、错误率等。</li>
<li><strong>性能分析</strong>：分析压力测试的结果，评估系统的性能表现和瓶颈，并找出导致性能问题的原因。</li>
<li><strong>优化调整</strong>：根据性能分析的结果，对系统进行优化和调整，可能涉及代码优化、配置调整、资源扩容等。</li>
<li><strong>再次测试</strong>：对优化后的系统再次进行压力测试，验证优化效果，直到达到预期的性能目标。</li>
</ol>
<h4 id="你们项目中日志怎么采集的"><a href="#你们项目中日志怎么采集的" class="headerlink" title="你们项目中日志怎么采集的"></a>你们项目中日志怎么采集的</h4><p>在项目中，日志的采集是为了记录系统运行过程中的重要信息和异常情况，便于后续的故障排查和性能分析。常见的日志采集方式包括：</p>
<ul>
<li><strong>日志框架</strong>：使用日志框架（如Log4j、Logback）来记录系统日志，可以设置日志级别、输出格式等。</li>
<li><strong>集中管理</strong>：将日志集中存储到日志服务器或日志管理系统中，便于统一管理和检索。</li>
</ul>
<h4 id="查看日志的命令"><a href="#查看日志的命令" class="headerlink" title="查看日志的命令"></a>查看日志的命令</h4><p><strong>命令行查看</strong>：使用命令行工具（如tail、grep）实时查看日志文件，方便快速定位问题。</p>
<p><strong>日志分析工具</strong>：使用日志分析工具（如ELK Stack、Splunk）对日志进行分析和可视化展示，帮助发现潜在的问题和趋势。</p>
<h4 id="怎么快速定位系统的瓶颈"><a href="#怎么快速定位系统的瓶颈" class="headerlink" title="怎么快速定位系统的瓶颈"></a>怎么快速定位系统的瓶颈</h4><h4 id="性能监控工具-1"><a href="#性能监控工具-1" class="headerlink" title="性能监控工具"></a>性能监控工具</h4><p>使用性能监控工具（如JProfiler、VisualVM）对系统进行监控和分析，可以帮助定位系统的瓶颈和性能问题。通过监控系统的CPU、内存、网络、数据库等指标，找出系统的瓶颈所在。</p>
<h4 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h4><p>分析系统日志，查找异常情况和错误信息，可以帮助定位系统的瓶颈和问题根源。根据日志中的关键信息，进行逐步排查和定位。</p>
<h4 id="生产问题怎么排查"><a href="#生产问题怎么排查" class="headerlink" title="生产问题怎么排查"></a>生产问题怎么排查</h4><p>生产问题排查是指在生产环境中出现系统故障或异常时，对问题进行迅速定位和解决的过程。以下是一些生产问题排查的常用方法：</p>
<ol>
<li><strong>快速定位</strong>：及时响应并快速定位问题，分析问题的影响范围和紧急程度。</li>
<li><strong>日志分析</strong>：分析系统日志和异常堆栈信息，找出问题发生的原因和关键点。</li>
<li><strong>监控告警</strong>：监控系统的性能指标和运行状态，及时发现异常情况并触发告警。</li>
<li><strong>回滚操作</strong>：如果可能，可以考虑回滚到稳定的版本或配置，暂时解决问题。</li>
<li><strong>紧急修复</strong>：针对问题迅速采取紧急修复措施，尽可能减少故障对业务的影响。</li>
<li><strong>持续跟踪</strong>：持续跟踪问题的解决过程和效果，确保问题得到彻底解决，避免类似问题再次发生。</li>
</ol>
<h3 id="技术场景2"><a href="#技术场景2" class="headerlink" title="技术场景2"></a>技术场景2</h3><h4 id="1-用户认证和授权"><a href="#1-用户认证和授权" class="headerlink" title="1. 用户认证和授权"></a>1. 用户认证和授权</h4><h4 id="场景问题"><a href="#场景问题" class="headerlink" title="场景问题"></a>场景问题</h4><p>实现用户登录、注册、角色管理和权限控制。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用Spring Security结合JWT实现用户认证和授权。</p>
<h4 id="实现业务逻辑"><a href="#实现业务逻辑" class="headerlink" title="实现业务逻辑"></a>实现业务逻辑</h4><p><strong>添加依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>安全配置类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line">import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line">import org.springframework.security.core.userdetails.User;</span><br><span class="line">import org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line">import org.springframework.security.provisioning.InMemoryUserDetailsManager;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Override</span><br><span class="line">    protected UserDetailsService userDetailsService() &#123;</span><br><span class="line">        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();</span><br><span class="line">        manager.createUser(User.withUsername(&quot;user&quot;).password(&quot;&#123;noop&#125;password&quot;).roles(&quot;USER&quot;).build());</span><br><span class="line">        manager.createUser(User.withUsername(&quot;admin&quot;).password(&quot;&#123;noop&#125;password&quot;).roles(&quot;ADMIN&quot;).build());</span><br><span class="line">        return manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)</span><br><span class="line">            .antMatchers(&quot;/user/**&quot;).hasRole(&quot;USER&quot;)</span><br><span class="line">            .antMatchers(&quot;/public/**&quot;).permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JWT 工具类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import io.jsonwebtoken.Jwts;</span><br><span class="line">import io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class JwtUtil &#123;</span><br><span class="line">    private static final String SECRET_KEY = &quot;secret&quot;;</span><br><span class="line"></span><br><span class="line">    public static String generateToken(String username) &#123;</span><br><span class="line">        return Jwts.builder()</span><br><span class="line">                .setSubject(username)</span><br><span class="line">                .setIssuedAt(new Date())</span><br><span class="line">                .setExpiration(new Date(System.currentTimeMillis() + 86400000)) // 1 day expiration</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, SECRET_KEY)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String extractUsername(String token) &#123;</span><br><span class="line">        return Jwts.parser()</span><br><span class="line">                .setSigningKey(SECRET_KEY)</span><br><span class="line">                .parseClaimsJws(token)</span><br><span class="line">                .getBody()</span><br><span class="line">                .getSubject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-日志管理"><a href="#2-日志管理" class="headerlink" title="2. 日志管理"></a>2. 日志管理</h4><h4 id="场景问题-1"><a href="#场景问题-1" class="headerlink" title="场景问题"></a>场景问题</h4><p>记录和管理日志信息，包括请求日志、错误日志和操作日志。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用SLF4J和Logback进行日志记录和管理。</p>
<h4 id="实现业务逻辑-1"><a href="#实现业务逻辑-1" class="headerlink" title="实现业务逻辑"></a>实现业务逻辑</h4><p><strong>添加依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>logback-spring.xml 配置文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;file&gt;logs/app.log&lt;/file&gt;</span><br><span class="line">        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;logs/app-%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;maxHistory&gt;30&lt;/maxHistory&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;root level=&quot;INFO&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;FILE&quot;/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p><strong>使用日志记录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class LoggingController &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(LoggingController.class);</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/log&quot;)</span><br><span class="line">    public String logExample() &#123;</span><br><span class="line">        logger.info(&quot;This is an info log message&quot;);</span><br><span class="line">        logger.error(&quot;This is an error log message&quot;);</span><br><span class="line">        return &quot;Logging example&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-国际化（I18N）"><a href="#3-国际化（I18N）" class="headerlink" title="3. 国际化（I18N）"></a>3. 国际化（I18N）</h4><h4 id="场景问题-2"><a href="#场景问题-2" class="headerlink" title="场景问题"></a>场景问题</h4><p>支持多语言，适应不同语言环境的用户。</p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用Spring Boot的国际化支持，实现多语言配置。</p>
<h4 id="实现业务逻辑-2"><a href="#实现业务逻辑-2" class="headerlink" title="实现业务逻辑"></a>实现业务逻辑</h4><p><strong>添加国际化资源文件</strong> 在<code>src/main/resources</code>目录下创建<code>messages.properties</code>和<code>messages_zh.properties</code>等文件。</p>
<p><strong>messages.properties</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">properties</span><br><span class="line"></span><br><span class="line">greeting=Hello</span><br></pre></td></tr></table></figure>

<p><strong>messages_zh.properties</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">properties</span><br><span class="line"></span><br><span class="line">greeting=你好</span><br></pre></td></tr></table></figure>

<p><strong>配置类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.MessageSource;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.support.ReloadableResourceBundleMessageSource;</span><br><span class="line">import org.springframework.web.servlet.LocaleResolver;</span><br><span class="line">import org.springframework.web.servlet.i18n.CookieLocaleResolver;</span><br><span class="line">import org.springframework.web.servlet.i18n.LocaleChangeInterceptor;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class InternationalizationConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MessageSource messageSource() &#123;</span><br><span class="line">        ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource();</span><br><span class="line">        messageSource.setBasename(&quot;classpath:messages&quot;);</span><br><span class="line">        messageSource.setDefaultEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        return messageSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public LocaleResolver localeResolver() &#123;</span><br><span class="line">        CookieLocaleResolver localeResolver = new CookieLocaleResolver();</span><br><span class="line">        localeResolver.setDefaultLocale(Locale.ENGLISH);</span><br><span class="line">        return localeResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public LocaleChangeInterceptor localeChangeInterceptor() &#123;</span><br><span class="line">        LocaleChangeInterceptor interceptor = new LocaleChangeInterceptor();</span><br><span class="line">        interceptor.setParamName(&quot;lang&quot;);</span><br><span class="line">        return interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>控制器类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.MessageSource;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestHeader;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.Locale;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class InternationalizationController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MessageSource messageSource;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/greet&quot;)</span><br><span class="line">    public String greet(@RequestHeader(name = &quot;Accept-Language&quot;, required = false) Locale locale) &#123;</span><br><span class="line">        return messageSource.getMessage(&quot;greeting&quot;, null, locale);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-任务调度"><a href="#4-任务调度" class="headerlink" title="4. 任务调度"></a>4. 任务调度</h4><h4 id="场景问题-3"><a href="#场景问题-3" class="headerlink" title="场景问题"></a>场景问题</h4><p>执行定时任务，如批处理、定时报告生成等。</p>
<h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用Spring’s <code>@Scheduled</code>注解实现定时任务。</p>
<h4 id="实现业务逻辑-3"><a href="#实现业务逻辑-3" class="headerlink" title="实现业务逻辑"></a>实现业务逻辑</h4><p><strong>添加依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>配置类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class SchedulingConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>任务调度类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class ScheduledTasks &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(ScheduledTasks.class);</span><br><span class="line"></span><br><span class="line">    @Scheduled(fixedRate = 5000)</span><br><span class="line">    public void reportCurrentTime() &#123;</span><br><span class="line">        logger.info(&quot;The time is now &#123;&#125;&quot;, new Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-文件上传和下载"><a href="#5-文件上传和下载" class="headerlink" title="5. 文件上传和下载"></a>5. 文件上传和下载</h4><h4 id="场景问题-4"><a href="#场景问题-4" class="headerlink" title="场景问题"></a>场景问题</h4><p>处理文件的上传和下载功能。</p>
<h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用Spring Boot的MultipartFile处理文件上传，使用Spring MVC处理文件下载。</p>
<h4 id="实现业务逻辑-4"><a href="#实现业务逻辑-4" class="headerlink" title="实现业务逻辑"></a>实现业务逻辑</h4><p><strong>添加依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>控制器类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line">import org.springframework.core.io.Resource;</span><br><span class="line">import org.springframework.core.io.UrlResource;</span><br><span class="line"></span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.nio.file.StandardCopyOption;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/files&quot;)</span><br><span class="line">public class FileController &#123;</span><br><span class="line">    private final Path fileStorageLocation = Paths.get(&quot;uploads&quot;).toAbsolutePath().normalize();</span><br><span class="line"></span><br><span class="line">    public FileController() throws Exception &#123;</span><br><span class="line">        Files.createDirectories(fileStorageLocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/upload&quot;)</span><br><span class="line">    public String uploadFile(@RequestParam(&quot;file&quot;) MultipartFile file) throws Exception &#123;</span><br><span class="line">        String fileName = file.getOriginalFilename();</span><br><span class="line">        Path targetLocation = fileStorageLocation.resolve(fileName);</span><br><span class="line">        Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">        return &quot;File uploaded successfully: &quot; + fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/download/&#123;fileName&#125;&quot;)</span><br><span class="line">    public Resource downloadFile(@PathVariable String fileName) throws Exception &#123;</span><br><span class="line">        Path filePath = fileStorageLocation.resolve(fileName).normalize();</span><br><span class="line">        Resource resource = new UrlResource(filePath.toUri());</span><br><span class="line">        if (resource.exists() &amp;&amp; resource.isReadable()) &#123;</span><br><span class="line">            return resource;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new RuntimeException(&quot;File not found or not readable: &quot; + fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-缓存处理"><a href="#6-缓存处理" class="headerlink" title="6. 缓存处理"></a>6. 缓存处理</h4><h4 id="场景问题-5"><a href="#场景问题-5" class="headerlink" title="场景问题"></a>场景问题</h4><p>提高数据访问性能，减少数据库负载。</p>
<h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用Spring Cache结合Redis进行缓存处理。</p>
<h4 id="实现业务逻辑-5"><a href="#实现业务逻辑-5" class="headerlink" title="实现业务逻辑"></a>实现业务逻辑</h4><p><strong>添加依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>配置类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.cache.annotation.EnableCaching;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableCaching</span><br><span class="line">public class CacheConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public LettuceConnectionFactory redisConnectionFactory() &#123;</span><br><span class="line">        return new LettuceConnectionFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate() &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory());</span><br><span class="line">        return redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.cache.annotation.Cacheable;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    private static final String USER_CACHE_KEY = &quot;user:&quot;;</span><br><span class="line"></span><br><span class="line">    @Cacheable(value = &quot;users&quot;, key = &quot;#id&quot;)</span><br><span class="line">    public User getUserById(Long id) &#123;</span><br><span class="line">        String cacheKey = USER_CACHE_KEY + id;</span><br><span class="line"></span><br><span class="line">        // 从Redis缓存中查询</span><br><span class="line">        User user = (User) redisTemplate.opsForValue().get(cacheKey);</span><br><span class="line">        if (user != null) &#123;</span><br><span class="line">            return user;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 缓存未命中，从数据库中查询</span><br><span class="line">        user = userRepository.findById(id).orElse(null);</span><br><span class="line">        if (user != null) &#123;</span><br><span class="line">            // 将查询结果存储到Redis缓存中，设置缓存时间为1小时</span><br><span class="line">            redisTemplate.opsForValue().set(cacheKey, user, 1, TimeUnit.HOURS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User saveUser(User user) &#123;</span><br><span class="line">        User savedUser = userRepository.save(user);</span><br><span class="line">        redisTemplate.opsForValue().set(USER_CACHE_KEY + savedUser.getId(), savedUser, 1, TimeUnit.HOURS);</span><br><span class="line">        return savedUser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deleteUser(Long id) &#123;</span><br><span class="line">        userRepository.deleteById(id);</span><br><span class="line">        redisTemplate.delete(USER_CACHE_KEY + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-远程服务调用"><a href="#7-远程服务调用" class="headerlink" title="7. 远程服务调用"></a>7. 远程服务调用</h4><h4 id="场景问题-6"><a href="#场景问题-6" class="headerlink" title="场景问题"></a>场景问题</h4><p>调用外部服务，如REST API和Web服务。</p>
<h4 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用Spring’s <code>RestTemplate</code>或<code>WebClient</code>进行远程服务调用。</p>
<h4 id="实现业务逻辑-6"><a href="#实现业务逻辑-6" class="headerlink" title="实现业务逻辑"></a>实现业务逻辑</h4><p><strong>添加依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>RestTemplate配置类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class RestTemplateConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplate restTemplate() &#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用RestTemplate调用外部服务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class RemoteServiceController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/fetch/&#123;id&#125;&quot;)</span><br><span class="line">    public String fetchData(@PathVariable String id) &#123;</span><br><span class="line">        String url = &quot;http://external-service/api/data/&quot; + id;</span><br><span class="line">        return restTemplate.getForObject(url, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-消息队列"><a href="#8-消息队列" class="headerlink" title="8. 消息队列"></a>8. 消息队列</h4><h4 id="场景问题-7"><a href="#场景问题-7" class="headerlink" title="场景问题"></a>场景问题</h4><p>实现异步消息处理，解耦微服务。</p>
<h4 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用Spring Boot集成RabbitMQ进行消息队列处理。</p>
<h4 id="实现业务逻辑-7"><a href="#实现业务逻辑-7" class="headerlink" title="实现业务逻辑"></a>实现业务逻辑</h4><p><strong>添加依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>配置类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.amqp.core.Queue;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class RabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue helloQueue() &#123;</span><br><span class="line">        return new Queue(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消息发送者</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class Sender &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    public void send(String message) &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(&quot;hello&quot;, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消息接收者</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class Receiver &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &quot;hello&quot;)</span><br><span class="line">    public void receive(String message) &#123;</span><br><span class="line">        System.out.println(&quot;Received message: &quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-API文档生成"><a href="#9-API文档生成" class="headerlink" title="9. API文档生成"></a>9. API文档生成</h4><h4 id="场景问题-8"><a href="#场景问题-8" class="headerlink" title="场景问题"></a>场景问题</h4><p>生成REST API文档，便于前后端协作。</p>
<h4 id="解决方案-8"><a href="#解决方案-8" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用Swagger或Spring REST Docs生成API文档。</p>
<h4 id="实现业务逻辑-8"><a href="#实现业务逻辑-8" class="headerlink" title="实现业务逻辑"></a>实现业务逻辑</h4><p><strong>添加依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Swagger配置类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import springfox.documentation.builders.PathSelectors;</span><br><span class="line">import springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line">import springfox.documentation.spi.DocumentationType;</span><br><span class="line">import springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line">import springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class SwaggerConfig &#123;</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public Docket api() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.example.demo&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>控制器类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class ApiController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/api/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;Hello, API!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问<code>http://localhost:8080/swagger-ui/</code>查看生成的API文档。</p>
<h4 id="10-文件存储"><a href="#10-文件存储" class="headerlink" title="10. 文件存储"></a>10. 文件存储</h4><h4 id="场景问题-9"><a href="#场景问题-9" class="headerlink" title="场景问题"></a>场景问题</h4><p>处理文件上传、存储和访问。</p>
<h4 id="解决方案-9"><a href="#解决方案-9" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用Spring Boot结合本地文件系统或云存储（如AWS S3）。</p>
<h4 id="实现业务逻辑-9"><a href="#实现业务逻辑-9" class="headerlink" title="实现业务逻辑"></a>实现业务逻辑</h4><p><strong>添加依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>控制器类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line">import org.springframework.core.io.Resource;</span><br><span class="line">import org.springframework.core.io.UrlResource;</span><br><span class="line"></span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.nio.file.StandardCopyOption;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/files&quot;)</span><br><span class="line">public class FileController &#123;</span><br><span class="line">    private final Path fileStorageLocation = Paths.get(&quot;uploads&quot;).toAbsolutePath().normalize();</span><br><span class="line"></span><br><span class="line">    public FileController() throws Exception &#123;</span><br><span class="line">        Files.createDirectories(fileStorageLocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/upload&quot;)</span><br><span class="line">    public String uploadFile(@RequestParam(&quot;file&quot;) MultipartFile file) throws Exception &#123;</span><br><span class="line">        String fileName = file.getOriginalFilename();</span><br><span class="line">        Path targetLocation = fileStorageLocation.resolve(fileName);</span><br><span class="line">        Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">        return &quot;File uploaded successfully: &quot; + fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/download/&#123;fileName&#125;&quot;)</span><br><span class="line">    public Resource downloadFile(@PathVariable String fileName) throws Exception &#123;</span><br><span class="line">        Path filePath = fileStorageLocation.resolve(fileName).normalize();</span><br><span class="line">        Resource resource = new UrlResource(filePath.toUri());</span><br><span class="line">        if (resource.exists() &amp;&amp; resource.isReadable()) &#123;</span><br><span class="line">            return resource;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new RuntimeException(&quot;File not found or not readable: &quot; + fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chabai000.github.io">茶白</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chabai000.github.io/posts/7648/">https://chabai000.github.io/posts/7648/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chabai000.github.io" target="_blank">茶白的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://api.dujin.org/bing/1366.php" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/%E8%B5%9E%E8%B5%8F%E7%A0%81.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E8%B5%9E%E8%B5%8F%E7%A0%81.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/43771/" title="shell脚本快速入门"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.dujin.org/bing/1366.php" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">shell脚本快速入门</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">茶白</div><div class="author-info__description">不论你在什么时候开始，重要的是开始之后就不要停止；不论你在什么时候结束，重要的是结束之后就不要悔恨</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/chabai000"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chabai000" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1693522579@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">1.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">锁的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">java锁的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.1.</span> <span class="toc-text">synchronized关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.2.</span> <span class="toc-text">synchronized实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%9A%84%E9%94%81%E7%B1%BB"><span class="toc-number">1.2.3.</span> <span class="toc-text">并发包中的锁类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B6%89%E5%8F%8A%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.</span> <span class="toc-text">锁涉及的几个重要概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E9%94%81%E5%92%8C%E5%AF%B9%E8%B1%A1%E9%94%81%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">类锁和对象锁（重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-number">2.</span> <span class="toc-text">多线程和异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">什么是进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">并行和并发区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">并发的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BD%9C%E7%94%A8"><span class="toc-number">2.4.</span> <span class="toc-text">并发作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.5.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5vs%E5%BC%82%E6%AD%A5"><span class="toc-number">2.6.</span> <span class="toc-text">同步vs异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">2.7.</span> <span class="toc-text">阻塞和非阻塞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis"><span class="toc-number">3.</span> <span class="toc-text">redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.1.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">3.1.1.</span> <span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E6%83%85%E5%86%B5"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">正常情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4"><span class="toc-number">3.1.1.5.</span> <span class="toc-text">双写一致</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.1.1.6.</span> <span class="toc-text">持久化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F"><span class="toc-number">3.1.1.7.</span> <span class="toc-text">数据过期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">3.1.1.8.</span> <span class="toc-text">淘汰策略</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.1.2.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#setnx"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">setnx</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redisson"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">redisson</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4"><span class="toc-number">3.1.3.</span> <span class="toc-text">命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">计数器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.4.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98token"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">保存token</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">3.1.4.3.</span> <span class="toc-text">延迟队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">3.2.</span> <span class="toc-text">其它</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4"><span class="toc-number">3.2.1.</span> <span class="toc-text">集群</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">主从</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%A8%E5%85%B5"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">哨兵</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4-1"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">集群</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.2.2.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="toc-number">3.2.3.</span> <span class="toc-text">redis为什么快</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql"><span class="toc-number">4.</span> <span class="toc-text">mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.1.1.</span> <span class="toc-text">定位慢查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">4.1.2.</span> <span class="toc-text">sql执行计划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">4.1.3.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">存储引擎</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">索引底层数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">4.1.3.3.</span> <span class="toc-text">聚簇和非聚簇索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E5%8E%9F%E5%88%99"><span class="toc-number">4.1.3.4.</span> <span class="toc-text">索引创建原则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="toc-number">4.1.3.5.</span> <span class="toc-text">索引失效场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sql%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C"><span class="toc-number">4.1.4.</span> <span class="toc-text">sql优化经验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83-1"><span class="toc-number">4.2.</span> <span class="toc-text">其它</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3"><span class="toc-number">4.2.1.</span> <span class="toc-text">事务相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">事务特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">隔离级别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MVCC"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">MVCC</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%90%8C%E6%AD%A5"><span class="toc-number">4.2.2.</span> <span class="toc-text">主存同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">4.2.3.</span> <span class="toc-text">读写分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">4.2.4.</span> <span class="toc-text">分库分表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6"><span class="toc-number">5.</span> <span class="toc-text">框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#spring"><span class="toc-number">5.1.</span> <span class="toc-text">spring</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.1.</span> <span class="toc-text">Bean线程安全问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP"><span class="toc-number">5.1.2.</span> <span class="toc-text">AOP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.3.</span> <span class="toc-text">事务原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88"><span class="toc-number">5.1.4.</span> <span class="toc-text">事务失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.1.5.</span> <span class="toc-text">Bean的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E5%BA%8F%E4%BE%9D%E8%B5%96"><span class="toc-number">5.1.6.</span> <span class="toc-text">循序依赖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#springmvc"><span class="toc-number">5.2.</span> <span class="toc-text">springmvc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">执行流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#springboot"><span class="toc-number">5.3.</span> <span class="toc-text">springboot</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.1.</span> <span class="toc-text">自动配置原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mybatis"><span class="toc-number">5.4.</span> <span class="toc-text">mybatis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-1"><span class="toc-number">5.4.1.</span> <span class="toc-text">执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD"><span class="toc-number">5.4.2.</span> <span class="toc-text">延迟加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">5.4.3.</span> <span class="toc-text">一二级缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">5.4.4.</span> <span class="toc-text">一级缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">5.4.5.</span> <span class="toc-text">二级缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ"><span class="toc-number">6.</span> <span class="toc-text">消息中间件——RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">消息模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E7%89%B9%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text">常用优化特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-number">6.2.1.</span> <span class="toc-text">消息不丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%B8%8D%E9%87%8D%E5%A4%8D"><span class="toc-number">6.2.2.</span> <span class="toc-text">消息不重复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF"><span class="toc-number">6.2.3.</span> <span class="toc-text">消息堆积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97-1"><span class="toc-number">6.2.4.</span> <span class="toc-text">延迟队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">6.2.5.</span> <span class="toc-text">死信队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.6.</span> <span class="toc-text">高可用机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%88todo%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">应用场景（todo）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">7.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#collection%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88"><span class="toc-number">7.1.</span> <span class="toc-text">collection单列集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#List"><span class="toc-number">7.1.1.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Vector"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedList"><span class="toc-number">7.1.1.3.</span> <span class="toc-text">LinkedList</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set"><span class="toc-number">7.1.2.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HashSet"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">7.1.2.1.1.</span> <span class="toc-text">LinkedHashSet</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TreeSet"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">TreeSet</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88"><span class="toc-number">7.2.</span> <span class="toc-text">Map双列集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashTable"><span class="toc-number">7.2.1.</span> <span class="toc-text">HashTable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap"><span class="toc-number">7.2.2.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">7.2.3.</span> <span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap"><span class="toc-number">7.2.4.</span> <span class="toc-text">TreeMap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87"><span class="toc-number">8.</span> <span class="toc-text">并发编程篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">8.1.</span> <span class="toc-text">线程的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.1.1.</span> <span class="toc-text">线程与进程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.1.2.</span> <span class="toc-text">并发和并行的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">8.1.3.</span> <span class="toc-text">创建线程的方式有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#runnable%E5%92%8Ccallable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">8.1.4.</span> <span class="toc-text">runnable和callable有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%8C%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E7%9A%84"><span class="toc-number">8.1.5.</span> <span class="toc-text">线程包括哪些状态，状态之间是如何变化的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8java%E4%B8%ADwait%E5%92%8Csleep%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">8.1.6.</span> <span class="toc-text">在java中wait和sleep方法的不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%83%E4%BB%AC%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">8.1.7.</span> <span class="toc-text">新建三个线程，如何保证它们按顺序执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#notify-%E5%92%8CnotifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">8.1.8.</span> <span class="toc-text">notify()和notifyAll()有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84run-%E5%92%8Cstart-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">8.1.9.</span> <span class="toc-text">线程的run()和start()有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E6%88%98%E7%A8%8B"><span class="toc-number">8.1.10.</span> <span class="toc-text">如何停止一个正在运行的战程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8"><span class="toc-number">8.2.</span> <span class="toc-text">线程中的并发安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%95%E5%8E%9F%E7%90%86"><span class="toc-number">8.2.1.</span> <span class="toc-text">synchronized关键字的底展原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E8%B0%88%E8%B0%88JMM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.2.2.</span> <span class="toc-text">你谈谈JMM (Java 内存模型)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97"><span class="toc-number">8.2.3.</span> <span class="toc-text">CAS你知道吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAQS"><span class="toc-number">8.2.4.</span> <span class="toc-text">什么是AQS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">8.2.5.</span> <span class="toc-text">ReentrantLock的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E5%92%8CLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">8.2.6.</span> <span class="toc-text">synchronized和Lock有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.2.7.</span> <span class="toc-text">死锁产生的条件是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%AD%BB%E9%94%81%E8%AF%8A%E6%96%AD"><span class="toc-number">8.2.8.</span> <span class="toc-text">如何进行死锁诊断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9volatile%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">8.2.9.</span> <span class="toc-text">请谈谈你对volatile的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%8A%E4%B8%80%E4%B8%8BConcurrentHashMap"><span class="toc-number">8.2.10.</span> <span class="toc-text">聊一下ConcurrentHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E8%87%B4%E4%BA%95%E5%8F%91%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.2.11.</span> <span class="toc-text">导致井发程序出现问题的根本原因是什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">8.3.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%98%9B"><span class="toc-number">8.3.1.</span> <span class="toc-text">说一下线程池的核心参数(线程池的执行原理知道嘛)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">8.3.2.</span> <span class="toc-text">线程池中有哪些常见的阻塞队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="toc-number">8.3.3.</span> <span class="toc-text">如何确定核心线程数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%A7%8D%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">8.3.4.</span> <span class="toc-text">线程池的种类有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">8.3.5.</span> <span class="toc-text">为什么不建议用Executors创建线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">8.4.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89"><span class="toc-number">8.4.1.</span> <span class="toc-text">线程池使用场景(你们项目中哪里用到了线程池）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E5%85%81%E8%AE%B8%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">8.4.2.</span> <span class="toc-text">如何控制某个方法允许并发访问线程的数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-%E4%BD%A0%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">8.4.3.</span> <span class="toc-text">谈谈 你对ThreadLocal的理解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jvm"><span class="toc-number">9.</span> <span class="toc-text">jvm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E6%A6%82%E8%BF%B0"><span class="toc-number">9.1.</span> <span class="toc-text">JVM 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E6%9E%84%E6%88%90"><span class="toc-number">9.2.</span> <span class="toc-text">JVM 构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.3.</span> <span class="toc-text">JVM 内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">9.4.</span> <span class="toc-text">类加载机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%EF%BC%88Garbage-Collection%EF%BC%89"><span class="toc-number">9.5.</span> <span class="toc-text">垃圾收集（Garbage Collection）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">9.6.</span> <span class="toc-text">垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98"><span class="toc-number">9.7.</span> <span class="toc-text">JVM 参数调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7"><span class="toc-number">9.8.</span> <span class="toc-text">性能监控工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">9.9.</span> <span class="toc-text">类加载器机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.9.1.</span> <span class="toc-text">双亲委派模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JIT-%E7%BC%96%E8%AF%91%E4%B8%8E-AOT-%E7%BC%96%E8%AF%91"><span class="toc-number">9.10.</span> <span class="toc-text">JIT 编译与 AOT 编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">9.11.</span> <span class="toc-text">常见问题及面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E5%9C%BA%E6%99%AF%E7%AF%87-3-5"><span class="toc-number">10.</span> <span class="toc-text">企业场景篇(3.5)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.1.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.1.1.</span> <span class="toc-text">工厂设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.1.1.1.</span> <span class="toc-text">简单工厂模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.1.1.2.</span> <span class="toc-text">工厂方法模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.1.1.3.</span> <span class="toc-text">抽象工厂模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.1.2.</span> <span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.1.3.</span> <span class="toc-text">责任链模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF1"><span class="toc-number">10.2.</span> <span class="toc-text">技术场景1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E8%BF%99%E5%9D%97%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.2.1.</span> <span class="toc-text">单点登录这块怎么实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.2.2.</span> <span class="toc-text">权限认证如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E4%BD%A0%E4%BB%AC%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6"><span class="toc-number">10.2.3.</span> <span class="toc-text">上传数据的安全性你们如何控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E8%B4%9F%E8%B4%A3%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E6%AF%94%E8%BE%83%E6%A3%98%E6%89%8B%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">10.2.4.</span> <span class="toc-text">你负责项目的时候遇到了哪些比较棘手的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E6%80%8E%E4%B9%88%E5%81%9A%E5%8E%8B%E6%B5%8B%E7%9A%84%EF%BC%88%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%EF%BC%89"><span class="toc-number">10.2.5.</span> <span class="toc-text">你们怎么做压测的（性能测试的）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%97%A5%E5%BF%97%E6%80%8E%E4%B9%88%E9%87%87%E9%9B%86%E7%9A%84"><span class="toc-number">10.2.6.</span> <span class="toc-text">你们项目中日志怎么采集的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">10.2.7.</span> <span class="toc-text">查看日志的命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%93%B6%E9%A2%88"><span class="toc-number">10.2.8.</span> <span class="toc-text">怎么快速定位系统的瓶颈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7-1"><span class="toc-number">10.2.9.</span> <span class="toc-text">性能监控工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="toc-number">10.2.10.</span> <span class="toc-text">日志分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5"><span class="toc-number">10.2.11.</span> <span class="toc-text">生产问题怎么排查</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF2"><span class="toc-number">10.3.</span> <span class="toc-text">技术场景2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83"><span class="toc-number">10.3.1.</span> <span class="toc-text">1. 用户认证和授权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98"><span class="toc-number">10.3.2.</span> <span class="toc-text">场景问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">10.3.3.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91"><span class="toc-number">10.3.4.</span> <span class="toc-text">实现业务逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86"><span class="toc-number">10.3.5.</span> <span class="toc-text">2. 日志管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98-1"><span class="toc-number">10.3.6.</span> <span class="toc-text">场景问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="toc-number">10.3.7.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91-1"><span class="toc-number">10.3.8.</span> <span class="toc-text">实现业务逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9B%BD%E9%99%85%E5%8C%96%EF%BC%88I18N%EF%BC%89"><span class="toc-number">10.3.9.</span> <span class="toc-text">3. 国际化（I18N）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98-2"><span class="toc-number">10.3.10.</span> <span class="toc-text">场景问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="toc-number">10.3.11.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91-2"><span class="toc-number">10.3.12.</span> <span class="toc-text">实现业务逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">10.3.13.</span> <span class="toc-text">4. 任务调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98-3"><span class="toc-number">10.3.14.</span> <span class="toc-text">场景问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-3"><span class="toc-number">10.3.15.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91-3"><span class="toc-number">10.3.16.</span> <span class="toc-text">实现业务逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD"><span class="toc-number">10.3.17.</span> <span class="toc-text">5. 文件上传和下载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98-4"><span class="toc-number">10.3.18.</span> <span class="toc-text">场景问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-4"><span class="toc-number">10.3.19.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91-4"><span class="toc-number">10.3.20.</span> <span class="toc-text">实现业务逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86"><span class="toc-number">10.3.21.</span> <span class="toc-text">6. 缓存处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98-5"><span class="toc-number">10.3.22.</span> <span class="toc-text">场景问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-5"><span class="toc-number">10.3.23.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91-5"><span class="toc-number">10.3.24.</span> <span class="toc-text">实现业务逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="toc-number">10.3.25.</span> <span class="toc-text">7. 远程服务调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98-6"><span class="toc-number">10.3.26.</span> <span class="toc-text">场景问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-6"><span class="toc-number">10.3.27.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91-6"><span class="toc-number">10.3.28.</span> <span class="toc-text">实现业务逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">10.3.29.</span> <span class="toc-text">8. 消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98-7"><span class="toc-number">10.3.30.</span> <span class="toc-text">场景问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-7"><span class="toc-number">10.3.31.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91-7"><span class="toc-number">10.3.32.</span> <span class="toc-text">实现业务逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-API%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90"><span class="toc-number">10.3.33.</span> <span class="toc-text">9. API文档生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98-8"><span class="toc-number">10.3.34.</span> <span class="toc-text">场景问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-8"><span class="toc-number">10.3.35.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91-8"><span class="toc-number">10.3.36.</span> <span class="toc-text">实现业务逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8"><span class="toc-number">10.3.37.</span> <span class="toc-text">10. 文件存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98-9"><span class="toc-number">10.3.38.</span> <span class="toc-text">场景问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-9"><span class="toc-number">10.3.39.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91-9"><span class="toc-number">10.3.40.</span> <span class="toc-text">实现业务逻辑</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/7648/" title="java八股文-高级篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.dujin.org/bing/1366.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java八股文-高级篇"/></a><div class="content"><a class="title" href="/posts/7648/" title="java八股文-高级篇">java八股文-高级篇</a><time datetime="2023-06-11T14:12:54.000Z" title="发表于 2023-06-11 22:12:54">2023-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/43771/" title="shell脚本快速入门"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.dujin.org/bing/1366.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="shell脚本快速入门"/></a><div class="content"><a class="title" href="/posts/43771/" title="shell脚本快速入门">shell脚本快速入门</a><time datetime="2022-06-24T12:55:57.000Z" title="发表于 2022-06-24 20:55:57">2022-06-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/55491/" title="java常用知识集"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java常用知识集"/></a><div class="content"><a class="title" href="/posts/55491/" title="java常用知识集">java常用知识集</a><time datetime="2022-05-19T12:32:28.000Z" title="发表于 2022-05-19 20:32:28">2022-05-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/37319/" title="jvm"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jvm"/></a><div class="content"><a class="title" href="/posts/37319/" title="jvm">jvm</a><time datetime="2022-05-19T04:13:32.000Z" title="发表于 2022-05-19 12:13:32">2022-05-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/12796/" title="centos7"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/centos.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="centos7"/></a><div class="content"><a class="title" href="/posts/12796/" title="centos7">centos7</a><time datetime="2022-05-18T07:14:53.000Z" title="发表于 2022-05-18 15:14:53">2022-05-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 茶白</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const disqus_config = function () {
    this.page.url = 'https://chabai000.github.io/posts/7648/'
    this.page.identifier = '/posts/7648/'
    this.page.title = 'java八股文-高级篇'
  }

  const disqusReset = () => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addGlobalFn('themeChange', disqusReset, 'disqus')

  const loadDisqus = () =>{
    if (window.DISQUS) disqusReset()
    else {
      const script = document.createElement('script')
      script.src = 'https://lchabai.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=lchabai&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if ('Disqus' === 'Disqus' || !true) {
    if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    fetch('https://disqus.com/api/3.0/forums/listPosts.json?forum=lchabai&related=thread&limit=6&api_key=')
      .then(response => response.json())
      .then(data => {
        const disqusArray = data.response.map(item => {
          return {
            'avatar': item.author.avatar.cache,
            'content': changeContent(item.message),
            'nick': item.author.name,
            'url': item.url,
            'date': item.createdAt
          }
        })

        saveToLocal.set('disqus-newest-comments', JSON.stringify(disqusArray), 10/(60*24))
        generateHtml(disqusArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (false) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick}</span><time> / ${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('disqus-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9310458102" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-lrcType="0"> </div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>