<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java八股文 | 茶白的博客</title><meta name="author" content="茶白"><meta name="copyright" content="茶白"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="包含计算机基础、Java基础、多线程、JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="Java八股文">
<meta property="og:url" content="https://chabai000.github.io/posts/17883/index.html">
<meta property="og:site_name" content="茶白的博客">
<meta property="og:description" content="包含计算机基础、Java基础、多线程、JVM">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chabai000.github.io/UpPictures/UpCover/%E5%85%AB%E8%82%A1%E6%96%87%E5%B0%81%E9%9D%A2.jpg">
<meta property="article:published_time" content="2022-03-21T10:10:39.000Z">
<meta property="article:modified_time" content="2024-09-05T13:39:23.034Z">
<meta property="article:author" content="茶白">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="八股文">
<meta property="article:tag" content="计算机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chabai000.github.io/UpPictures/UpCover/%E5%85%AB%E8%82%A1%E6%96%87%E5%B0%81%E9%9D%A2.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chabai000.github.io/posts/17883/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 茶白","link":"链接: ","source":"来源: 茶白的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java八股文',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-05 21:39:23'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><style type="text/css">.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{left:-66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{left:0!important}</style><meta name="generator" content="Hexo 7.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://api.bimg.cc/random')"><nav id="nav"><span id="blog-info"><a href="/" title="茶白的博客"><span class="site-name">茶白的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java八股文</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-21T10:10:39.000Z" title="发表于 2022-03-21 18:10:39">2022-03-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-05T13:39:23.034Z" title="更新于 2024-09-05 21:39:23">2024-09-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">164.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>543分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java八股文"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java基础常见面试题总结"><a href="#Java基础常见面试题总结" class="headerlink" title="Java基础常见面试题总结"></a>Java基础常见面试题总结</h1><h2 id="1-Java的特点"><a href="#1-Java的特点" class="headerlink" title="1.Java的特点"></a>1.Java的特点</h2><p><strong>Java是一门面向对象的编程语言</strong>。面向对象和面向过程的区别参考下一个问题。</p>
<p><strong>Java具有平台独立性和移植性</strong>。</p>
<ul>
<li>Java有一句口号：<code>Write once, run anywhere</code>，一次编写、到处运行。这也是Java的魅力所在。而实现这种特性的正是Java虚拟机JVM。已编译的Java程序可以在任何带有JVM的平台上运行。你可以在windows平台编写代码，然后拿到linux上运行。只要你在编写完代码后，将代码编译成.class文件，再把class文件打成Java包，这个jar包就可以在不同的平台上运行了。</li>
</ul>
<p><strong>Java具有稳健性</strong>。</p>
<ul>
<li>Java是一个强类型语言，它允许扩展编译时检查潜在类型不匹配问题的功能。Java要求显式的方法声明，它不支持C风格的隐式声明。这些严格的要求保证编译程序能捕捉调用错误，这就导致更可靠的程序。</li>
<li>异常处理是Java中使得程序更稳健的另一个特征。异常是某种类似于错误的异常条件出现的信号。使用<code>try/catch/finally</code>语句，程序员可以找到出错的处理代码，这就简化了出错处理和恢复的任务。</li>
</ul>
<h2 id="2-Java是如何实现跨平台的？"><a href="#2-Java是如何实现跨平台的？" class="headerlink" title="2.Java是如何实现跨平台的？"></a>2.Java是如何实现跨平台的？</h2><p>Java是通过JVM（Java虚拟机）实现跨平台的。</p>
<p>JVM可以理解成一个软件，不同的平台有不同的版本。我们编写的Java代码，编译后会生成.class 文件（字节码文件）。Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码，通过JVM翻译成机器码之后才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。</p>
<p>只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。</p>
<p>因此，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的翻译才能执行。</p>
<h2 id="3-Java-与-C-的区别"><a href="#3-Java-与-C-的区别" class="headerlink" title="3.Java 与 C++ 的区别"></a>3.Java 与 C++ 的区别</h2><ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 兼容 C ，不但支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性， C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
</ul>
<h2 id="4-JDK-JRE-JVM三者的关系"><a href="#4-JDK-JRE-JVM三者的关系" class="headerlink" title="4.JDK&#x2F;JRE&#x2F;JVM三者的关系"></a>4.JDK&#x2F;JRE&#x2F;JVM三者的关系</h2><p><strong>JVM</strong></p>
<p>英文名称（Java Virtual Machine），就是我们耳熟能详的 Java 虚拟机。Java 能够跨平台运行的核心在于 JVM 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/20220402230447.png" alt="img"></p>
<p>所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。也就是说class文件并不直接与机器的操作系统交互，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</p>
<p>针对不同的系统有不同的 jvm 实现，有 Linux 版本的 jvm 实现，也有Windows 版本的 jvm 实现，但是同一段代码在编译后的字节码是一样的。这就是Java能够跨平台，实现一次编写，多处运行的原因所在。</p>
<p><strong>JRE</strong></p>
<p>英文名称（Java Runtime Environment），就是Java 运行时环境。我们编写的Java程序必须要在JRE才能运行。它主要包含两个部分，JVM 和 Java 核心类库。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/20220401234008.png" alt="img"></p>
<p>JRE是Java的运行环境，并不是一个开发环境，所以没有包含任何开发工具，如编译器和调试器等。</p>
<p>如果你只是想运行Java程序，而不是开发Java程序的话，那么你只需要安装JRE即可。</p>
<p><strong>JDK</strong></p>
<p>英文名称（Java Development Kit），就是 Java 开发工具包</p>
<p>学过Java的同学，都应该安装过JDK。当我们安装完JDK之后，目录结构是这样的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/20220404120509.png" alt="img"></p>
<p>可以看到，JDK目录下有个JRE，也就是JDK中已经集成了 JRE，不用单独安装JRE。</p>
<p>另外，JDK中还有一些好用的工具，如jinfo，jps，jstack等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/20220404120507.png" alt="img"></p>
<p>最后，总结一下JDK&#x2F;JRE&#x2F;JVM，他们三者的关系</p>
<p><strong>JRE &#x3D; JVM + Java 核心类库</strong></p>
<p><strong>JDK &#x3D; JRE + Java工具 + 编译器 + 调试器</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/20220402230613.png" alt="img"></p>
<h2 id="5-Java程序是编译执行还是解释执行？"><a href="#5-Java程序是编译执行还是解释执行？" class="headerlink" title="5.Java程序是编译执行还是解释执行？"></a>5.Java程序是编译执行还是解释执行？</h2><p>先看看什么是编译型语言和解释型语言。</p>
<p><strong>编译型语言</strong></p>
<p>在程序运行之前，通过编译器将源程序编译成机器码可运行的二进制，以后执行这个程序时，就不用再进行编译了。</p>
<p>优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高，可以脱离语言环境独立运行。</p>
<p>缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。</p>
<p><strong>总结</strong>：执行速度快、效率高；依靠编译器、跨平台性差些。</p>
<p><strong>代表语言</strong>：C、C++、Pascal、Object-C以及Swift。</p>
<p><strong>解释型语言</strong></p>
<p>定义：解释型语言的源代码不是直接翻译成机器码，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。在运行的时候才将源程序翻译成机器码，翻译一句，然后执行一句，直至结束。</p>
<p>优点：</p>
<ol>
<li>有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（如虚拟机）。</li>
<li>灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。</li>
</ol>
<p>缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。</p>
<p>总结：解释型语言执行速度慢、效率低；依靠解释器、跨平台性好。</p>
<p>代表语言：JavaScript、Python、Erlang、PHP、Perl、Ruby。</p>
<p>对于Java这种语言，它的<strong>源代码</strong>会先通过javac编译成<strong>字节码</strong>，再通过jvm将字节码转换成<strong>机器码</strong>执行，即解释运行 和编译运行配合使用，所以可以称为混合型或者半编译型。</p>
<h2 id="6-面向对象和面向过程的区别？"><a href="#6-面向对象和面向过程的区别？" class="headerlink" title="6.面向对象和面向过程的区别？"></a>6.面向对象和面向过程的区别？</h2><p>面向对象和面向过程是一种软件开发思想。</p>
<ul>
<li>面向过程就是分析出解决问题所需要的步骤，然后用函数按这些步骤实现，使用的时候依次调用就可以了。</li>
<li>面向对象是把构成问题事务分解成各个对象，分别设计这些对象，然后将他们组装成有完整功能的系统。面向过程只用函数实现，面向对象是用类实现各个功能模块。</li>
</ul>
<p>以五子棋为例，面向过程的设计思路就是首先分析问题的步骤：</p>
<p>1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。<br>把上面每个步骤用分别的函数来实现，问题就解决了。</p>
<p>而面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为：</p>
<ol>
<li>黑白双方</li>
<li>棋盘系统，负责绘制画面</li>
<li>规则系统，负责判定诸如犯规、输赢等。</li>
</ol>
<p>黑白双方负责接受用户的输入，并告知棋盘系统棋子布局发生变化，棋盘系统接收到了棋子的变化的信息就负责在屏幕上面显示出这种变化，同时利用规则系统来对棋局进行判定。</p>
<h2 id="7-面向对象有哪些特性？"><a href="#7-面向对象有哪些特性？" class="headerlink" title="7.面向对象有哪些特性？"></a>7.面向对象有哪些特性？</h2><p>面向对象四大特性：封装，继承，多态，抽象</p>
<p>1、封装就是将类的信息隐藏在类内部，不允许外部程序直接访问，而是通过该类的方法实现对隐藏信息的操作和访问。 良好的封装能够减少耦合。</p>
<p>2、继承是从已有的类中派生出新的类，新的类继承父类的属性和行为，并能扩展新的能力，大大增加程序的重用性和易维护性。在Java中是单继承的，也就是说一个子类只有一个父类。</p>
<p>3、多态是同一个行为具有多个不同表现形式的能力。在不修改程序代码的情况下改变程序运行时绑定的代码。实现多态的三要素：继承、重写、父类引用指向子类对象。</p>
<ul>
<li>静态多态性：通过重载实现，相同的方法有不同的參数列表，可以根据参数的不同，做出不同的处理。</li>
<li>动态多态性：在子类中重写父类的方法。运行期间判断所引用对象的实际类型，根据其实际类型调用相应的方法。</li>
</ul>
<p>4、抽象。把客观事物用代码抽象出来。</p>
<h2 id="8-面向对象编程的六大原则"><a href="#8-面向对象编程的六大原则" class="headerlink" title="8.面向对象编程的六大原则?"></a>8.面向对象编程的六大原则?</h2><ul>
<li><strong>对象单一职责</strong>：我们设计创建的对象，必须职责明确，比如商品类，里面相关的属性和方法都必须跟商品相关，不能出现订单等不相关的内容。这里的类可以是模块、类库、程序集，而不单单指类。</li>
<li><strong>里式替换原则</strong>：子类能够完全替代父类，反之则不行。通常用于实现接口时运用。因为子类能够完全替代基（父）类，那么这样父类就拥有很多子类，在后续的程序扩展中就很容易进行扩展，程序完全不需要进行修改即可进行扩展。比如IA的实现为A，因为项目需求变更，现在需要新的实现，直接在容器注入处更换接口即可.</li>
<li><strong>迪米特法则</strong>，也叫最小原则，或者说最小耦合。通常在设计程序或开发程序的时候，尽量要高内聚，低耦合。当两个类进行交互的时候，会产生依赖。而迪米特法则就是建议这种依赖越少越好。就像构造函数注入父类对象时一样，当需要依赖某个对象时，并不在意其内部是怎么实现的，而是在容器中注入相应的实现，既符合里式替换原则，又起到了解耦的作用。</li>
<li>开闭原则：开放扩展，封闭修改。当项目需求发生变更时，要尽可能的不去对原有的代码进行修改，而在原有的基础上进行扩展。</li>
<li><strong>依赖倒置原则</strong>：高层模块不应该直接依赖于底层模块的具体实现，而应该依赖于底层的抽象。接口和抽象类不应该依赖于实现类，而实现类依赖接口或抽象类。</li>
<li><strong>接口隔离原则</strong>：一个对象和另外一个对象交互的过程中，依赖的内容最小。也就是说在接口设计的时候，在遵循对象单一职责的情况下，尽量减少接口的内容。</li>
</ul>
<p><strong>简洁版</strong>：</p>
<ul>
<li>单一职责：对象设计要求独立，不能设计万能对象。</li>
<li>开闭原则：对象修改最小化。</li>
<li>里式替换：程序扩展中抽象被具体可以替换（接口、父类、可以被实现类对象、子类替换对象）</li>
<li>迪米特：高内聚，低耦合。尽量不要依赖细节。</li>
<li>依赖倒置：面向抽象编程。也就是参数传递，或者返回值，可以使用父类类型或者接口类型。从广义上讲：基于接口编程，提前设计好接口框架。</li>
<li>接口隔离：接口设计大小要适中。过大导致污染，过小，导致调用麻烦。</li>
</ul>
<h2 id="9-数组到底是不是对象？"><a href="#9-数组到底是不是对象？" class="headerlink" title="9.数组到底是不是对象？"></a>9.数组到底是不是对象？</h2><p>先说说对象的概念。对象是根据某个类创建出来的一个实例，表示某类事物中一个具体的个体。</p>
<p>对象具有各种属性，并且具有一些特定的行为。站在计算机的角度，对象就是内存中的一个内存块，在这个内存块封装了一些数据，也就是类中定义的各个属性。</p>
<p>所以，对象是用来封装数据的。</p>
<p>java中的数组具有java中其他对象的一些基本特点。比如封装了一些数据，可以访问属性，也可以调用方法。</p>
<p>因此，可以说，数组是对象。</p>
<p>也可以通过代码验证数组是对象的事实。比如以下的代码，输出结果为java.lang.Object。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> <span class="type">int</span>[].class;</span><br><span class="line">System.out.println(clz.getSuperclass().getName());</span><br></pre></td></tr></table></figure>

<p>由此，可以看出，数组类的父类就是Object类，那么可以推断出数组就是对象。</p>
<h2 id="10-Java的基本数据类型有哪些？"><a href="#10-Java的基本数据类型有哪些？" class="headerlink" title="10.Java的基本数据类型有哪些？"></a>10.Java的基本数据类型有哪些？</h2><ul>
<li>byte，8bit</li>
<li>char，16bit</li>
<li>short，16bit</li>
<li>int，32bit</li>
<li>float，32bit</li>
<li>long，64bit</li>
<li>double，64bit</li>
<li>boolean，只有两个值：true、false，可以使⽤用 1 bit 来存储</li>
</ul>
<table>
<thead>
<tr>
<th>简单类型</th>
<th>boolean</th>
<th>byte</th>
<th>char</th>
<th>short</th>
<th>Int</th>
<th>long</th>
<th>float</th>
<th>double</th>
</tr>
</thead>
<tbody><tr>
<td>二进制位数</td>
<td>1</td>
<td>8</td>
<td>16</td>
<td>16</td>
<td>32</td>
<td>64</td>
<td>32</td>
<td>64</td>
</tr>
<tr>
<td>包装类</td>
<td>Boolean</td>
<td>Byte</td>
<td>Character</td>
<td>Short</td>
<td>Integer</td>
<td>Long</td>
<td>Float</td>
<td>Double</td>
</tr>
</tbody></table>
<p>在Java规范中，没有明确指出boolean的大小。在《Java虚拟机规范》给出了单个boolean占4个字节，和boolean数组1个字节的定义，具体 <strong>还要看虚拟机实现是否按照规范来</strong>，因此boolean占用1个字节或者4个字节都是有可能的。</p>
<h2 id="11-为什么不能用浮点型表示金额？"><a href="#11-为什么不能用浮点型表示金额？" class="headerlink" title="11.为什么不能用浮点型表示金额？"></a>11.为什么不能用浮点型表示金额？</h2><p>由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。</p>
<p>建议使用BigDecimal或者Long来表示金额。</p>
<h2 id="12-什么是值传递和引用传递？"><a href="#12-什么是值传递和引用传递？" class="headerlink" title="12.什么是值传递和引用传递？"></a>12.什么是值传递和引用传递？</h2><ul>
<li>值传递是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。</li>
<li>引用传递一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身，两者指向同一片内存空间。所以对引用对象进行操作会同时改变原对象。</li>
</ul>
<p><strong>java中不存在引用传递，只有值传递</strong>。即不存在变量a指向变量b，变量b指向对象的这种情况。</p>
<h2 id="13-了解Java的包装类型吗？为什么需要包装类？"><a href="#13-了解Java的包装类型吗？为什么需要包装类？" class="headerlink" title="13.了解Java的包装类型吗？为什么需要包装类？"></a>13.了解Java的包装类型吗？为什么需要包装类？</h2><p>Java 是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将 int 、double 等类型放进去的。因为集合的容器要求元素是 Object 类型。</p>
<p>为了让基本类型也具有对象的特征，就出现了包装类型。相当于将基本类型包装起来，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p>
<h2 id="14-自动装箱和拆箱"><a href="#14-自动装箱和拆箱" class="headerlink" title="14.自动装箱和拆箱"></a>14.自动装箱和拆箱</h2><p>Java中基础数据类型与它们对应的包装类见下表：</p>
<table>
<thead>
<tr>
<th align="left">原始类型</th>
<th align="left">包装类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boolean</td>
<td align="left">Boolean</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">Byte</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">Character</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">Float</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">Integer</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">Long</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">Short</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">Double</td>
</tr>
</tbody></table>
<p>装箱：将基础类型转化为包装类型。</p>
<p>拆箱：将包装类型转化为基础类型。</p>
<p>当基础类型与它们的包装类有如下几种情况时，编译器会<strong>自动</strong>帮我们进行装箱或拆箱：</p>
<ul>
<li>赋值操作（装箱或拆箱）</li>
<li>进行加减乘除混合运算 （拆箱）</li>
<li>进行&gt;,&lt;,&#x3D;&#x3D;比较运算（拆箱）</li>
<li>调用equals进行比较（装箱）</li>
<li>ArrayList、HashMap等集合类添加基础类型数据时（装箱）</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 装箱 调⽤ Integer.valueOf(1)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x; <span class="comment">// 拆箱 调⽤了 X.intValue()</span></span><br></pre></td></tr></table></figure>

<p>下面看一道常见的面试题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">System.out.println(c == d);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>为什么第三个输出是false？看看 Integer 类的源码就知道啦。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Integer c = 200;</code> 会调用 调⽤<code>Integer.valueOf(200)</code>。而从Integer的valueOf()源码可以看到，这里的实现并不是简单的new Integer，而是用IntegerCache做一个cache。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是IntegerCache静态代码块中的一段，默认Integer cache 的下限是-128，上限默认127。当赋值100给Integer时，刚好在这个范围内，所以从cache中取对应的Integer并返回，所以a和b返回的是同一个对象，所以<code>==</code>比较是相等的，当赋值200给Integer时，不在cache 的范围内，所以会new Integer并返回，当然<code>==</code>比较的结果是不相等的。</p>
<h2 id="15-String-为什么不可变？"><a href="#15-String-为什么不可变？" class="headerlink" title="15.String 为什么不可变？"></a>15.String 为什么不可变？</h2><p>先看看什么是不可变的对象。</p>
<p>如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p>
<p>接着来看Java8 String类的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出，String对象其实在内部就是一个个字符，存储在这个value数组里面的。</p>
<p>value数组用final修饰，final 修饰的变量，值不能被修改。因此value不可以指向其他对象。</p>
<p>String类内部所有的字段都是私有的，也就是被private修饰。而且String没有对外提供修改内部状态的方法，因此value数组不能改变。</p>
<p>所以，String是不可变的。</p>
<p>那为什么String要设计成不可变的？</p>
<p>主要有以下几点原因：</p>
<ol>
<li><strong>线程安全</strong>。同一个字符串实例可以被多个线程共享，因为字符串不可变，本身就是线程安全的。</li>
<li><strong>支持hash映射和缓存</strong>。因为String的hash值经常会使用到，比如作为 Map 的键，不可变的特性使得 hash 值也不会变，不需要重新计算。</li>
<li><strong>出于安全考虑</strong>。网络地址URL、文件路径path、密码通常情况下都是以String类型保存，假若String不是固定不变的，将会引起各种安全隐患。比如将密码用String的类型保存，那么它将一直留在内存中，直到垃圾收集器把它清除。假如String类不是固定不变的，那么这个密码可能会被改变，导致出现安全隐患。</li>
<li><strong>字符串常量池优化</strong>。String对象创建之后，会缓存到字符串常量池中，下次需要创建同样的对象时，可以直接返回缓存的引用。</li>
</ol>
<p>既然我们的String是不可变的，它内部还有很多substring， replace， replaceAll这些操作的方法。这些方法好像会改变String对象？怎么解释呢？</p>
<p>其实不是的，我们每次调用replace等方法，其实会在堆内存中创建了一个新的对象。然后其value数组引用指向不同的对象。</p>
<h2 id="16-为何JDK9要将String的底层实现由char-改成byte"><a href="#16-为何JDK9要将String的底层实现由char-改成byte" class="headerlink" title="16.为何JDK9要将String的底层实现由char[]改成byte[]?"></a>16.为何JDK9要将String的底层实现由char[]改成byte[]?</h2><p>主要是为了<strong>节约String占用的内存</strong>。</p>
<p>在大部分Java程序的堆内存中，String占用的空间最大，并且绝大多数String只有Latin-1字符，这些Latin-1字符只需要1个字节就够了。</p>
<p>而在JDK9之前，JVM因为String使用char数组存储，每个char占2个字节，所以即使字符串只需要1字节，它也要按照2字节进行分配，浪费了一半的内存空间。</p>
<p>到了JDK9之后，对于每个字符串，会先判断它是不是只有Latin-1字符，如果是，就按照1字节的规格进行分配内存，如果不是，就按照2字节的规格进行分配，这样便提高了内存使用率，同时GC次数也会减少，提升效率。</p>
<p>不过Latin-1编码集支持的字符有限，比如不支持中文字符，因此对于中文字符串，用的是UTF16编码（两个字节），所以用byte[]和char[]实现没什么区别。</p>
<h2 id="17-String-StringBuffer-和-StringBuilder区别"><a href="#17-String-StringBuffer-和-StringBuilder区别" class="headerlink" title="17.String, StringBuffer 和 StringBuilder区别"></a>17.String, StringBuffer 和 StringBuilder区别</h2><p><strong>1. 可变性</strong></p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p><strong>2. 线程安全</strong></p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<h2 id="18-什么是StringJoiner？"><a href="#18-什么是StringJoiner？" class="headerlink" title="18.什么是StringJoiner？"></a>18.什么是StringJoiner？</h2><p>StringJoiner是 Java 8 新增的一个 API，它基于 StringBuilder 实现，用于实现对字符串之间通过分隔符拼接的场景。</p>
<p>StringJoiner 有两个构造方法，第一个构造要求依次传入分隔符、前缀和后缀。第二个构造则只要求传入分隔符即可（前缀和后缀默认为空字符串）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix)</span><br><span class="line">StringJoiner(CharSequence delimiter)</span><br></pre></td></tr></table></figure>

<p>有些字符串拼接场景，使用 StringBuffer 或 StringBuilder 则显得比较繁琐。</p>
<p>比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; values = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.size(); i++) &#123;</span><br><span class="line">	sb.append(values.get(i));</span><br><span class="line">	<span class="keyword">if</span> (i != values.size() -<span class="number">1</span>) &#123;</span><br><span class="line">		sb.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sb.append(<span class="string">&quot;)&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>而通过StringJoiner来实现拼接List的各个元素，代码看起来更加简洁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; values = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Integer value : values) &#123;</span><br><span class="line">	sj.add(value.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，像平时经常使用的Collectors.joining(“,”)，底层就是通过StringJoiner实现的。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(</span><br><span class="line">    CharSequence delimiter,CharSequence prefix,CharSequence suffix) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(</span><br><span class="line">            () -&gt; <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(delimiter, prefix, suffix),</span><br><span class="line">            StringJoiner::add, StringJoiner::merge,</span><br><span class="line">            StringJoiner::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-String-类的常用方法有哪些？"><a href="#19-String-类的常用方法有哪些？" class="headerlink" title="19.String 类的常用方法有哪些？"></a>19.String 类的常用方法有哪些？</h2><ul>
<li>indexOf()：返回指定字符的索引。</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
<h2 id="20-new-String-“dabin”-会创建几个对象？"><a href="#20-new-String-“dabin”-会创建几个对象？" class="headerlink" title="20.new String(“dabin”)会创建几个对象？"></a>20.new String(“dabin”)会创建几个对象？</h2><p>使用这种方式会创建两个字符串对象（前提是字符串常量池中没有 “dabin” 这个字符串对象）。</p>
<ul>
<li>“dabin” 属于字符串字面量，因此编译时期会在字符串常量池中创建一个字符串对象，指向这个 “dabin” 字符串字面量；</li>
<li>使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<h2 id="21-什么是字符串常量池？"><a href="#21-什么是字符串常量池？" class="headerlink" title="21.什么是字符串常量池？"></a>21.什么是字符串常量池？</h2><p>字符串常量池（String Pool）保存着所有字符串字面量，这些字面量在编译时期就确定。字符串常量池位于堆内存中，专门用来存储字符串常量。在创建字符串时，JVM首先会检查字符串常量池，如果该字符串已经存在池中，则返回其引用，如果不存在，则创建此字符串并放入池中，并返回其引用。</p>
<h2 id="22-String最大长度是多少？"><a href="#22-String最大长度是多少？" class="headerlink" title="22.String最大长度是多少？"></a>22.String最大长度是多少？</h2><p>String类提供了一个length方法，返回值为int类型，而int的取值上限为2^31 -1。</p>
<p>所以理论上String的最大长度为2^31 -1。</p>
<p><strong>达到这个长度的话需要多大的内存吗</strong>？</p>
<p>String内部是使用一个char数组来维护字符序列的，一个char占用两个字节。如果说String最大长度是2^31 -1的话，那么最大的字符串占用内存空间约等于4GB。</p>
<p>也就是说，我们需要有大于4GB的JVM运行内存才行。</p>
<p><strong>那String一般都存储在JVM的哪块区域呢</strong>？</p>
<p>字符串在JVM中的存储分两种情况，一种是String对象，存储在JVM的堆栈中。一种是字符串常量，存储在常量池里面。</p>
<p><strong>什么情况下字符串会存储在常量池呢</strong>？</p>
<p>当通过字面量进行字符串声明时，比如String s &#x3D; “茶白”;，这个字符串在编译之后会以常量的形式进入到常量池。</p>
<p><strong>那常量池中的字符串最大长度是2^31-1吗</strong>？</p>
<p>不是的，常量池对String的长度是有另外限制的。。Java中的UTF-8编码的Unicode字符串在常量池中以CONSTANT_Utf8类型表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 length;</span><br><span class="line">    u1 bytes[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>length在这里就是代表字符串的长度，length的类型是u2，u2是无符号的16位整数，也就是说最大长度可以做到2^16-1 即 65535。</p>
<p>不过javac编译器做了限制，需要length &lt; 65535。所以字符串常量在常量池中的最大长度是65535 - 1 &#x3D; 65534。</p>
<p>最后总结一下：</p>
<p>String在不同的状态下，具有不同的长度限制。</p>
<ul>
<li>字符串常量长度不能超过65534</li>
<li>堆内字符串的长度不超过2^31-1</li>
</ul>
<h2 id="23-Object常用方法有哪些？"><a href="#23-Object常用方法有哪些？" class="headerlink" title="23.Object常用方法有哪些？"></a>23.Object常用方法有哪些？</h2><p>Java面试经常会出现的一道题目，Object的常用方法。下面给大家整理一下。</p>
<p>Object常用方法有：<code>toString()</code>、<code>equals()</code>、<code>hashCode()</code>、<code>clone()</code>等。</p>
<p><strong>toString</strong></p>
<p>默认输出对象地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, <span class="string">&quot;茶白&quot;</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//me.tyson.java.core.Person@4554617c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以重写toString方法，按照重写逻辑输出对象值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;:&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, <span class="string">&quot;茶白&quot;</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//茶白:18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>equals</strong></p>
<p>默认比较两个引用变量是否指向同一个对象（内存地址）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.age = age;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;茶白&quot;</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, name);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, name);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以重写equals方法，按照age和name是否相等来判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">            <span class="keyword">return</span> age == p.age &amp;&amp; name.equals(p.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;茶白&quot;</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, name);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, name);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>hashCode</strong></p>
<p>将与对象相关的信息映射成一个哈希值，默认的实现hashCode值是根据内存地址换算出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Cat</span>().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//out</span></span><br><span class="line">    <span class="comment">//1349277854</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>clone</strong></p>
<p>Java赋值是复制对象引用，如果我们想要得到一个对象的副本，使用赋值操作是无法达到目的的。Object对象有个clone()方法，实现了对</p>
<p>象中各个属性的复制，但它的可见范围是protected的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure>

<p>所以实体类使用克隆的前提是：</p>
<ul>
<li>实现Cloneable接口，这是一个标记接口，自身没有方法，这应该是一种约定。调用clone方法时，会判断有没有实现Cloneable接口，没有实现Cloneable的话会抛异常CloneNotSupportedException。</li>
<li>覆盖clone()方法，可见性提升为public。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        c.name = <span class="string">&quot;茶白&quot;</span>;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cloneCat</span> <span class="operator">=</span> (Cat) c.clone();</span><br><span class="line">        c.name = <span class="string">&quot;茶白&quot;</span>;</span><br><span class="line">        System.out.println(cloneCat.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//茶白</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getClass</strong></p>
<p>返回此 Object 的运行时类，常用于java反射机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;茶白&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">        System.out.println(clz);</span><br><span class="line">        <span class="comment">//获取类名</span></span><br><span class="line">        System.out.println(clz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * class com.tyson.basic.Person</span></span><br><span class="line"><span class="comment">     * com.tyson.basic.Person</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>wait</strong></p>
<p>当前线程调用对象的wait()方法之后，当前线程会释放对象锁，进入等待状态。等待其他线程调用此对象的notify()&#x2F;notifyAll()唤醒或者等待超时时间wait(long timeout)自动唤醒。线程需要获取obj对象锁之后才能调用 obj.wait()。</p>
<p><strong>notify</strong></p>
<p>obj.notify()唤醒在此对象上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象上等待的所有线程。</p>
<h2 id="24-讲讲深拷贝和浅拷贝？"><a href="#24-讲讲深拷贝和浅拷贝？" class="headerlink" title="24.讲讲深拷贝和浅拷贝？"></a>24.讲讲深拷贝和浅拷贝？</h2><p><strong>浅拷贝</strong>：拷⻉对象和原始对象的引⽤类型引用同⼀个对象。</p>
<p>以下例子，Cat对象里面有个Person对象，调用clone之后，克隆对象和原对象的Person引用的是同一个对象，这就是浅拷贝。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Person owner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, <span class="string">&quot;茶白&quot;</span>);</span><br><span class="line">        c.owner = p;</span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cloneCat</span> <span class="operator">=</span> (Cat) c.clone();</span><br><span class="line">        p.setName(<span class="string">&quot;茶白&quot;</span>);</span><br><span class="line">        System.out.println(cloneCat.owner.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//茶白</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>深拷贝</strong>：拷贝对象和原始对象的引用类型引用不同的对象。</p>
<p>以下例子，在clone函数中不仅调用了super.clone，而且调用Person对象的clone方法（Person也要实现Cloneable接口并重写clone方法），从而实现了深拷贝。可以看到，拷贝对象的值不会受到原对象的影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Person owner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        c = (Cat) <span class="built_in">super</span>.clone();</span><br><span class="line">        c.owner = (Person) owner.clone();<span class="comment">//拷贝Person对象</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, <span class="string">&quot;茶白&quot;</span>);</span><br><span class="line">        c.owner = p;</span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cloneCat</span> <span class="operator">=</span> (Cat) c.clone();</span><br><span class="line">        p.setName(<span class="string">&quot;茶白&quot;</span>);</span><br><span class="line">        System.out.println(cloneCat.owner.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="comment">//茶白</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="25-两个对象的hashCode-相同，则-equals-是否也一定为-true？"><a href="#25-两个对象的hashCode-相同，则-equals-是否也一定为-true？" class="headerlink" title="25.两个对象的hashCode()相同，则 equals()是否也一定为 true？"></a>25.两个对象的hashCode()相同，则 equals()是否也一定为 true？</h2><p>equals与hashcode的关系：</p>
<ol>
<li>如果两个对象调用equals比较返回true，那么它们的hashCode值一定要相同；</li>
<li>如果两个对象的hashCode相同，它们并不一定相同。</li>
</ol>
<p>hashcode方法主要是用来<strong>提升对象比较的效率</strong>，先进行hashcode()的比较，如果不相同，那就不必在进行equals的比较，这样就大大减少了equals比较的次数，当比较对象的数量很大的时候能提升效率。</p>
<h2 id="26-为什么重写-equals-时一定要重写-hashCode？"><a href="#26-为什么重写-equals-时一定要重写-hashCode？" class="headerlink" title="26.为什么重写 equals 时一定要重写 hashCode？"></a>26.为什么重写 equals 时一定要重写 hashCode？</h2><p>之所以重写<code>equals()</code>要重写<code>hashcode()</code>，是为了保证<code>equals()</code>方法返回true的情况下hashcode值也要一致，如果重写了<code>equals()</code>没有重写<code>hashcode()</code>，就会出现两个对象相等但<code>hashcode()</code>不相等的情况。这样，当用其中的一个对象作为键保存到hashMap、hashTable或hashSet中，再以另一个对象作为键值去查找他们的时候，则会查找不到。</p>
<h2 id="27-Java创建对象有几种方式？"><a href="#27-Java创建对象有几种方式？" class="headerlink" title="27.Java创建对象有几种方式？"></a>27.Java创建对象有几种方式？</h2><p>Java创建对象有以下几种方式：</p>
<ul>
<li>用new语句创建对象。</li>
<li>使用反射，使用Class.newInstance()创建对象。</li>
<li>调用对象的clone()方法。</li>
<li>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</li>
</ul>
<h2 id="28-说说类实例化的顺序"><a href="#28-说说类实例化的顺序" class="headerlink" title="28.说说类实例化的顺序"></a>28.说说类实例化的顺序</h2><p>Java中类实例化顺序：</p>
<ol>
<li>静态属性，静态代码块。</li>
<li>普通属性，普通代码块。</li>
<li>构造方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifeCycle</span> &#123;</span><br><span class="line">    <span class="comment">// 静态属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> getStaticField();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(staticField);</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> getField();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LifeCycle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStaticField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">statiFiled</span> <span class="operator">=</span> <span class="string">&quot;静态属性初始化&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> statiFiled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filed</span> <span class="operator">=</span> <span class="string">&quot;普通属性初始化&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> filed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argc)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LifeCycle</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *      静态属性初始化</span></span><br><span class="line"><span class="comment">     *      静态代码块初始化</span></span><br><span class="line"><span class="comment">     *      普通属性初始化</span></span><br><span class="line"><span class="comment">     *      普通代码块初始化</span></span><br><span class="line"><span class="comment">     *      构造方法初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="29-equals和-有什么区别？"><a href="#29-equals和-有什么区别？" class="headerlink" title="29.equals和&#x3D;&#x3D;有什么区别？"></a>29.equals和&#x3D;&#x3D;有什么区别？</h2><ul>
<li>对于基本数据类型，&#x3D;&#x3D;比较的是他们的值。基本数据类型没有equal方法；</li>
<li>对于复合数据类型，&#x3D;&#x3D;比较的是它们的存放地址(是否是同一个对象)。<code>equals()</code>默认比较地址值，重写的话按照重写逻辑去比较。</li>
</ul>
<h2 id="30-常见的关键字有哪些？"><a href="#30-常见的关键字有哪些？" class="headerlink" title="30.常见的关键字有哪些？"></a>30.常见的关键字有哪些？</h2><p><strong>static</strong></p>
<p>static可以用来修饰类的成员方法、类的成员变量。</p>
<p>static变量也称作<strong>静态变量</strong>，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p>
<p>以下例子，age为非静态变量，则p1打印结果是：<code>Name:zhangsan, Age:10</code>；若age使用static修饰，则p1打印结果是：<code>Name:zhangsan, Age:12</code>，因为static变量在内存只有一个副本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Name:&quot;</span> + name + <span class="string">&quot;, Age:&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p1.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">        p1.age = <span class="number">10</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p2.name = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">        p2.age = <span class="number">12</span>;</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**Output</span></span><br><span class="line"><span class="comment">     * Name:zhangsan, Age:10</span></span><br><span class="line"><span class="comment">     * Name:lisi, Age:12</span></span><br><span class="line"><span class="comment">     */</span><span class="comment">//~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>static方法一般称作<strong>静态方法</strong>。静态方法不依赖于任何对象就可以进行访问，通过类名即可调用静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world: &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Utils.print(<span class="string">&quot;茶白&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态代码块</strong>只会在类加载的时候执行一次。以下例子，startDate和endDate在类加载的时候进行赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>  &#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Date startDate, endDate;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        startDate = Date.valueOf(<span class="string">&quot;2008&quot;</span>);</span><br><span class="line">        endDate = Date.valueOf(<span class="string">&quot;2021&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Date birthDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态内部类</strong></p>
<p><strong>在静态方法里</strong>，使用⾮静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。⽽静态内部类不需要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 在静态方法里，不能直接使用OuterClass.this去创建InnerClass的实例</span></span><br><span class="line">        <span class="comment">// 需要先创建OuterClass的实例o，然后通过o创建InnerClass的实例</span></span><br><span class="line">        <span class="comment">// InnerClass innerClass = new InnerClass();</span></span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> outerClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        <span class="type">StaticInnerClass</span> <span class="variable">staticInnerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line"></span><br><span class="line">        outerClass.test();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nonStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;nonStaticMethod...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>final</strong></p>
<ol>
<li><strong>基本数据</strong>类型用final修饰，则不能修改，是常量；<strong>对象引用</strong>用final修饰，则引用只能指向该对象，不能指向别的对象，但是对象本身可以修改。</li>
<li>final修饰的方法不能被子类重写</li>
<li>final修饰的类不能被继承。</li>
</ol>
<p><strong>this</strong></p>
<p><code>this.属性名称</code>指访问类中的成员变量，可以用来区分成员变量和局部变量。如下代码所示，<code>this.name</code>访问类Person当前实例的变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-08-17 00:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this.方法名称</code>用来访问本类的方法。以下代码中，<code>this.born()</code>调用类 Person 的当前实例的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-08-17 00:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.born();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">born</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>super</strong></p>
<p>super 关键字用于在子类中访问父类的变量和方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;茶白&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类:&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name);</span><br><span class="line">        <span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 茶白</span></span><br><span class="line"><span class="comment">     * 父类:茶白</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子类B中，我们重写了父类的<code>getName()</code>方法，如果在重写的<code>getName()</code>方法中我们要调用父类的相同方法，必须要通过super关键字显式指出。</p>
<h2 id="31-final-finally-finalize-的区别"><a href="#31-final-finally-finalize-的区别" class="headerlink" title="31.final, finally, finalize 的区别"></a>31.final, finally, finalize 的区别</h2><ul>
<li>final 用于修饰属性、方法和类, 分别表示属性不能被重新赋值，方法不可被覆盖，类不可被继承。</li>
<li>finally 是异常处理语句结构的一部分，一般以<code>try-catch-finally</code>出现，<code>finally</code>代码块表示总是被执行。</li>
<li>finalize 是Object类的一个方法，该方法一般由垃圾回收器来调用，当我们调用<code>System.gc()</code>方法的时候，由垃圾回收器调用<code>finalize()</code>方法，回收垃圾，JVM并不保证此方法总被调用。</li>
</ul>
<h2 id="32-final关键字的作用？"><a href="#32-final关键字的作用？" class="headerlink" title="32.final关键字的作用？"></a>32.final关键字的作用？</h2><ul>
<li>final 修饰的类不能被继承。</li>
<li>final 修饰的方法不能被重写。</li>
<li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li>
</ul>
<h2 id="33-方法重载和重写的区别？"><a href="#33-方法重载和重写的区别？" class="headerlink" title="33.方法重载和重写的区别？"></a>33.方法重载和重写的区别？</h2><p><strong>同个类中的多个方法可以有相同的方法名称，但是有不同的参数列表，这就称为方法重载</strong>。参数列表又叫参数签名，包括参数的类型、参数的个数、参数的顺序，只要有一个不同就叫做参数列表不同。</p>
<p>重载是面向对象的一个基本特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverrideTest</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPerson</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPerson</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//set name</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPerson</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">//set name and age</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法的重写描述的是父类和子类之间的。当父类的功能无法满足子类的需求，可以在子类对方法进行重写</strong>。方法重写时， 方法名与形参列表必须一致。</p>
<p>如下代码，Person为父类，Student为子类，在Student中重写了dailyTask方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dailyTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;work eat sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dailyTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;study eat sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="34-接口与抽象类区别？"><a href="#34-接口与抽象类区别？" class="headerlink" title="34.接口与抽象类区别？"></a>34.接口与抽象类区别？</h2><p>1、<strong>语法层面</strong>上的区别</p>
<ul>
<li>抽象类可以有方法实现，而接口的方法中只能是抽象方法（Java 8 之后接口方法可以有默认实现）；</li>
<li>抽象类中的成员变量可以是各种类型的，接口中的成员变量只能是public static final类型；</li>
<li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法（Java 8之后接口可以有静态方法）；</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<p>2、<strong>设计层面</strong>上的区别</p>
<ul>
<li>抽象层次不同。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口只是对类行为进行抽象。继承抽象类是一种”是不是”的关系，而接口实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是具备不具备的关系，比如鸟是否能飞。</li>
<li>继承抽象类的是具有相似特点的类，而实现接口的却可以不同的类。</li>
</ul>
<p>门和警报的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AlarmDoor</span> <span class="keyword">extends</span> <span class="title class_">Door</span> <span class="keyword">implements</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMWCar</span> <span class="keyword">extends</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="35-常见的Exception有哪些？"><a href="#35-常见的Exception有哪些？" class="headerlink" title="35.常见的Exception有哪些？"></a>35.常见的Exception有哪些？</h2><p>常见的RuntimeException：</p>
<ol>
<li><code>ClassCastException</code> &#x2F;&#x2F;类型转换异常</li>
<li><code>IndexOutOfBoundsException</code> &#x2F;&#x2F;数组越界异常</li>
<li><code>NullPointerException</code> &#x2F;&#x2F;空指针</li>
<li><code>ArrayStoreException</code> &#x2F;&#x2F;数组存储异常</li>
<li><code>NumberFormatException</code> &#x2F;&#x2F;数字格式化异常</li>
<li><code>ArithmeticException</code> &#x2F;&#x2F;数学运算异常</li>
</ol>
<p>checked Exception：</p>
<ol>
<li><code>NoSuchFieldException</code> &#x2F;&#x2F;反射异常，没有对应的字段</li>
<li><code>ClassNotFoundException</code> &#x2F;&#x2F;类没有找到异常</li>
<li><code>IllegalAccessException</code> &#x2F;&#x2F;安全权限异常，可能是反射时调用了private方法</li>
</ol>
<h2 id="36-Error和Exception的区别？"><a href="#36-Error和Exception的区别？" class="headerlink" title="36.Error和Exception的区别？"></a>36.Error和Exception的区别？</h2><p><strong>Error</strong>：JVM 无法解决的严重问题，如栈溢出<code>StackOverflowError</code>、内存溢出<code>OOM</code>等。程序无法处理的错误。</p>
<p><strong>Exception</strong>：其它因编程错误或偶然的外在因素导致的一般性问题。可以在代码中进行处理。如：空指针异常、数组下标越界等。</p>
<h2 id="37-运行时异常和非运行时异常（checked）的区别？"><a href="#37-运行时异常和非运行时异常（checked）的区别？" class="headerlink" title="37.运行时异常和非运行时异常（checked）的区别？"></a>37.运行时异常和非运行时异常（checked）的区别？</h2><p><code>unchecked exception</code>包括<code>RuntimeException</code>和<code>Error</code>类，其他所有异常称为检查（checked）异常。</p>
<ol>
<li><code>RuntimeException</code>由程序错误导致，应该修正程序避免这类异常发生。</li>
<li><code>checked Exception</code>由具体的环境（读取的文件不存在或文件为空或sql异常）导致的异常。必须进行处理，不然编译不通过，可以catch或者throws。</li>
</ol>
<h2 id="38-throw和throws的区别？"><a href="#38-throw和throws的区别？" class="headerlink" title="38.throw和throws的区别？"></a>38.throw和throws的区别？</h2><ul>
<li><strong>throw</strong>：用于抛出一个具体的异常对象。</li>
<li><strong>throws</strong>：用在方法签名中，用于声明该方法可能抛出的异常。子类方法抛出的异常范围更加小，或者根本不抛异常。</li>
</ul>
<h2 id="39-通过故事讲清楚NIO"><a href="#39-通过故事讲清楚NIO" class="headerlink" title="39.通过故事讲清楚NIO"></a>39.通过故事讲清楚NIO</h2><p>下面通过一个例子来讲解下。</p>
<p>假设某银行只有10个职员。该银行的业务流程分为以下4个步骤：</p>
<p>1） 顾客填申请表（5分钟）；</p>
<p>2） 职员审核（1分钟）；</p>
<p>3） 职员叫保安去金库取钱（3分钟）；</p>
<p>4） 职员打印票据，并将钱和票据返回给顾客（1分钟）。</p>
<p>下面我们看看银行不同的工作方式对其工作效率到底有何影响。</p>
<p>首先是BIO方式。</p>
<p>每来一个顾客，马上由一位职员来接待处理，并且这个职员需要负责以上4个完整流程。当超过10个顾客时，剩余的顾客需要排队等候。</p>
<p>一个职员处理一个顾客需要10分钟（5+1+3+1）时间。一个小时（60分钟）能处理6个顾客，一共10个职员，那就是只能处理60个顾客。</p>
<p>可以看到银行职员的工作状态并不饱和，比如在第1步，其实是处于等待中。</p>
<p>这种工作其实就是BIO，每次来一个请求（顾客），就分配到线程池中由一个线程（职员）处理，如果超出了线程池的最大上限（10个），就扔到队列等待 。</p>
<p>那么如何提高银行的吞吐量呢？</p>
<p>思路就是：<strong>分而治之</strong>，将任务拆分开来，由专门的人负责专门的任务。</p>
<p>具体来讲，银行专门指派一名职员A，A的工作就是每当有顾客到银行，他就递上表格让顾客填写。每当有顾客填好表后，A就将其随机指派给剩余的9名职员完成后续步骤。</p>
<p>这种方式下，假设顾客非常多，职员A的工作处于饱和中，他不断的将填好表的顾客带到柜台处理。</p>
<p>柜台一个职员5分钟能处理完一个顾客，一个小时9名职员能处理：9*（60&#x2F;5）&#x3D;108。</p>
<p>可见工作方式的转变能带来效率的极大提升。</p>
<p>这种工作方式其实就NIO的思路。</p>
<p>下图是非常经典的NIO说明图，<code>mainReactor</code>线程负责监听server socket，接收新连接，并将建立的socket分派给<code>subReactor</code></p>
<p><code>subReactor</code>可以是一个线程，也可以是线程池，负责多路分离已连接的socket，读写网络数据。这里的读写网络数据可类比顾客填表这一耗时动作，对具体的业务处理功能，其扔给worker线程池完成</p>
<p>可以看到典型NIO有三类线程，分别是<code>mainReactor</code>线程、<code>subReactor</code>线程、<code>work</code>线程。</p>
<p>不同的线程干专业的事情，最终每个线程都没空着，系统的吞吐量自然就上去了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/20220423154450.png" alt="img"></p>
<p><strong>那这个流程还有没有什么可以提高的地方呢？</strong></p>
<p>可以看到，在这个业务流程里边第3个步骤，职员叫保安去金库取钱（3分钟）。这3分钟柜台职员是在等待中度过的，可以把这3分钟利用起来。</p>
<p>还是分而治之的思路，指派1个职员B来专门负责第3步骤。</p>
<p>每当柜台员工完成第2步时，就通知职员B来负责与保安沟通取钱。这时候柜台员工可以继续处理下一个顾客。</p>
<p>当职员B拿到钱之后，通知顾客钱已经到柜台了，让顾客重新排队处理，当柜台职员再次服务该顾客时，发现该顾客前3步已经完成，直接执行第4步即可。</p>
<p>在当今web服务中，经常需要通过RPC或者Http等方式调用第三方服务，这里对应的就是第3步，如果这步耗时较长，通过异步方式将能极大降低资源使用率。</p>
<p>NIO+异步的方式能让少量的线程做大量的事情。这适用于很多应用场景，比如代理服务、api服务、长连接服务等等。这些应用如果用同步方式将耗费大量机器资源。</p>
<p>不过虽然NIO+异步能提高系统吞吐量，但其并不能让一个请求的等待时间下降，相反可能会增加等待时间。</p>
<p>最后，NIO基本思想总结起来就是：<strong>分而治之，将任务拆分开来，由专门的人负责专门的任务</strong></p>
<h2 id="40-BIO-NIO-AIO区别的区别？"><a href="#40-BIO-NIO-AIO区别的区别？" class="headerlink" title="40.BIO&#x2F;NIO&#x2F;AIO区别的区别？"></a>40.BIO&#x2F;NIO&#x2F;AIO区别的区别？</h2><p><strong>同步阻塞IO</strong> : 用户进程发起一个IO操作以后，必须等待IO操作的真正完成后，才能继续运行。</p>
<p><strong>同步非阻塞IO</strong>: 客户端与服务器通过Channel连接，采用多路复用器轮询注册的<code>Channel</code>。提高吞吐量和可靠性。用户进程发起一个IO操作以后，可做其它事情，但用户进程需要轮询IO操作是否完成，这样造成不必要的CPU资源浪费。</p>
<p><strong>异步非阻塞IO</strong>: 非阻塞异步通信模式，NIO的升级版，采用异步通道实现异步通信，其read和write方法均是异步方法。用户进程发起一个IO操作，然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知。类似Future模式。</p>
<h2 id="41-守护线程是什么？"><a href="#41-守护线程是什么？" class="headerlink" title="41.守护线程是什么？"></a>41.守护线程是什么？</h2><ul>
<li>守护线程是运行在后台的一种特殊进程。</li>
<li>它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。</li>
<li>在 Java 中垃圾回收线程就是特殊的守护线程。</li>
</ul>
<h2 id="42-Java支持多继承吗？"><a href="#42-Java支持多继承吗？" class="headerlink" title="42.Java支持多继承吗？"></a>42.Java支持多继承吗？</h2><p>java中，<strong>类不支持</strong>多继承。<strong>接口才支持</strong>多继承。接口的作用是拓展对象功能。当一个子接口继承了多个父接口时，说明子接口拓展了多个功能。当一个类实现该接口时，就拓展了多个的功能。</p>
<p>Java不支持多继承的原因：</p>
<ul>
<li>出于安全性的考虑，如果子类继承的多个父类里面有相同的方法或者属性，子类将不知道具体要继承哪个。</li>
<li>Java提供了接口和内部类以达到实现多继承功能，弥补单继承的缺陷。</li>
</ul>
<h2 id="43-如何实现对象克隆？"><a href="#43-如何实现对象克隆？" class="headerlink" title="43.如何实现对象克隆？"></a>43.如何实现对象克隆？</h2><ul>
<li>实现<code>Cloneable</code>接口，重写 <code>clone()</code> 方法。这种方式是浅拷贝，即如果类中属性有自定义引用类型，只拷贝引用，不拷贝引用指向的对象。如果对象的属性的Class也实现 <code>Cloneable</code> 接口，那么在克隆对象时也会克隆属性，即深拷贝。</li>
<li>结合序列化，深拷贝。</li>
<li>通过<code>org.apache.commons</code>中的工具类<code>BeanUtils</code>和<code>PropertyUtils</code>进行对象复制。</li>
</ul>
<h2 id="44-同步和异步的区别？"><a href="#44-同步和异步的区别？" class="headerlink" title="44.同步和异步的区别？"></a>44.同步和异步的区别？</h2><p>同步：发出一个调用时，在没有得到结果之前，该调用就不返回。</p>
<p>异步：在调用发出后，被调用者返回结果之后会通知调用者，或通过回调函数处理这个调用。</p>
<h2 id="45-阻塞和非阻塞的区别？"><a href="#45-阻塞和非阻塞的区别？" class="headerlink" title="45.阻塞和非阻塞的区别？"></a>45.阻塞和非阻塞的区别？</h2><p>阻塞和非阻塞关注的是线程的状态。</p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会恢复运行。</p>
<p>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<blockquote>
<p>举个例子，理解下同步、阻塞、异步、非阻塞的区别：</p>
<p>同步就是烧开水，要自己来看开没开；异步就是水开了，然后水壶响了通知你水开了（回调通知）。阻塞是烧开水的过程中，你不能干其他事情，必须在旁边等着；非阻塞是烧开水的过程里可以干其他事情。</p>
</blockquote>
<h2 id="46-Java8的新特性有哪些？"><a href="#46-Java8的新特性有哪些？" class="headerlink" title="46.Java8的新特性有哪些？"></a>46.Java8的新特性有哪些？</h2><ul>
<li>Lambda 表达式：Lambda允许把函数作为一个方法的参数</li>
<li>Stream API ：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中</li>
<li>默认方法：默认方法就是一个在接口里面有了一个实现的方法。</li>
<li>Optional 类 ：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li>Date Time API ：加强对日期与时间的处理。</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/Tyson0314/Java-learning/blob/master/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7.md">Java8 新特性总结</a></p>
</blockquote>
<h2 id="47-序列化和反序列化"><a href="#47-序列化和反序列化" class="headerlink" title="47.序列化和反序列化"></a>47.序列化和反序列化</h2><ul>
<li>序列化：把对象转换为字节序列的过程称为对象的序列化.</li>
<li>反序列化：把字节序列恢复为对象的过程称为对象的反序列化.</li>
</ul>
<h2 id="48-什么时候需要用到序列化和反序列化呢"><a href="#48-什么时候需要用到序列化和反序列化呢" class="headerlink" title="48.什么时候需要用到序列化和反序列化呢?"></a>48.什么时候需要用到序列化和反序列化呢?</h2><p>当我们只在本地 JVM 里运行下 Java 实例，这个时候是不需要什么序列化和反序列化的，但当我们需要将内存中的对象持久化到磁盘，数据库中时，当我们需要与浏览器进行交互时，当我们需要实现 RPC 时，这个时候就需要序列化和反序列化了.</p>
<p>前两个需要用到序列化和反序列化的场景，是不是让我们有一个很大的疑问? 我们在与浏览器交互时，还有将内存中的对象持久化到数据库中时，好像都没有去进行序列化和反序列化，因为我们都没有实现 Serializable 接口，但一直正常运行.</p>
<p>下面先给出结论:</p>
<p><strong>只要我们对内存中的对象进行持久化或网络传输，这个时候都需要序列化和反序列化.</strong></p>
<p>理由:</p>
<p>服务器与浏览器交互时真的没有用到 Serializable 接口吗? JSON 格式实际上就是将一个对象转化为字符串，所以服务器与浏览器交互时的数据格式其实是字符串，我们来看来 String 类型的源码:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> final <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> java.<span class="property">io</span>.<span class="property">Serializable</span>，<span class="title class_">Comparable</span>&lt;<span class="title class_">String</span>&gt;，<span class="title class_">CharSequence</span> &#123;</span><br><span class="line">    <span class="regexp">/\*\* The value is used for character storage. \*/</span></span><br><span class="line">    <span class="keyword">private</span> final char value\[\];</span><br><span class="line"></span><br><span class="line">    <span class="regexp">/\*\* Cache the hash code for the string \*/</span></span><br><span class="line">    <span class="keyword">private</span> int hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="regexp">/\*\* use serialVersionUID from JDK 1.0.2 for interoperability \*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final long serialVersionUID = -6849794470754667710L;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String 类型实现了 Serializable 接口，并显示指定 serialVersionUID 的值.</p>
<p>然后我们再来看对象持久化到数据库中时的情况，Mybatis 数据库映射文件里的 insert 代码:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert <span class="built_in">id</span>=<span class="string">&quot;insertUser&quot;</span> parameterType=<span class="string">&quot;org.tyshawn.bean.User&quot;</span>&gt;</span><br><span class="line">    INSERT INTO t\_user(name，age) VALUES (<span class="comment">#&#123;name&#125;，#&#123;age&#125;)</span></span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<p>实际上我们并不是将整个对象持久化到数据库中，而是将对象中的属性持久化到数据库中，而这些属性（如Date&#x2F;String）都实现了 Serializable 接口。</p>
<h2 id="49-实现序列化和反序列化为什么要实现-Serializable-接口"><a href="#49-实现序列化和反序列化为什么要实现-Serializable-接口" class="headerlink" title="49.实现序列化和反序列化为什么要实现 Serializable 接口?"></a>49.实现序列化和反序列化为什么要实现 Serializable 接口?</h2><p>在 Java 中实现了 Serializable 接口后， JVM 在类加载的时候就会发现我们实现了这个接口，然后在初始化实例对象的时候就会在底层帮我们实现序列化和反序列化。</p>
<p>如果被写对象类型不是String、数组、Enum，并且没有实现Serializable接口，那么在进行序列化的时候，将抛出NotSerializableException。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remaining cases</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(</span><br><span class="line">            cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(cl.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="50-实现-Serializable-接口之后，为什么还要显示指定-serialVersionUID-的值"><a href="#50-实现-Serializable-接口之后，为什么还要显示指定-serialVersionUID-的值" class="headerlink" title="50.实现 Serializable 接口之后，为什么还要显示指定 serialVersionUID 的值?"></a>50.实现 Serializable 接口之后，为什么还要显示指定 serialVersionUID 的值?</h2><p>如果不显示指定 serialVersionUID，JVM 在序列化时会根据属性自动生成一个 serialVersionUID，然后与属性一起序列化，再进行持久化或网络传输. 在反序列化时，JVM 会再根据属性自动生成一个新版 serialVersionUID，然后将这个新版 serialVersionUID 与序列化时生成的旧版 serialVersionUID 进行比较，如果相同则反序列化成功，否则报错.</p>
<p>如果显示指定了 serialVersionUID，JVM 在序列化和反序列化时仍然都会生成一个 serialVersionUID，但值为我们显示指定的值，这样在反序列化时新旧版本的 serialVersionUID 就一致了.</p>
<p>如果我们的类写完后不再修改，那么不指定serialVersionUID，不会有问题，但这在实际开发中是不可能的，我们的类会不断迭代，一旦类被修改了，那旧对象反序列化就会报错。 所以在实际开发中，我们都会显示指定一个 serialVersionUID。</p>
<h2 id="51-static-属性为什么不会被序列化"><a href="#51-static-属性为什么不会被序列化" class="headerlink" title="51.static 属性为什么不会被序列化?"></a>51.static 属性为什么不会被序列化?</h2><p>因为序列化是针对对象而言的，而 static 属性优先于对象存在，随着类的加载而加载，所以不会被序列化.</p>
<p>看到这个结论，是不是有人会问，serialVersionUID 也被 static 修饰，为什么 serialVersionUID 会被序列化? 其实 serialVersionUID 属性并没有被序列化，JVM 在序列化对象时会自动生成一个 serialVersionUID，然后将我们显示指定的 serialVersionUID 属性值赋给自动生成的 serialVersionUID.</p>
<h2 id="52-transient关键字的作用？"><a href="#52-transient关键字的作用？" class="headerlink" title="52.transient关键字的作用？"></a>52.transient关键字的作用？</h2><p>Java语言的关键字，变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。</p>
<p>也就是说被transient修饰的成员变量，在序列化的时候其值会被忽略，在被反序列化后， transient 变量的值被设为初始值， 如 int 型的是 0，对象型的是 null。</p>
<h2 id="53-什么是反射？"><a href="#53-什么是反射？" class="headerlink" title="53.什么是反射？"></a>53.什么是反射？</h2><p>动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p>
<p>在运行状态中，对于任意一个类，能够知道这个类的所有属性和方法。对于任意一个对象，能够调用它的任意一个方法和属性。</p>
<h2 id="54-反射有哪些应用场景呢？"><a href="#54-反射有哪些应用场景呢？" class="headerlink" title="54.反射有哪些应用场景呢？"></a>54.反射有哪些应用场景呢？</h2><ol>
<li>JDBC连接数据库时使用<code>Class.forName()</code>通过反射加载数据库的驱动程序</li>
<li>Eclispe、IDEA等开发工具利用反射动态解析对象的类型与结构，动态提示对象的属性和方法</li>
<li>Web服务器中利用反射调用了Sevlet的<code>service</code>方法</li>
<li>JDK动态代理底层依赖反射实现</li>
</ol>
<h2 id="55-讲讲什么是泛型？"><a href="#55-讲讲什么是泛型？" class="headerlink" title="55.讲讲什么是泛型？"></a>55.讲讲什么是泛型？</h2><p>Java泛型是JDK 5中引⼊的⼀个新特性， 允许在定义类和接口的时候使⽤类型参数。声明的类型参数在使⽤时⽤具体的类型来替换。</p>
<p>泛型最⼤的好处是可以提⾼代码的复⽤性。以List接口为例，我们可以将String、 Integer等类型放⼊List中， 如不⽤泛型， 存放String类型要写⼀个List接口， 存放Integer要写另外⼀个List接口， 泛型可以很好的解决这个问题。</p>
<h2 id="56-如何停止一个正在运行的线程？"><a href="#56-如何停止一个正在运行的线程？" class="headerlink" title="56.如何停止一个正在运行的线程？"></a>56.如何停止一个正在运行的线程？</h2><p>有几种方式。</p>
<p>1、<strong>使用线程的stop方法</strong>。</p>
<p>使用stop()方法可以强制终止线程。不过stop是一个被废弃掉的方法，不推荐使用。</p>
<p>使用Stop方法，会一直向上传播ThreadDeath异常，从而使得目标线程解锁所有锁住的监视器，即释放掉所有的对象锁。使得之前被锁住的对象得不到同步的处理，因此可能会造成数据不一致的问题。</p>
<p>2、<strong>使用interrupt方法中断线程</strong>，该方法只是告诉线程要终止，但最终何时终止取决于计算机。调用interrupt方法仅仅是在当前线程中打了一个停止的标记，并不是真的停止线程。</p>
<p>接着调用 Thread.currentThread().isInterrupted()方法，可以用来判断当前线程是否被终止，通过这个判断我们可以做一些业务逻辑处理，通常如果isInterrupted返回true的话，会抛一个中断异常，然后通过try-catch捕获。</p>
<p>3、<strong>设置标志位</strong></p>
<p>设置标志位，当标识位为某个值时，使线程正常退出。设置标志位是用到了共享变量的方式，为了保证共享变量在内存中的可见性，可以使用volatile修饰它，这样的话，变量取值始终会从主存中获取最新值。</p>
<p>但是这种volatile标记共享变量的方式，在线程发生阻塞时是无法完成响应的。比如调用Thread.sleep() 方法之后，线程处于不可运行状态，即便是主线程修改了共享变量的值，该线程此时根本无法检查循环标志，所以也就无法实现线程中断。</p>
<p>因此，interrupt() 加上手动抛异常的方式是目前中断一个正在运行的线程<strong>最为正确</strong>的方式了。</p>
<h2 id="57-什么是跨域？"><a href="#57-什么是跨域？" class="headerlink" title="57.什么是跨域？"></a>57.什么是跨域？</h2><p>简单来讲，跨域是指从一个域名的网页去请求另一个域名的资源。由于有<strong>同源策略</strong>的关系，一般是不允许这么直接访问的。但是，很多场景经常会有跨域访问的需求，比如，在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域问题。</p>
<p><strong>那什么是同源策略呢</strong>？</p>
<p>所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p>同源策略限制以下几种行为：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. Cookie、LocalStorage 和 IndexDB 无法读取</span><br><span class="line"><span class="number">2</span>. DOM 和 <span class="keyword">Js对象无法获得</span></span><br><span class="line"><span class="keyword"></span><span class="number">3</span>. AJAX 请求不能发送</span><br></pre></td></tr></table></figure>

<p><strong>为什么要有同源策略</strong>？</p>
<p>举个例子，假如你刚刚在网银输入账号密码，查看了自己的余额，然后再去访问其他带颜色的网站，这个网站可以访问刚刚的网银站点，并且获取账号密码，那后果可想而知。因此，从安全的角度来讲，同源策略是有利于保护网站信息的。</p>
<h2 id="58-跨域问题怎么解决呢？"><a href="#58-跨域问题怎么解决呢？" class="headerlink" title="58.跨域问题怎么解决呢？"></a>58.跨域问题怎么解决呢？</h2><p>嗯，有以下几种方法：</p>
<p><strong>CORS</strong>，跨域资源共享</p>
<p>CORS（Cross-origin resource sharing），跨域资源共享。CORS 其实是浏览器制定的一个规范，浏览器会自动进行 CORS 通信，它的实现主要在服务端，通过一些 HTTP Header 来限制可以访问的域，例如页面 A 需要访问 B 服务器上的数据，如果 B 服务器 上声明了允许 A 的域名访问，那么从 A 到 B 的跨域请求就可以完成。</p>
<p><strong>@CrossOrigin注解</strong></p>
<p>如果项目使用的是Springboot，可以在Controller类上添加一个 @CrossOrigin(origins &#x3D;”*”) 注解就可以实现对当前controller 的跨域访问了，当然这个标签也可以加到方法上，或者直接加到入口类上对所有接口进行跨域处理。注意SpringMVC的版本要在4.2或以上版本才支持@CrossOrigin。</p>
<p><strong>nginx反向代理接口跨域</strong></p>
<p>nginx反向代理跨域原理如下： 首先同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p>
<p>nginx反向代理接口跨域实现思路如下：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proxy服务器</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">81</span>;</span><br><span class="line">    server_name  www.<span class="property">domain1</span>.<span class="property">com</span>;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   <span class="attr">http</span>:<span class="comment">//www.domain2.com:8080;  #反向代理</span></span><br><span class="line">        proxy_cookie_domain www.<span class="property">domain2</span>.<span class="property">com</span> www.<span class="property">domain1</span>.<span class="property">com</span>; #修改cookie里域名</span><br><span class="line">        index  index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">        </span><br><span class="line">        add_header <span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span> <span class="attr">http</span>:<span class="comment">//www.domain1.com;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的前端代理只要访问 http:<a target="_blank" rel="noopener" href="http://www.domain1.com:81/*%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%E3%80%82">www.domain1.com:81/*就可以了。</a></p>
<p><strong>通过jsonp跨域</strong></p>
<p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，这是浏览器允许的操作，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p>
<h2 id="59-设计接口要注意什么"><a href="#59-设计接口要注意什么" class="headerlink" title="59.设计接口要注意什么?"></a>59.设计接口要注意什么?</h2><ol>
<li><strong>接口参数校验</strong>。接口必须校验参数，比如入参是否允许为空，入参长度是否符合预期。</li>
<li>设计接口时，充分考虑接口的<strong>可扩展性</strong>。思考接口是否可以复用，怎样保持接口的可扩展性。</li>
<li><strong>串行调用考虑改并行调用</strong>。比如设计一个商城首页接口，需要查商品信息、营销信息、用户信息等等。如果是串行一个一个查，那耗时就比较大了。这种场景是可以改为并行调用的，降低接口耗时。</li>
<li>接口是否需要<strong>防重</strong>处理。涉及到数据库修改的，要考虑防重处理，可以使用数据库防重表，以唯一流水号作为唯一索引。</li>
<li><strong>日志打印全面</strong>，入参出参，接口耗时，记录好日志，方便甩锅。</li>
<li>修改旧接口时，注意<strong>兼容性设计</strong>。</li>
<li><strong>异常处理得当</strong>。使用finally关闭流资源、使用log打印而不是e.printStackTrace()、不要吞异常等等</li>
<li>是否需要考虑<strong>限流</strong>。限流为了保护系统，防止流量洪峰超过系统的承载能力。</li>
</ol>
<h2 id="60-过滤器和拦截器有什么区别？"><a href="#60-过滤器和拦截器有什么区别？" class="headerlink" title="60.过滤器和拦截器有什么区别？"></a>60.过滤器和拦截器有什么区别？</h2><p>1、<strong>实现原理不同</strong>。</p>
<p>过滤器和拦截器底层实现不同。过滤器是基于函数回调的，拦截器是基于Java的反射机制（动态代理）实现的。一般自定义的过滤器中都会实现一个doFilter()方法，这个方法有一个FilterChain参数，而实际上它是一个回调接口。</p>
<p>2、<strong>使用范围不同</strong>。</p>
<p>过滤器实现的是 javax.servlet.Filter 接口，而这个接口是在Servlet规范中定义的，也就是说过滤器Filter的使用要依赖于Tomcat等容器，导致它只能在web程序中使用。而拦截器是一个Spring组件，并由Spring容器管理，并不依赖Tomcat等容器，是可以单独使用的。拦截器不仅能应用在web程序中，也可以用于Application、Swing等程序中。</p>
<p>3、<strong>使用的场景不同</strong>。</p>
<p>因为拦截器更接近业务系统，所以拦截器主要用来实现项目中的业务判断的，比如：日志记录、权限判断等业务。而过滤器通常是用来实现通用功能过滤的，比如：敏感词过滤、响应数据压缩等功能。</p>
<p>4、<strong>触发时机不同</strong>。</p>
<p>过滤器Filter是在请求进入容器后，但在进入servlet之前进行预处理，请求结束是在servlet处理完以后。</p>
<p>拦截器 Interceptor 是在请求进入servlet后，在进入Controller之前进行预处理的，Controller 中渲染了对应的视图之后请求结束。</p>
<p>5、<strong>拦截的请求范围不同</strong>。</p>
<p>请求的执行顺序是：请求进入容器 -&gt; 进入过滤器 -&gt; 进入 Servlet -&gt; 进入拦截器 -&gt; 执行控制器。可以看到过滤器和拦截器的执行时机也是不同的，过滤器会先执行，然后才会执行拦截器，最后才会进入真正的要调用的方法。</p>
<blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022833940">https://segmentfault.com/a/1190000022833940</a></p>
</blockquote>
<h2 id="61-对接第三方接口要考虑什么？"><a href="#61-对接第三方接口要考虑什么？" class="headerlink" title="61.对接第三方接口要考虑什么？"></a>61.对接第三方接口要考虑什么？</h2><p>嗯，需要考虑以下几点：</p>
<ol>
<li>确认接口对接的<strong>网络协议</strong>，是https&#x2F;http或者自定义的私有协议等。</li>
<li>约定好<strong>数据传参、响应格式</strong>（如application&#x2F;json），弱类型对接强类型语言时要特别注意</li>
<li><strong>接口安全</strong>方面，要确定身份校验方式，使用token、证书校验等</li>
<li>确认是否需要接口调用失败后的<strong>重试</strong>机制，保证数据传输的最终一致性。</li>
<li><strong>日志记录要全面</strong>。接口出入参数，以及解析之后的参数值，都要用日志记录下来，方便定位问题（甩锅）。</li>
</ol>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/gzt19881123/article/details/108791034">https://blog.csdn.net/gzt19881123/article/details/108791034</a></p>
<h2 id="62-后端接口性能优化有哪些方法？"><a href="#62-后端接口性能优化有哪些方法？" class="headerlink" title="62.后端接口性能优化有哪些方法？"></a>62.后端接口性能优化有哪些方法？</h2><p>有以下这些方法：</p>
<p>1、<strong>优化索引</strong>。给where条件的关键字段，或者<code>order by</code>后面的排序字段，加索引。</p>
<p>2、<strong>优化sql语句</strong>。比如避免使用select *、批量操作、避免深分页、提升group by的效率等</p>
<p>3、<strong>避免大事务</strong>。使用@Transactional注解这种声明式事务的方式提供事务功能，容易造成大事务，引发其他的问题。应该避免在事务中一次性处理太多数据，将一些跟事务无关的逻辑放到事务外面执行。</p>
<p>4、<strong>异步处理</strong>。剥离主逻辑和副逻辑，副逻辑可以异步执行，异步写库。比如用户购买的商品发货了，需要发短信通知，短信通知是副流程，可以异步执行，以免影响主流程的执行。</p>
<p>5、<strong>降低锁粒度</strong>。在并发场景下，多个线程同时修改数据，造成数据不一致的情况。这种情况下，一般会加锁解决。但如果锁加得不好，导致锁的粒度太粗，也会非常影响接口性能。</p>
<p>6、<strong>加缓存</strong>。如果表数据量非常大的话，直接从数据库查询数据，性能会非常差。可以使用Redis<code>和</code>memcached提升查询性能，从而提高接口性能。</p>
<p>7、<strong>分库分表</strong>。当系统发展到一定的阶段，用户并发量大，会有大量的数据库请求，需要占用大量的数据库连接，同时会带来磁盘IO的性能瓶颈问题。或者数据库表数据非常大，SQL查询即使走了索引，也很耗时。这时，可以通过分库分表解决。分库用于解决数据库连接资源不足问题，和磁盘IO的性能瓶颈问题。分表用于解决单表数据量太大，sql语句查询数据时，即使走了索引也非常耗时问题。</p>
<p>8、<strong>避免在循环中查询数据库</strong>。循环查询数据库，非常耗时，最好能在一次查询中获取所有需要的数据。</p>
<h2 id="63-为什么在阿里巴巴Java开发手册中强制要求使用包装类型定义属性呢？"><a href="#63-为什么在阿里巴巴Java开发手册中强制要求使用包装类型定义属性呢？" class="headerlink" title="63.为什么在阿里巴巴Java开发手册中强制要求使用包装类型定义属性呢？"></a>63.为什么在阿里巴巴Java开发手册中强制要求使用包装类型定义属性呢？</h2><p>嗯，以布尔字段为例，当我们没有设置对象的字段的值的时候，Boolean类型的变量会设置默认值为<code>null</code>，而boolean类型的变量会设置默认值为<code>false</code>。</p>
<p>也就是说，包装类型的默认值都是null，而基本数据类型的默认值是一个固定值，如boolean是false，byte、short、int、long是0，float是0.0f等。</p>
<p>举一个例子，比如有一个扣费系统，扣费时需要从外部的定价系统中读取一个费率的值，我们预期该接口的返回值中会包含一个浮点型的费率字段。当我们取到这个值得时候就使用公式：金额*费率&#x3D;费用 进行计算，计算结果进行划扣。</p>
<p>如果由于计费系统异常，他可能会返回个默认值，如果这个字段是Double类型的话，该默认值为null，如果该字段是double类型的话，该默认值为0.0。</p>
<p>如果扣费系统对于该费率返回值没做特殊处理的话，拿到null值进行计算会直接报错，阻断程序。拿到0.0可能就直接进行计算，得出接口为0后进行扣费了。这种异常情况就无法被感知。</p>
<p><strong>那我可以对0.0做特殊判断，如果是0就阻断报错，这样是否可以呢？</strong></p>
<p>不对，这时候就会产生一个问题，如果允许费率是0的场景又怎么处理呢？</p>
<p>使用基本数据类型只会让方案越来越复杂，坑越来越多。</p>
<p>这种使用包装类型定义变量的方式，通过异常来阻断程序，进而可以被识别到这种线上问题。如果使用基本数据类型的话，系统可能不会报错，进而认为无异常。</p>
<p>因此，建议在POJO和RPC的返回值中使用包装类型。</p>
<h2 id="64-8招让接口性能提升100倍"><a href="#64-8招让接口性能提升100倍" class="headerlink" title="64.8招让接口性能提升100倍"></a>64.8招让接口性能提升100倍</h2><p><strong>池化思想</strong></p>
<p>如果你每次需要用到线程，都去创建，就会有增加一定的耗时，而线程池可以重复利用线程，避免不必要的耗时。</p>
<p>比如<code>TCP</code>三次握手，它为了减少性能损耗，引入了<code>Keep-Alive长连接</code>，避免频繁的创建和销毁连接。</p>
<p><strong>拒绝阻塞等待</strong></p>
<p>如果你调用一个系统<code>B</code>的接口，但是它处理业务逻辑，耗时需要<code>10s</code>甚至更多。然后你是一直<strong>阻塞等待，直到系统B的下游接口返回</strong>，再继续你的下一步操作吗？这样<strong>显然不合理</strong>。</p>
<p>参考<strong>IO多路复用模型</strong>。即我们不用阻塞等待系统<code>B</code>的接口，而是先去做别的操作。等系统<code>B</code>的接口处理完，通过<strong>事件回调</strong>通知，我们接口收到通知再进行对应的业务操作即可。</p>
<p><strong>远程调用由串行改为并行</strong></p>
<p>比如设计一个商城首页接口，需要查商品信息、营销信息、用户信息等等。如果是串行一个一个查，那耗时就比较大了。这种场景是可以改为并行调用的，降低接口耗时。</p>
<p><strong>锁粒度避免过粗</strong></p>
<p>在高并发场景，为了防止<strong>超卖等情况</strong>，我们经常需要<strong>加锁来保护共享资源</strong>。但是，如果加锁的粒度过粗，是很影响接口性能的。</p>
<p>不管你是<code>synchronized</code>加锁还是<code>redis</code>分布式锁，只需要在共享临界资源加锁即可，不涉及共享资源的，就不必要加锁。</p>
<p><strong>耗时操作，考虑放到异步执行</strong></p>
<p>耗时操作，考虑用<strong>异步处理</strong>，这样可以降低接口耗时。比如用户注册成功后，短信邮件通知，是可以异步处理的。</p>
<p><strong>使用缓存</strong></p>
<p>把要查的数据，提前放好到缓存里面，需要时，<strong>直接查缓存，而避免去查数据库或者计算的过程</strong>。</p>
<p><strong>提前初始化到缓存</strong></p>
<p>预取思想很容易理解，就是<strong>提前把要计算查询的数据，初始化到缓存</strong>。如果你在未来某个时间需要用到某个经过复杂计算的数据，<strong>才实时去计算的话，可能耗时比较大</strong>。这时候，我们可以采取预取思想，<strong>提前把将来可能需要的数据计算好，放到缓存中</strong>，等需要的时候，去缓存取就行。这将大幅度提高接口性能。</p>
<p><strong>压缩传输内容</strong></p>
<p>压缩传输内容，传输报文变得更小，因此传输会更快。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="常见的集合有哪些？"><a href="#常见的集合有哪些？" class="headerlink" title="常见的集合有哪些？"></a>常见的集合有哪些？</h2><p>Java集合类主要由两个接口<strong>Collection</strong>和<strong>Map</strong>派生出来的，Collection有三个子接口：List、Set、Queue。</p>
<p>Java集合框架图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/collections.drawio.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/map.png" alt="img"></p>
<p>List代表了有序可重复集合，可直接根据元素的索引来访问；Set代表无序不可重复集合，只能根据元素本身来访问；Queue是队列集合。Map代表的是存储key-value对的集合，可根据元素的key来访问value。</p>
<p>集合体系中常用的实现类有<code>ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap</code>等实现类。</p>
<h2 id="List-、Set和Map-的区别"><a href="#List-、Set和Map-的区别" class="headerlink" title="List 、Set和Map 的区别"></a>List 、Set和Map 的区别</h2><ul>
<li>List 以索引来存取元素，有序的，元素是允许重复的，可以插入多个null；</li>
<li>Set 不能存放重复元素，无序的，只允许一个null；</li>
<li>Map 保存键值对映射；</li>
<li>List 底层实现有数组、链表两种方式；Set、Map 容器有基于哈希存储和红黑树两种方式实现；</li>
<li>Set 基于 Map 实现，Set 里的元素值就是 Map的键值。</li>
</ul>
<h2 id="ArrayList-了解吗？"><a href="#ArrayList-了解吗？" class="headerlink" title="ArrayList 了解吗？"></a>ArrayList 了解吗？</h2><p><code>ArrayList</code> 的底层是动态数组，它的容量能动态增长。在添加大量元素前，应用可以使用<code>ensureCapacity</code>操作增加 <code>ArrayList</code> 实例的容量。ArrayList 继承了 AbstractList ，并实现了 List 接口。</p>
<h2 id="ArrayList-的扩容机制？"><a href="#ArrayList-的扩容机制？" class="headerlink" title="ArrayList 的扩容机制？"></a>ArrayList 的扩容机制？</h2><p>ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。<strong>默认情况下，新的容量会是原容量的1.5倍</strong>。以JDK1.8为例说明:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否可以容纳e，若能，则直接添加在末尾；若不能，则进行扩容，然后再把e添加在末尾</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//将e添加到数组末尾</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次在add()一个元素时，arraylist都需要对这个list的容量进行一个判断。通过ensureCapacityInternal()方法确保当前ArrayList维护的数组具有存储新元素的能力，经过处理之后将元素存储在数组elementData的尾部</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">      ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//如果传入的是个空数组则最小容量取默认容量与minCapacity之间的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// 若ArrayList已有的存储能力满足最低存储要求，则返回add直接添加元素；如果最低要求的存储能力&gt;ArrayList已有的存储能力，这就表示ArrayList的存储能力不足，因此需要调用 grow();方法进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取elementData数组的内存空间长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">// 扩容至原来的1.5倍</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//校验容量是否够</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//若预设值大于默认的最大值，检查是否溢出</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// 调用Arrays.copyOf方法将elementData数组指向新的内存空间</span></span><br><span class="line">         <span class="comment">//并将elementData的数据复制到新的内存空间</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="怎么在遍历-ArrayList-时移除一个元素？"><a href="#怎么在遍历-ArrayList-时移除一个元素？" class="headerlink" title="怎么在遍历 ArrayList 时移除一个元素？"></a>怎么在遍历 ArrayList 时移除一个元素？</h2><p>foreach删除会导致快速失败问题，可以使用迭代器的 remove() 方法。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator itr = list.iterator();</span><br><span class="line">while(itr.hasNext()) &#123;</span><br><span class="line">      if(itr.next().equals(&quot;jay&quot;) &#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Arraylist-和-Vector-的区别"><a href="#Arraylist-和-Vector-的区别" class="headerlink" title="Arraylist 和 Vector 的区别"></a>Arraylist 和 Vector 的区别</h2><ol>
<li>ArrayList在内存不够时扩容为原来的1.5倍，Vector是扩容为原来的2倍。</li>
<li>Vector属于线程安全级别的，但是大多数情况下不使用Vector，因为操作Vector效率比较低。</li>
</ol>
<h2 id="Arraylist-与-LinkedList的区别"><a href="#Arraylist-与-LinkedList的区别" class="headerlink" title="Arraylist 与 LinkedList的区别"></a>Arraylist 与 LinkedList的区别</h2><ol>
<li>ArrayList基于动态数组实现；LinkedList基于链表实现。</li>
<li>对于随机index访问的get和set方法，ArrayList的速度要优于LinkedList。因为ArrayList直接通过数组下标直接找到元素；LinkedList要移动指针遍历每个元素直到找到为止。</li>
<li>新增和删除元素，LinkedList的速度要优于ArrayList。因为ArrayList在新增和删除元素时，可能扩容和复制数组；LinkedList实例化对象需要时间外，只需要修改指针即可。</li>
</ol>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap 使用数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的， 链表长度大于8（<code>TREEIFY_THRESHOLD</code>）时，会把链表转换为红黑树，红黑树节点个数小于6（<code>UNTREEIFY_THRESHOLD</code>）时才转化为链表，防止频繁的转化。</p>
<h3 id="解决hash冲突的办法有哪些？HashMap用的哪种？"><a href="#解决hash冲突的办法有哪些？HashMap用的哪种？" class="headerlink" title="解决hash冲突的办法有哪些？HashMap用的哪种？"></a>解决hash冲突的办法有哪些？HashMap用的哪种？</h3><p>解决Hash冲突方法有：开放定址法、再哈希法、链地址法。HashMap中采用的是 链地址法 。</p>
<ul>
<li>开放定址法基本思想就是，如果<code>p=H(key)</code>出现冲突时，则以<code>p</code>为基础，再次hash，<code>p1=H(p)</code>,如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址<code>pi</code>。 因此开放定址法所需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以<code>只能在删除的节点上做标记，而不能真正删除节点。</code></li>
<li>再哈希法提供多个不同的hash函数，当<code>R1=H1(key1)</code>发生冲突时，再计算<code>R2=H2(key1)</code>，直到没有冲突为止。 这样做虽然不易产生堆集，但增加了计算的时间。</li>
<li>链地址法将哈希值相同的元素构成一个同义词的单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。</li>
</ul>
<h3 id="使用的hash算法？"><a href="#使用的hash算法？" class="headerlink" title="使用的hash算法？"></a>使用的hash算法？</h3><p>Hash算法：取key的hashCode值、高位运算、取模运算。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h=key.hashCode() //第一步 取hashCode值</span><br><span class="line">h^(h&gt;&gt;&gt;16)  //第二步 高位参与运算，减少冲突</span><br><span class="line">return h&amp;(length-1);  //第三步 取模运算</span><br></pre></td></tr></table></figure>

<p>在JDK1.8的实现中，优化了高位运算的算法，通过<code>hashCode()</code>的高16位异或低16位实现的：这么做可以在数组比较小的时候，也能保证考虑到高低位都参与到Hash的计算中，可以减少冲突，同时不会有太大的开销。</p>
<h3 id="为什么建议设置HashMap的容量？"><a href="#为什么建议设置HashMap的容量？" class="headerlink" title="为什么建议设置HashMap的容量？"></a>为什么建议设置HashMap的容量？</h3><p>HashMap有扩容机制，就是当达到扩容条件时会进行扩容。扩容条件就是当HashMap中的元素个数超过临界值时就会自动扩容（threshold &#x3D; loadFactor * capacity）。</p>
<p>如果我们没有设置初始容量大小，随着元素的不断增加，HashMap会发生多次扩容。而HashMap每次扩容都需要重建hash表，非常影响性能。所以建议开发者在创建HashMap的时候指定初始化容量。</p>
<h3 id="扩容过程？"><a href="#扩容过程？" class="headerlink" title="扩容过程？"></a>扩容过程？</h3><p>1.8扩容机制：当元素个数大于<code>threshold</code>时，会进行扩容，使用2倍容量的数组代替原有数组。采用尾插入的方式将原数组元素拷贝到新数组。1.8扩容之后链表元素相对位置没有变化，而1.7扩容之后链表元素会倒置。</p>
<p>1.7链表新节点采用的是头插法，这样在线程一扩容迁移元素时，会将元素顺序改变，导致两个线程中出现元素的相互指向而形成循环链表，1.8采用了尾插法，避免了这种情况的发生。</p>
<p>原数组的元素在重新计算hash之后，因为数组容量n变为2倍，那么n-1的mask范围在高位多1bit。在元素拷贝过程不需要重新计算元素在数组中的位置，只需要看看原来的hash值新增的那个bit是1还是0，是0的话索引没变，是1的话索引变成“原索引+oldCap”（根据<code>e.hash &amp; oldCap == 0</code>判断） 。这样可以省去重新计算hash值的时间，而且由于新增的1bit是0还是1可以认为是随机的，因此resize的过程会均匀的把之前的冲突的节点分散到新的bucket。</p>
<h3 id="put方法流程？"><a href="#put方法流程？" class="headerlink" title="put方法流程？"></a>put方法流程？</h3><ol>
<li>如果table没有初始化就先进行初始化过程</li>
<li>使用hash算法计算key的索引</li>
<li>判断索引处有没有存在元素，没有就直接插入</li>
<li>如果索引处存在元素，则遍历插入，有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入</li>
<li>链表的数量大于阈值8，就要转换成红黑树的结构</li>
<li>添加成功后会检查是否需要扩容</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/map_put.png" alt="img"></p>
<h3 id="红黑树的特点？"><a href="#红黑树的特点？" class="headerlink" title="红黑树的特点？"></a>红黑树的特点？</h3><ul>
<li>每个节点或者是黑色，或者是红色。</li>
<li>根节点和叶子节点（<code>NIL</code>）是黑色的。</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
</ul>
<h3 id="在解决-hash-冲突的时候，为什么选择先用链表，再转红黑树"><a href="#在解决-hash-冲突的时候，为什么选择先用链表，再转红黑树" class="headerlink" title="在解决 hash 冲突的时候，为什么选择先用链表，再转红黑树?"></a>在解决 hash 冲突的时候，为什么选择先用链表，再转红黑树?</h3><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。所以，当元素个数小于8个的时候，采用链表结构可以保证查询性能。而当元素个数大于8个的时候并且数组容量大于等于64，会采用红黑树结构。因为红黑树搜索时间复杂度是 <code>O(logn)</code>，而链表是 <code>O(n)</code>，在n比较大的时候，使用红黑树可以加快查询速度。</p>
<h3 id="HashMap-的长度为什么是-2-的幂次方？"><a href="#HashMap-的长度为什么是-2-的幂次方？" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方？"></a>HashMap 的长度为什么是 2 的幂次方？</h3><p>Hash 值的范围值比较大，使用之前需要先对数组的长度取模运算，得到的余数才是元素存放的位置也就是对应的数组下标。这个数组下标的计算方法是<code>(n - 1) &amp; hash</code>。将HashMap的长度定为2 的幂次方，这样就可以使用<code>(n - 1)&amp;hash</code>位运算代替%取余的操作，提高性能。</p>
<h3 id="HashMap默认加载因子是多少？为什么是-0-75？"><a href="#HashMap默认加载因子是多少？为什么是-0-75？" class="headerlink" title="HashMap默认加载因子是多少？为什么是 0.75？"></a>HashMap默认加载因子是多少？为什么是 0.75？</h3><p>先看下HashMap的默认构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> threshold;             <span class="comment">// 容纳键值对的最大值</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line"><span class="type">int</span> modCount;  </span><br><span class="line"><span class="type">int</span> size;  </span><br></pre></td></tr></table></figure>

<p>Node[] table的初始化长度length为16，默认的loadFactor是0.75，0.75是对空间和时间效率的一个平衡选择，根据泊松分布，loadFactor 取0.75碰撞最小。一般不会修改，除非在时间和空间比较特殊的情况下 ：</p>
<ul>
<li>如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值 。</li>
<li>如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</li>
</ul>
<h3 id="一般用什么作为HashMap的key"><a href="#一般用什么作为HashMap的key" class="headerlink" title="一般用什么作为HashMap的key?"></a>一般用什么作为HashMap的key?</h3><p>一般用<code>Integer</code>、<code>String</code>这种不可变类当 HashMap 当 key。String类比较常用。</p>
<ul>
<li>因为 String 是不可变的，所以在它创建的时候&#96;hashcode&#96;&#96;就被缓存了，不需要重新计算。这就是 HashMap 中的key经常使用字符串的原因。</li>
<li>获取对象的时候要用到 <code>equals()</code> 和 <code>hashCode()</code> 方法，而Integer、String这些类都已经重写了 <code>hashCode()</code> 以及 <code>equals()</code> 方法，不需要自己去重写这两个方法。</li>
</ul>
<h3 id="HashMap为什么线程不安全？"><a href="#HashMap为什么线程不安全？" class="headerlink" title="HashMap为什么线程不安全？"></a>HashMap为什么线程不安全？</h3><ul>
<li>多线程下扩容死循环。JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致<strong>环形链表</strong>的出现，形成死循环。</li>
<li>在JDK1.8中，在多线程环境下，会发生<strong>数据覆盖</strong>的情况。</li>
</ul>
<h3 id="HashMap和HashTable的区别？"><a href="#HashMap和HashTable的区别？" class="headerlink" title="HashMap和HashTable的区别？"></a>HashMap和HashTable的区别？</h3><p>HashMap和Hashtable都实现了Map接口。</p>
<ol>
<li>HashMap可以接受为null的key和value，key为null的键值对放在下标为0的头结点的链表中，而Hashtable则不行。</li>
<li>HashMap是非线程安全的，HashTable是线程安全的。Jdk1.5提供了ConcurrentHashMap，它是HashTable的替代。</li>
<li>Hashtable很多方法是同步方法，在单线程环境下它比HashMap要慢。</li>
<li>哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</li>
</ol>
<h2 id="LinkedHashMap底层原理？"><a href="#LinkedHashMap底层原理？" class="headerlink" title="LinkedHashMap底层原理？"></a>LinkedHashMap底层原理？</h2><p>HashMap是无序的，迭代HashMap所得到元素的顺序并不是它们最初放到HashMap的顺序，即不能保持它们的插入顺序。</p>
<p>LinkedHashMap继承于HashMap，是HashMap和LinkedList的融合体，具备两者的特性。每次put操作都会将entry插入到双向链表的尾部。</p>
<h2 id="讲一下TreeMap？"><a href="#讲一下TreeMap？" class="headerlink" title="讲一下TreeMap？"></a>讲一下TreeMap？</h2><p>TreeMap是一个能比较元素大小的Map集合，会对传入的key进行了大小排序。可以使用元素的自然顺序，也可以使用集合中自定义的比较器来进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeMap 的继承结构：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/image-20210905215046510.png" alt="img"></p>
<p><strong>TreeMap的特点：</strong></p>
<ol>
<li>TreeMap是有序的key-value集合，通过红黑树实现。根据键的自然顺序进行排序或根据提供的Comparator进行排序。</li>
<li>TreeMap继承了AbstractMap，实现了NavigableMap接口，支持一系列的导航方法，给定具体搜索目标，可以返回最接近的匹配项。如floorEntry()、ceilingEntry()分别返回小于等于、大于等于给定键关联的Map.Entry()对象，不存在则返回null。lowerKey()、floorKey、ceilingKey、higherKey()只返回关联的key。</li>
</ol>
<h2 id="HashSet底层原理？"><a href="#HashSet底层原理？" class="headerlink" title="HashSet底层原理？"></a>HashSet底层原理？</h2><p>HashSet 基于 HashMap 实现。放入HashSet中的元素实际上由HashMap的key来保存，而HashMap的value则存储了一个静态的Object对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5024744406713321676L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map; <span class="comment">//基于HashMap实现</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashSet、LinkedHashSet-和-TreeSet-的区别？"><a href="#HashSet、LinkedHashSet-和-TreeSet-的区别？" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 的区别？"></a>HashSet、LinkedHashSet 和 TreeSet 的区别？</h2><p><code>HashSet</code> 是 <code>Set</code> 接口的主要实现类 ，<code>HashSet</code> 的底层是 <code>HashMap</code>，线程不安全的，可以存储 null 值；</p>
<p><code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，能够按照添加的顺序遍历；</p>
<p><code>TreeSet</code> 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式可以自定义。</p>
<h2 id="什么是fail-fast？"><a href="#什么是fail-fast？" class="headerlink" title="什么是fail fast？"></a>什么是fail fast？</h2><p>fast-fail是Java集合的一种错误机制。当多个线程对同一个集合进行操作时，就有可能会产生fast-fail事件。例如：当线程a正通过iterator遍历集合时，另一个线程b修改了集合的内容，此时modCount（记录集合操作过程的修改次数）会加1，不等于expectedModCount，那么线程a访问集合的时候，就会抛出ConcurrentModificationException，产生fast-fail事件。边遍历边修改集合也会产生fast-fail事件。</p>
<p>解决方法：</p>
<ul>
<li>使用Colletions.synchronizedList方法或在修改集合内容的地方加上synchronized。这样的话，增删集合内容的同步锁会阻塞遍历操作，影响性能。</li>
<li>使用CopyOnWriteArrayList来替换ArrayList。在对CopyOnWriteArrayList进行修改操作的时候，会拷贝一个新的数组，对新的数组进行操作，操作完成后再把引用移到新的数组。</li>
</ul>
<h2 id="什么是fail-safe？"><a href="#什么是fail-safe？" class="headerlink" title="什么是fail safe？"></a>什么是fail safe？</h2><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
<p><strong>原理</strong>：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p>
<p><strong>缺点</strong>：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p>
<h2 id="讲一下ArrayDeque？"><a href="#讲一下ArrayDeque？" class="headerlink" title="讲一下ArrayDeque？"></a>讲一下ArrayDeque？</h2><p>ArrayDeque实现了双端队列，内部使用循环数组实现，默认大小为16。它的特点有：</p>
<ol>
<li>在两端添加、删除元素的效率较高</li>
<li>根据元素内容查找和删除的效率比较低。</li>
<li>没有索引位置的概念，不能根据索引位置进行操作。</li>
</ol>
<p>ArrayDeque和LinkedList都实现了Deque接口，如果只需要从两端进行操作，ArrayDeque效率更高一些。如果同时需要根据索引位置进行操作，或者经常需要在中间进行插入和删除（LinkedList有相应的 api，如add(int index, E e)），则应该选LinkedList。</p>
<p>ArrayDeque和LinkedList都是线程不安全的，可以使用Collections工具类中synchronizedXxx()转换成线程同步。</p>
<h2 id="哪些集合类是线程安全的？哪些不安全？"><a href="#哪些集合类是线程安全的？哪些不安全？" class="headerlink" title="哪些集合类是线程安全的？哪些不安全？"></a>哪些集合类是线程安全的？哪些不安全？</h2><p>线性安全的集合类：</p>
<ul>
<li>Vector：比ArrayList多了同步机制。</li>
<li>Hashtable。</li>
<li>ConcurrentHashMap：是一种高效并且线程安全的集合。</li>
<li>Stack：栈，也是线程安全的，继承于Vector。</li>
</ul>
<p>线性不安全的集合类：</p>
<ul>
<li>Hashmap</li>
<li>Arraylist</li>
<li>LinkedList</li>
<li>HashSet</li>
<li>TreeSet</li>
<li>TreeMap</li>
</ul>
<h2 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h2><p>Iterator模式用同一种逻辑来遍历集合。它可以把访问逻辑从不同类型的集合类中抽象出来，不需要了解集合内部实现便可以遍历集合元素，统一使用 Iterator 提供的接口去遍历。它的特点是更加安全，因为它可以保证，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">	Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要有三个方法：hasNext()、next()和remove()。</p>
<h2 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h2><p>ListIterator 是 Iterator的增强版。</p>
<ul>
<li>ListIterator遍历可以是逆向的，因为有previous()和hasPrevious()方法，而Iterator不可以。</li>
<li>ListIterator有add()方法，可以向List添加对象，而Iterator却不能。</li>
<li>ListIterator可以定位当前的索引位置，因为有nextIndex()和previousIndex()方法，而Iterator不可以。</li>
<li>ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。</li>
<li>ListIterator只能用于遍历List及其子类，Iterator可用来遍历所有集合。</li>
</ul>
<h2 id="如何让一个集合不能被修改？"><a href="#如何让一个集合不能被修改？" class="headerlink" title="如何让一个集合不能被修改？"></a>如何让一个集合不能被修改？</h2><p>可以采用Collections包下的unmodifiableMap&#x2F;unmodifiableList&#x2F;unmodifiableSet方法，通过这个方法返回的集合，是不可以修改的。如果修改的话，会抛出 java.lang.UnsupportedOperationException异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections.unmodifiableCollection(list);</span><br><span class="line">clist.add(<span class="string">&quot;y&quot;</span>); <span class="comment">// 运行时此行报错</span></span><br><span class="line">System.out.println(list. size());</span><br></pre></td></tr></table></figure>

<p>对于List&#x2F;Set&#x2F;Map集合，Collections包都有相应的支持。</p>
<p><strong>那使用final关键字进行修饰可以实现吗？</strong></p>
<p>答案是不可以。</p>
<p>final关键字修饰的成员变量如果是是引用类型的话，则表示这个引用的地址值是不能改变的，但是这个引用所指向的对象里面的内容还是可以改变的。</p>
<p>而集合类都是引用类型，用final修饰的话，集合里面的内容还是可以修改的。</p>
<h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>JDK 提供的这些容器大部分在 <code>java.util.concurrent</code> 包中。</p>
<ul>
<li><strong>ConcurrentHashMap:</strong> 线程安全的 HashMap</li>
<li><strong>CopyOnWriteArrayList:</strong> 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector.</li>
<li><strong>ConcurrentLinkedQueue:</strong> 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。</li>
<li><strong>BlockingQueue:</strong> 阻塞队列接口，JDK 内部通过链表、数组等方式实现了这个接口。非常适合用于作为数据共享的通道。</li>
<li><strong>ConcurrentSkipListMap:</strong> 跳表的实现。使用跳表的数据结构进行快速查找。</li>
</ul>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>多线程环境下，使用Hashmap进行put操作会引起死循环，应该使用支持多线程的 ConcurrentHashMap。</p>
<p>JDK1.8 ConcurrentHashMap取消了segment分段锁，而采用CAS和synchronized来保证并发安全。数据结构采用数组+链表&#x2F;红黑二叉树。synchronized只锁定当前链表或红黑二叉树的首节点，相比1.7锁定HashEntry数组，锁粒度更小，支持更高的并发量。当链表长度过长时，Node会转换成TreeNode，提高查找速度。</p>
<h4 id="put执行流程？"><a href="#put执行流程？" class="headerlink" title="put执行流程？"></a>put执行流程？</h4><p>在put的时候需要锁住Segment，保证并发安全。调用get的时候不加锁，因为node数组成员val和指针next是用volatile修饰的，更改后的值会立刻刷新到主存中，保证了可见性，node数组table也用volatile修饰，保证在运行过程对其他线程具有可见性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put 操作流程：</p>
<ol>
<li>如果table没有初始化就先进行初始化过程</li>
<li>使用hash算法计算key的位置</li>
<li>如果这个位置为空则直接CAS插入，如果不为空的话，则取出这个节点来</li>
<li>如果取出来的节点的hash值是MOVED(-1)的话，则表示当前正在对这个数组进行扩容，复制到新的数组，则当前线程也去帮助复制</li>
<li>如果这个节点，不为空，也不在扩容，则通过synchronized来加锁，进行添加操作，这里有两种情况，一种是链表形式就直接遍历到尾端插入或者覆盖掉相同的key，一种是红黑树就按照红黑树结构插入</li>
<li>链表的数量大于阈值8，就会转换成红黑树的结构或者进行扩容（table长度小于64）</li>
<li>添加成功后会检查是否需要扩容</li>
</ol>
<h4 id="怎么扩容？"><a href="#怎么扩容？" class="headerlink" title="怎么扩容？"></a>怎么扩容？</h4><p>数组扩容transfer方法中会设置一个步长，表示一个线程处理的数组长度，最小值是16。在一个步长范围内只有一个线程会对其进行复制移动操作。</p>
<h4 id="ConcurrentHashMap-和-Hashtable-的区别？"><a href="#ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别？"></a>ConcurrentHashMap 和 Hashtable 的区别？</h4><ol>
<li>Hashtable通过使用synchronized修饰方法的方式来实现多线程同步，因此，Hashtable的同步会锁住整个数组。在高并发的情况下，性能会非常差。ConcurrentHashMap采用了更细粒度的锁来提高在并发情况下的效率。注：synchronized容器（同步容器）也是通过synchronized关键字来实现线程安全，在使用的时候会对所有的数据加锁。</li>
<li>Hashtable默认的大小为11，当达到阈值后，每次按照下面的公式对容量进行扩充：newCapacity &#x3D; oldCapacity * 2 + 1。ConcurrentHashMap默认大小是16，扩容时容量扩大为原来的2倍。</li>
</ol>
<h3 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h3><p>Copy-On-Write，写时复制。当我们往容器添加元素时，不直接往容器添加，而是先将当前容器进行复制，复制出一个新的容器，然后往新的容器添加元素，添加完元素之后，再将原容器的引用指向新容器。这样做的好处就是可以对<code>CopyOnWrite</code>容器进行并发的读而不需要加锁，因为当前容器不会被修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">//add方法需要加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">//复制新数组</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements); <span class="comment">//原容器的引用指向新容器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器，它们是<code>CopyOnWriteArrayList</code>和<code>CopyOnWriteArraySet</code>。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>内存占用问题。由于CopyOnWrite的写时复制机制，在进行写操作的时候，内存里会同时驻扎两个对象的内存。</li>
<li>CopyOnWrite容器不能保证数据的实时一致性，可能读取到旧数据。</li>
</ul>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p><strong>CopyOnWriteArrayList</strong>是Java并发包中提供的一个并发容器。CopyOnWriteArrayList相当于线程安全的ArrayList，CopyOnWriteArrayList使用了一种叫写时复制的方法，当有新元素add到CopyOnWriteArrayList时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。</p>
<p><code>CopyOnWriteArrayList</code>中add方法添加的时候是需要加锁的，保证同步，避免了多线程写的时候复制出多个副本。读的时候不需要加锁，如果读的时候有其他线程正在向<code>CopyOnWriteArrayList</code>添加数据，还是可以读到旧的数据。</p>
<p>CopyOnWrite并发容器用于读多写少的并发场景。</p>
<p><strong>优点</strong>：</p>
<p>读操作性能很高，因为无需任何同步措施，比较适用于<strong>读多写少</strong>的并发场景。Java的list在遍历时，若中途有别的线程对list容器进行修改，则会抛出<strong>ConcurrentModificationException</strong>异常。而CopyOnWriteArrayList由于其”读写分离”的思想，遍历和修改操作分别作用在不同的list容器，所以在使用迭代器进行遍历时候，也就不会抛出ConcurrentModificationException异常了。</p>
<p><strong>缺点</strong>：</p>
<p><strong>一是内存占用问题</strong>，毕竟每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC；</p>
<p><strong>二是无法保证实时性</strong>，Vector对于读写操作均加锁同步，可以保证读和写的强一致性。而CopyOnWriteArrayList由于其实现策略的原因，写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。</p>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>非阻塞队列。高效的并发队列，使用链表实现。可以看做一个线程安全的 <code>LinkedList</code>，通过 CAS 操作实现。</p>
<p>如果对队列加锁的成本较高则适合使用无锁的 <code>ConcurrentLinkedQueue</code> 来替代。适合在对性能要求相对较高，同时有多个线程对队列进行读写的场景。</p>
<p><strong>非阻塞队列中的几种主要方法：</strong><code>add(E e)</code>: 将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则会抛出异常； <code>remove()</code>：移除队首元素，若移除成功，则返回true；如果移除失败（队列为空），则会抛出异常； <code>offer(E e)</code>：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则返回false； <code>poll()</code>：移除并获取队首元素，若成功，则返回队首元素；否则返回null； <code>peek()</code>：获取队首元素，若成功，则返回队首元素；否则返回null</p>
<p>对于非阻塞队列，一般情况下建议使用offer、poll和peek三个方法，不建议使用add和remove方法。因为使用offer、poll和peek三个方法可以通过返回值判断操作成功与否，而使用add和remove方法却不能达到这样的效果。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列是<code>java.util.concurrent</code>包下重要的数据结构，<code>BlockingQueue</code>提供了线程安全的队列访问方式：当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于<code>BlockingQueue</code>实现的。<code>BlockingQueue</code> 适合用于作为数据共享的通道。</p>
<p>使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。</p>
<p>阻塞队列和一般的队列的区别就在于：</p>
<ol>
<li>多线程支持，多个线程可以安全的访问队列</li>
<li>阻塞操作，当队列为空的时候，消费线程会阻塞等待队列不为空；当队列满了的时候，生产线程就会阻塞直到队列不满</li>
</ol>
<p><strong>方法</strong></p>
<table>
<thead>
<tr>
<th>方法\处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<h4 id="JDK提供的阻塞队列"><a href="#JDK提供的阻塞队列" class="headerlink" title="JDK提供的阻塞队列"></a>JDK提供的阻塞队列</h4><p>JDK 7 提供了7个阻塞队列，如下</p>
<p>1、<strong>ArrayBlockingQueue</strong></p>
<p>有界阻塞队列，底层采用数组实现。<code>ArrayBlockingQueue</code> 一旦创建，容量不能改变。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不能保证线程访问队列的公平性，参数<code>fair</code>可用于设置线程是否公平访问队列。为了保证公平性，通常会降低吞吐量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Integer&gt;(<span class="number">10</span>,<span class="literal">true</span>);<span class="comment">//fair</span></span><br></pre></td></tr></table></figure>

<p>2、<strong>LinkedBlockingQueue</strong></p>
<p><code>LinkedBlockingQueue</code>是一个用单向链表实现的有界阻塞队列，可以当做无界队列也可以当做有界队列来使用。通常在创建 <code>LinkedBlockingQueue</code> 对象时，会指定队列最大的容量。此队列的默认和最大长度为<code>Integer.MAX_VALUE</code>。此队列按照先进先出的原则对元素进行排序。与 <code>ArrayBlockingQueue</code> 相比起来具有更高的吞吐量。</p>
<p>3、<strong>PriorityBlockingQueue</strong></p>
<p>支持优先级的<strong>无界</strong>阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现<code>compareTo()</code>方法来指定元素排序规则，或者初始化<code>PriorityBlockingQueue</code>时，指定构造参数<code>Comparator</code>来进行排序。</p>
<p><code>PriorityBlockingQueue</code> 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会<strong>自动扩容</strong>。</p>
<p><code>PriorityQueue</code> 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p>
<p>4、<strong>DelayQueue</strong></p>
<p>支持延时获取元素的无界阻塞队列。队列使用<code>PriorityBlockingQueue</code>来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</p>
<p>5、<strong>SynchronousQueue</strong></p>
<p>不存储元素的阻塞队列，每一个put必须等待一个take操作，否则不能继续添加元素。支持公平访问队列。</p>
<p><code>SynchronousQueue</code>可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身不存储任何元素，非常适合传递性场景。<code>SynchronousQueue</code>的吞吐量高于<code>LinkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>。</p>
<p>6、<strong>LinkedTransferQueue</strong></p>
<p>由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，多了<code>tryTransfer</code>和<code>transfer</code>方法。</p>
<p>transfer方法：如果当前有消费者正在等待接收元素（take或者待时间限制的poll方法），transfer可以把生产者传入的元素立刻传给消费者。如果没有消费者等待接收元素，则将元素放在队列的tail节点，并等到该元素被消费者消费了才返回。</p>
<p>tryTransfer方法：用来试探生产者传入的元素能否直接传给消费者。如果没有消费者在等待，则返回false。和上述方法的区别是该方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>JDK使用通知模式实现阻塞队列。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p>
<p>ArrayBlockingQueue使用Condition来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// 队列为空时，阻塞当前消费者</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">          putIndex = <span class="number">0</span>;</span><br><span class="line">     count++;</span><br><span class="line">     notEmpty.signal(); <span class="comment">// 队列不为空时，通知消费者获取元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池：一个管理线程的池子。</p>
<h3 id="为什么平时都是使用线程池创建线程，直接new一个线程不好吗？"><a href="#为什么平时都是使用线程池创建线程，直接new一个线程不好吗？" class="headerlink" title="为什么平时都是使用线程池创建线程，直接new一个线程不好吗？"></a>为什么平时都是使用线程池创建线程，直接new一个线程不好吗？</h3><p>嗯，手动创建线程有两个缺点</p>
<ol>
<li>不受控风险</li>
<li>频繁创建开销大</li>
</ol>
<p><strong>为什么不受控</strong>？</p>
<p>系统资源有限，每个人针对不同业务都可以手动创建线程，并且创建线程没有统一标准，比如创建的线程有没有名字等。当系统运行起来，所有线程都在抢占资源，毫无规则，混乱场面可想而知，不好管控。</p>
<p><strong>频繁手动创建线程为什么开销会大？跟new Object() 有什么差别？</strong></p>
<p>虽然Java中万物皆对象，但是new Thread() 创建一个线程和 new Object()还是有区别的。</p>
<p>new Object()过程如下：</p>
<ol>
<li>JVM分配一块内存 M</li>
<li>在内存 M 上初始化该对象</li>
<li>将内存 M 的地址赋值给引用变量 obj</li>
</ol>
<p>创建线程的过程如下：</p>
<ol>
<li>JVM为一个线程栈分配内存，该栈为每个线程方法调用保存一个栈帧</li>
<li>每一栈帧由一个局部变量数组、返回值、操作数堆栈和常量池组成</li>
<li>每个线程获得一个程序计数器，用于记录当前虚拟机正在执行的线程指令地址</li>
<li>系统创建一个与Java线程对应的本机线程</li>
<li>将与线程相关的描述符添加到JVM内部数据结构中</li>
<li>线程共享堆和方法区域</li>
</ol>
<p>创建一个线程大概需要1M左右的空间（Java8，机器规格2c8G）。可见，频繁手动创建&#x2F;销毁线程的代价是非常大的。</p>
<h3 id="为什么使用线程池？"><a href="#为什么使用线程池？" class="headerlink" title="为什么使用线程池？"></a>为什么使用线程池？</h3><ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。统一管理线程，避免系统创建大量同类线程而导致消耗完内存。</li>
</ul>
<h3 id="线程池执行原理？"><a href="#线程池执行原理？" class="headerlink" title="线程池执行原理？"></a>线程池执行原理？</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="线程池执行流程"></p>
<ol>
<li>当线程池里存活的线程数小于核心线程数<code>corePoolSize</code>时，这时对于一个新提交的任务，线程池会创建一个线程去处理任务。当线程池里面存活的线程数小于等于核心线程数<code>corePoolSize</code>时，线程池里面的线程会一直存活着，就算空闲时间超过了<code>keepAliveTime</code>，线程也不会被销毁，而是一直阻塞在那里一直等待任务队列的任务来执行。</li>
<li>当线程池里面存活的线程数已经等于corePoolSize了，这是对于一个新提交的任务，会被放进任务队列workQueue排队等待执行。</li>
<li>当线程池里面存活的线程数已经等于<code>corePoolSize</code>了，并且任务队列也满了，假设<code>maximumPoolSize&gt;corePoolSize</code>，这时如果再来新的任务，线程池就会继续创建新的线程来处理新的任务，知道线程数达到<code>maximumPoolSize</code>，就不会再创建了。</li>
<li>如果当前的线程数达到了<code>maximumPoolSize</code>，并且任务队列也满了，如果还有新的任务过来，那就直接采用拒绝策略进行处理。默认的拒绝策略是抛出一个RejectedExecutionException异常。</li>
</ol>
<h3 id="线程池参数有哪些？"><a href="#线程池参数有哪些？" class="headerlink" title="线程池参数有哪些？"></a>线程池参数有哪些？</h3><p>ThreadPoolExecutor 的通用构造函数：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler);</span><br></pre></td></tr></table></figure>

<p>1、<code>corePoolSize</code>：当有新任务时，如果线程池中线程数没有达到线程池的基本大小，则会创建新的线程执行任务，否则将任务放入阻塞队列。当线程池中存活的线程数总是大于 corePoolSize 时，应该考虑调大 corePoolSize。</p>
<p>2、<code>maximumPoolSize</code>：当阻塞队列填满时，如果线程池中线程数没有超过最大线程数，则会创建新的线程运行任务。否则根据拒绝策略处理新任务。非核心线程类似于临时借来的资源，这些线程在空闲时间超过 keepAliveTime 之后，就应该退出，避免资源浪费。</p>
<p>3、<code>BlockingQueue</code>：存储等待运行的任务。</p>
<p>4、<code>keepAliveTime</code>：<strong>非核心线程</strong>空闲后，保持存活的时间，此参数只对非核心线程有效。设置为0，表示多余的空闲线程会被立即终止。</p>
<p>5、<code>TimeUnit</code>：时间单位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.DAYS</span><br><span class="line">TimeUnit.HOURS</span><br><span class="line">TimeUnit.MINUTES</span><br><span class="line">TimeUnit.SECONDS</span><br><span class="line">TimeUnit.MILLISECONDS</span><br><span class="line">TimeUnit.MICROSECONDS</span><br><span class="line">TimeUnit.NANOSECONDS</span><br></pre></td></tr></table></figure>

<p>6、<code>ThreadFactory</code>：每当线程池创建一个新的线程时，都是通过线程工厂方法来完成的。在 ThreadFactory 中只定义了一个方法 newThread，每当线程池需要创建新线程就会调用它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String poolName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThreadFactory</span><span class="params">(String poolName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.poolName = poolName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyAppThread</span>(runnable, poolName);<span class="comment">//将线程池名字传递给构造函数，用于区分不同线程池的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、<code>RejectedExecutionHandler</code>：当队列和线程池都满了的时候，根据拒绝策略处理新任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AbortPolicy：默认的策略，直接抛出RejectedExecutionException</span><br><span class="line">DiscardPolicy：不处理，直接丢弃</span><br><span class="line">DiscardOldestPolicy：将等待队列队首的任务丢弃，并执行当前任务</span><br><span class="line">CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure>

<h3 id="线程池大小怎么设置？"><a href="#线程池大小怎么设置？" class="headerlink" title="线程池大小怎么设置？"></a>线程池大小怎么设置？</h3><p>如果线程池线程数量太小，当有大量请求需要处理，系统响应比较慢，会影响用户体验，甚至会出现任务队列大量堆积任务导致OOM。</p>
<p>如果线程池线程数量过大，大量线程可能会同时抢占 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了执行效率。</p>
<p>**CPU 密集型任务(N+1)**： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为<code> N（CPU 核心数）+1</code>，多出来的一个线程是为了防止某些原因导致的线程阻塞（如IO操作，线程sleep，等待锁）而带来的影响。一旦某个线程被阻塞，释放了CPU资源，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p>
<p>**I&#x2F;O 密集型任务(2N)**： 系统的大部分时间都在处理 IO 操作，此时线程可能会被阻塞，释放CPU资源，这时就可以将 CPU 交出给其它线程使用。因此在 IO 密集型任务的应用中，可以多配置一些线程，具体的计算方法：<code>最佳线程数 = CPU核心数 * (1/CPU利用率) = CPU核心数 * (1 + (IO耗时/CPU耗时))</code>，一般可设置为2N。</p>
<h3 id="线程池的类型有哪些？适用场景？"><a href="#线程池的类型有哪些？适用场景？" class="headerlink" title="线程池的类型有哪些？适用场景？"></a>线程池的类型有哪些？适用场景？</h3><p>常见的线程池有 <code>FixedThreadPool</code>、<code>SingleThreadExecutor</code>、<code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code>。这几个都是 <code>ExecutorService</code> 线程池实例。</p>
<p><strong>FixedThreadPool</strong></p>
<p>固定线程数的线程池。任何时间点，最多只有 nThreads 个线程处于活动状态执行任务。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">	return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用无界队列 LinkedBlockingQueue（队列容量为 Integer.MAX_VALUE），运行中的线程池不会拒绝任务，即不会调用RejectedExecutionHandler.rejectedExecution()方法。</p>
<p>maxThreadPoolSize 是无效参数，故将它的值设置为与 coreThreadPoolSize 一致。</p>
<p>keepAliveTime 也是无效参数，设置为0L，因为此线程池里所有线程都是核心线程，核心线程不会被回收（除非设置了executor.allowCoreThreadTimeOut(true)）。</p>
<p>适用场景：适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。需要注意的是，FixedThreadPool 不会拒绝任务，<strong>在任务比较多的时候会导致 OOM。</strong></p>
<p><strong>SingleThreadExecutor</strong></p>
<p>只有一个线程的线程池。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutionService newSingleThreadExecutor() &#123;</span><br><span class="line">	return new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用无界队列 LinkedBlockingQueue。线程池只有一个运行的线程，新来的任务放入工作队列，线程处理完任务就循环从队列里获取任务执行。保证顺序的执行各个任务。</p>
<p>适用场景：适用于串行执行任务的场景，一个任务一个任务地执行。<strong>在任务比较多的时候也是会导致 OOM。</strong></p>
<p><strong>CachedThreadPool</strong></p>
<p>根据需要创建新线程的线程池。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">	return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果主线程提交任务的速度高于线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p>
<p>使用没有容量的SynchronousQueue作为线程池工作队列，当线程池有空闲线程时，<code>SynchronousQueue.offer(Runnable task)</code>提交的任务会被空闲线程处理，否则会创建新的线程处理任务。</p>
<p>适用场景：用于并发执行大量短期的小任务。<code>CachedThreadPool</code>允许创建的线程数量为 Integer.MAX_VALUE ，<strong>可能会创建大量线程，从而导致 OOM。</strong></p>
<p><strong>ScheduledThreadPoolExecutor</strong></p>
<p>在给定的延迟后运行任务，或者定期执行任务。在实际项目中基本不会被用到，因为有其他方案选择比如<code>quartz</code>。</p>
<p>使用的任务队列 <code>DelayQueue</code> 封装了一个 <code>PriorityQueue</code>，<code>PriorityQueue</code> 会对队列中的任务进行排序，时间早的任务先被执行(即<code>ScheduledFutureTask</code> 的 <code>time</code> 变量小的先执行)，如果time相同则先提交的任务会被先执行(<code>ScheduledFutureTask</code> 的 <code>squenceNumber</code> 变量小的先执行)。</p>
<p>执行周期任务步骤：</p>
<ol>
<li>线程从 <code>DelayQueue</code> 中获取已到期的 <code>ScheduledFutureTask（DelayQueue.take()）</code>。到期任务是指 <code>ScheduledFutureTask</code>的 time 大于等于当前系统的时间；</li>
<li>执行这个 <code>ScheduledFutureTask</code>；</li>
<li>修改 <code>ScheduledFutureTask</code> 的 time 变量为下次将要被执行的时间；</li>
<li>把这个修改 time 之后的 <code>ScheduledFutureTask</code> 放回 <code>DelayQueue</code> 中（<code>DelayQueue.add()</code>)。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/scheduled-task.jpg" alt="img"></p>
<p>适用场景：周期性执行任务的场景，需要限制线程数量的场景。</p>
<h3 id="怎么判断线程池的任务是不是执行完了？"><a href="#怎么判断线程池的任务是不是执行完了？" class="headerlink" title="怎么判断线程池的任务是不是执行完了？"></a>怎么判断线程池的任务是不是执行完了？</h3><p>有几种方法：</p>
<p>1、使用线程池的原生函数<strong>isTerminated()</strong>;</p>
<p>executor提供一个原生函数isTerminated()来判断线程池中的任务是否全部完成。如果全部完成返回true，否则返回false。</p>
<p>2、<strong>使用重入锁，维持一个公共计数</strong>。</p>
<p>所有的普通任务维持一个计数器，当任务完成时计数器加一（这里要加锁），当计数器的值等于任务数时，这时所有的任务已经执行完毕了。</p>
<p>3、<strong>使用CountDownLatch</strong>。</p>
<p>它的原理跟第二种方法类似，给CountDownLatch一个计数值，任务执行完毕后，调用countDown()执行计数值减一。最后执行的任务在调用方法的开始调用await()方法，这样整个任务会阻塞，直到这个计数值为零，才会继续执行。</p>
<p>这种方式的<strong>缺点</strong>就是需要提前知道任务的数量。</p>
<p>4、<strong>submit向线程池提交任务，使用Future判断任务执行状态</strong>。</p>
<p>使用submit向线程池提交任务与execute提交不同，submit会有Future类型的返回值。通过future.isDone()方法可以知道任务是否执行完成。</p>
<h3 id="为什么要使用Executor线程池框架呢？"><a href="#为什么要使用Executor线程池框架呢？" class="headerlink" title="为什么要使用Executor线程池框架呢？"></a>为什么要使用Executor线程池框架呢？</h3><ul>
<li>每次执行任务都通过new Thread()去创建线程，比较消耗性能，创建一个线程是比较耗时、耗资源的</li>
<li>调用new Thread()创建的线程缺乏管理，可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪</li>
<li>直接使用new Thread()启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不好实现</li>
</ul>
<h2 id="execute和submit的区别"><a href="#execute和submit的区别" class="headerlink" title="execute和submit的区别"></a>execute和submit的区别</h2><p>execute只能提交Runnable类型的任务，无返回值。submit既可以提交Runnable类型的任务，也可以提交Callable类型的任务，会有一个类型为Future的返回值，但当任务类型为Runnable时，返回值为null。</p>
<p>execute在执行任务时，如果遇到异常会直接抛出，而submit不会直接抛出，只有在使用Future的get方法获取返回值时，才会抛出异常</p>
<p>execute所属顶层接口是Executor，submit所属顶层接口是ExecutorService，实现类ThreadPoolExecutor重写了execute方法，抽象类AbstractExecutorService重写了submit方法。</p>
<h2 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h2><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间。</p>
<p>线程是比进程更小的执行单位，它是在一个进程中独立的控制流，一个进程可以启动多个线程，每条线程并行执行不同的任务。</p>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>**初始(NEW)**：线程被构建，还没有调用 start()。</p>
<p>**运行(RUNNABLE)**：包括操作系统的就绪和运行两种状态。</p>
<p>**阻塞(BLOCKED)**：一般是被动的，在抢占资源中得不到资源，被动的挂起在内存，等待资源释放将其唤醒。线程被阻塞会释放CPU，不释放内存。</p>
<p>**等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p>
<p>**超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。</p>
<p>**终止(TERMINATED)**：表示该线程已经执行完毕。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/image-20210909235618175.png" alt="img"></p>
<blockquote>
<p>图片来源：Java并发编程的艺术</p>
</blockquote>
<h3 id="讲讲线程中断？"><a href="#讲讲线程中断？" class="headerlink" title="讲讲线程中断？"></a>讲讲线程中断？</h3><p>线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑取决于目标线程。</p>
<p>线程中断三个重要的方法：</p>
<p><strong>1、java.lang.Thread#interrupt</strong></p>
<p>调用目标线程的<code>interrupt()</code>方法，给目标线程发一个中断信号，线程被打上中断标记。</p>
<p><strong>2、java.lang.Thread#isInterrupted()</strong></p>
<p>判断目标线程是否被中断，不会清除中断标记。</p>
<p><strong>3、java.lang.Thread#interrupted</strong></p>
<p>判断目标线程是否被中断，会清除中断标记。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 响应中断</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Java技术栈线程被中断，程序退出。&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建线程有哪几种方式？"><a href="#创建线程有哪几种方式？" class="headerlink" title="创建线程有哪几种方式？"></a>创建线程有哪几种方式？</h3><ul>
<li>通过扩展<code>Thread</code>类来创建多线程</li>
<li>通过实现<code>Runnable</code>接口来创建多线程</li>
<li>实现<code>Callable</code>接口，通过<code>FutureTask</code>接口创建线程。</li>
<li>使用<code>Executor</code>框架来创建线程池。</li>
</ul>
<p><strong>继承 Thread 创建线程</strong>代码如下。run()方法是由jvm创建完操作系统级线程后回调的方法，不可以手动调用，手动调用相当于调用普通方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-11 10:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        mThread1.start();</span><br><span class="line">        mThread2.start();</span><br><span class="line">        myThread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Runnable 创建线程代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-11 10:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Runnable1</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable1</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Runnable1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Runnable接口比继承Thread类所具有的优势：</p>
<ol>
<li>可以避免java中的单继承的限制</li>
<li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类</li>
</ol>
<p><strong>Callable 创建线程代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-11 10:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Callable1</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Callable1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步计算的结果</span></span><br><span class="line">        FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(result).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待任务完成，返回结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> result.get();</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Callable1</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 Executor 创建线程代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-11 10:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取ExecutorService实例，生产禁用，需要手动创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//提交任务</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">RunnableDemo</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;茶白&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么是线程死锁？"><a href="#什么是线程死锁？" class="headerlink" title="什么是线程死锁？"></a>什么是线程死锁？</h3><p>线程死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，它们都将无法推进下去。</p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方持有的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E6%AD%BB%E9%94%81.png" alt="死锁"></p>
<p>下面通过例子说明线程死锁，代码来自并发编程之美。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource2</span><br><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]waiting get resource1</span><br></pre></td></tr></table></figure>

<p>线程 A 通过 <code>synchronized</code> (resource1) 获得 resource1 的监视器锁，然后通过 <code>Thread.sleep(1000)</code>。让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p>
<h3 id="线程死锁怎么产生？怎么避免？"><a href="#线程死锁怎么产生？怎么避免？" class="headerlink" title="线程死锁怎么产生？怎么避免？"></a>线程死锁怎么产生？怎么避免？</h3><p><strong>死锁产生的四个必要条件</strong>：</p>
<ul>
<li>互斥：一个资源每次只能被一个进程使用</li>
<li>请求与保持：一个进程因请求资源而阻塞时，不释放获得的资源</li>
<li>不剥夺：进程已获得的资源，在未使用之前，不能强行剥夺</li>
<li>循环等待：进程之间循环等待着资源</li>
</ul>
<p><strong>避免死锁的方法</strong>：</p>
<ul>
<li>互斥条件不能破坏，因为加锁就是为了保证互斥</li>
<li>一次性申请所有的资源，避免线程占有资源而且在等待其他资源</li>
<li>占有部分资源的线程进一步申请其他资源时，如果申请不到，主动释放它占有的资源</li>
<li>按序申请资源</li>
</ul>
<h3 id="线程run和start的区别？"><a href="#线程run和start的区别？" class="headerlink" title="线程run和start的区别？"></a>线程run和start的区别？</h3><ul>
<li>当程序调用<code>start()</code>方法，将会创建一个新线程去执行<code>run()</code>方法中的代码。<code>run()</code>就像一个普通方法一样，直接调用<code>run()</code>的话，不会创建新线程。</li>
<li>一个线程的 <code>start()</code> 方法只能调用一次，多次调用会抛出 java.lang.IllegalThreadStateException 异常。<code>run()</code> 方法则没有限制。</li>
</ul>
<h3 id="线程都有哪些方法？"><a href="#线程都有哪些方法？" class="headerlink" title="线程都有哪些方法？"></a>线程都有哪些方法？</h3><p><strong>start</strong></p>
<p>用于启动线程。</p>
<p><strong>getPriority</strong></p>
<p>获取线程优先级，默认是5，线程默认优先级为5，如果不手动指定，那么线程优先级具有继承性，比如线程A启动线程B，那么线程B的优先级和线程A的优先级相同</p>
<p><strong>setPriority</strong></p>
<p>设置线程优先级。CPU会尽量将执行资源让给优先级比较高的线程。</p>
<p><strong>interrupt</strong></p>
<p>告诉线程，你应该中断了，具体到底中断还是继续运行，由被通知的线程自己处理。</p>
<p>当对一个线程调用 interrupt() 时，有两种情况：</p>
<ol>
<li>如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。</li>
<li>如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true。不过，被设置中断标志的线程可以继续正常运行，不受影响。</li>
</ol>
<p>interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。</p>
<p><strong>join</strong></p>
<p>等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p>
<p><strong>yield</strong></p>
<p>暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p>
<p><strong>sleep</strong></p>
<p>使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，线程自动转为Runnable状态。</p>
<h3 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h3><ol>
<li>使用共享变量的方式。共享变量可以被多个执行相同任务的线程用来作为是否停止的信号，通知停止线程的执行。</li>
<li>使用interrupt方法终止线程。当一个线程被阻塞，处于不可运行状态时，即使主程序中将该线程的共享变量设置为true，但该线程此时根本无法检查循环标志，当然也就无法立即中断。这时候可以使用Thread提供的interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态。</li>
</ol>
<h2 id="volatile底层原理"><a href="#volatile底层原理" class="headerlink" title="volatile底层原理"></a>volatile底层原理</h2><p><code>volatile</code>是轻量级的同步机制，<code>volatile</code>保证变量对所有线程的可见性，不保证原子性。</p>
<ol>
<li>当对<code>volatile</code>变量进行写操作的时候，JVM会向处理器发送一条<code>LOCK</code>前缀的指令，将该变量所在缓存行的数据写回系统内存。</li>
<li>由于缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存中。</li>
</ol>
<blockquote>
<p>来看看缓存一致性协议是什么。</p>
<p><strong>缓存一致性协议</strong>：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，就会从内存重新读取。</p>
</blockquote>
<p><code>volatile</code>关键字的两个作用：</p>
<ol>
<li>保证了不同线程对共享变量进行操作时的<strong>可见性</strong>，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li>
<li>禁止进行<strong>指令重排序</strong>。</li>
</ol>
<blockquote>
<p>指令重排序是JVM为了优化指令，提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。Java编译器会在生成指令系列时在适当的位置会插入<code>内存屏障</code>指令来禁止处理器重排序。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。对一个volatile字段进行写操作，Java内存模型将在写操作后插入一个写屏障指令，这个指令会把之前的写入值都刷新到内存。</p>
</blockquote>
<h2 id="volatile为什么不能保证原子性？"><a href="#volatile为什么不能保证原子性？" class="headerlink" title="volatile为什么不能保证原子性？"></a>volatile为什么不能保证原子性？</h2><p>volatile可以保证可见性和顺序性，但是它不能保证原子性。</p>
<p>举个例子。一个变量i被volatile修饰，两个线程想对这个变量修改，都对其进行自增操作i++，i++的过程可以分为三步，首先获取i的值，其次对i的值进行加1，最后将得到的新值写会到缓存中。</p>
<p>假如i的初始值为100。线程A首先得到了i的初始值100，但是还没来得及修改，就阻塞了，这时线程B开始了，它也去取i的值，由于i的值未被修改，即使是被volatile修饰，主存的变量还没变化，那么线程B得到的值也是100，之后对其进行加1操作，得到101，将新值写入到缓存中，再刷入主存中。根据可见性的原则，这个主存的值可以被其他线程可见。</p>
<p>那么问题来了，线程A之前已经读取到了i的值为100，线程A阻塞结束后，继续将100这个值加1，得到101，再将值写到缓存，最后刷入主存。这样i经过两次自增之后，结果值只加了1，明显是有问题的。所以说即便volatile具有可见性，也不能保证对它修饰的变量具有原子性。</p>
<h2 id="synchronized的用法有哪些"><a href="#synchronized的用法有哪些" class="headerlink" title="synchronized的用法有哪些?"></a>synchronized的用法有哪些?</h2><ol>
<li><strong>修饰普通方法</strong>：作用于当前对象实例，进入同步代码前要获得当前对象实例的锁</li>
<li><strong>修饰静态方法</strong>：作用于当前类，进入同步代码前要获得当前类对象的锁，synchronized关键字加到static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁</li>
<li><strong>修饰代码块</strong>：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁</li>
</ol>
<h2 id="synchronized的作用有哪些？"><a href="#synchronized的作用有哪些？" class="headerlink" title="synchronized的作用有哪些？"></a>synchronized的作用有哪些？</h2><p><strong>原子性</strong>：确保线程互斥的访问同步代码；</p>
<p><strong>可见性</strong>：保证共享变量的修改能够及时可见；</p>
<p><strong>有序性</strong>：有效解决重排序问题。</p>
<h2 id="synchronized-底层实现原理？"><a href="#synchronized-底层实现原理？" class="headerlink" title="synchronized 底层实现原理？"></a>synchronized 底层实现原理？</h2><p>synchronized 同步代码块的实现是通过 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <code>monitor</code>的持有权（monitor对象存在于每个Java对象的对象头中， synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因）。</p>
<p>其内部包含一个计数器，当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 <code>monitorexit</code> 指令后，将锁计数器设为0 ，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止</p>
<p>synchronized 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是<code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法，JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<h2 id="volatile和synchronized的区别是什么？"><a href="#volatile和synchronized的区别是什么？" class="headerlink" title="volatile和synchronized的区别是什么？"></a>volatile和synchronized的区别是什么？</h2><ol>
<li><code>volatile</code>只能使用在变量上；而<code>synchronized</code>可以在类，变量，方法和代码块上。</li>
<li><code>volatile</code>至保证可见性；<code>synchronized</code>保证原子性与可见性。</li>
<li><code>volatile</code>禁用指令重排序；<code>synchronized</code>不会。</li>
<li><code>volatile</code>不会造成阻塞；<code>synchronized</code>会。</li>
</ol>
<h2 id="ReentrantLock和synchronized区别"><a href="#ReentrantLock和synchronized区别" class="headerlink" title="ReentrantLock和synchronized区别"></a>ReentrantLock和synchronized区别</h2><ol>
<li>使用synchronized关键字实现同步，线程执行完同步代码块会<strong>自动释放锁</strong>，而ReentrantLock需要手动释放锁。</li>
<li>synchronized是<strong>非公平锁</strong>，ReentrantLock可以设置为公平锁。</li>
<li>ReentrantLock上等待获取锁的线程是<strong>可中断的</strong>，线程可以放弃等待锁。而synchonized会无限期等待下去。</li>
<li>ReentrantLock <strong>可以设置超时获取锁</strong>。在指定的截止时间之前获取锁，如果截止时间到了还没有获取到锁，则返回。</li>
<li>ReentrantLock 的 tryLock() 方法<strong>可以尝试非阻塞的获取锁</strong>，调用该方法后立刻返回，如果能够获取则返回true，否则返回false。</li>
</ol>
<h2 id="wait-和sleep-的异同点？"><a href="#wait-和sleep-的异同点？" class="headerlink" title="wait()和sleep()的异同点？"></a>wait()和sleep()的异同点？</h2><p><strong>相同点</strong>：</p>
<ol>
<li>它们都可以使当前线程暂停运行，把机会交给其他线程</li>
<li>任何线程在调用wait()和sleep()之后，在等待期间被中断都会抛出<code>InterruptedException</code></li>
</ol>
<p><strong>不同点</strong>：</p>
<ol>
<li><code>wait()</code>是Object超类中的方法；而<code>sleep()</code>是线程Thread类中的方法</li>
<li>对锁的持有不同，<code>wait()</code>会释放锁，而<code>sleep()</code>并不释放锁</li>
<li>唤醒方法不完全相同，<code>wait()</code>依靠<code>notify</code>或者<code>notifyAll </code>、中断、达到指定时间来唤醒；而<code>sleep()</code>到达指定时间被唤醒</li>
<li>调用<code>wait()</code>需要先获取对象的锁，而<code>Thread.sleep()</code>不用</li>
</ol>
<h2 id="Runnable和Callable有什么区别？"><a href="#Runnable和Callable有什么区别？" class="headerlink" title="Runnable和Callable有什么区别？"></a>Runnable和Callable有什么区别？</h2><ul>
<li>Callable接口方法是<code>call()</code>，Runnable的方法是<code>run()</code>；</li>
<li>Callable接口call方法有返回值，支持泛型，Runnable接口run方法无返回值。</li>
<li>Callable接口<code>call()</code>方法允许抛出异常；而Runnable接口<code>run()</code>方法不能继续上抛异常。</li>
</ul>
<h2 id="线程执行顺序怎么控制？"><a href="#线程执行顺序怎么控制？" class="headerlink" title="线程执行顺序怎么控制？"></a>线程执行顺序怎么控制？</h2><p>假设有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</p>
<p>可以使用<strong>join方法</strong>解决这个问题。比如在线程A中，调用线程B的join方法表示的意思就是<strong>：A等待B线程执行完毕后（释放CPU执行权），在继续执行。</strong></p>
<p>代码如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Thread spring = new Thread(new SeasonThreadTask(&quot;春天&quot;));</span><br><span class="line">        Thread summer = new Thread(new SeasonThreadTask(&quot;夏天&quot;));</span><br><span class="line">        Thread autumn = new Thread(new SeasonThreadTask(&quot;秋天&quot;));</span><br><span class="line"></span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            //春天线程先启动</span><br><span class="line">            spring.start();</span><br><span class="line">            //主线程等待线程spring执行完，再往下执行</span><br><span class="line">            spring.join();</span><br><span class="line">            //夏天线程再启动</span><br><span class="line">            summer.start();</span><br><span class="line">            //主线程等待线程summer执行完，再往下执行</span><br><span class="line">            summer.join();</span><br><span class="line">            //秋天线程最后启动</span><br><span class="line">            autumn.start();</span><br><span class="line">            //主线程等待线程autumn执行完，再往下执行</span><br><span class="line">            autumn.join();</span><br><span class="line">        &#125; catch (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SeasonThreadTask implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public SeasonThreadTask(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 1; i &lt;4; i++) &#123;</span><br><span class="line">            System.out.println(this.name + &quot;来了: &quot; + i + &quot;次&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">春天来了: 1次</span><br><span class="line">春天来了: 2次</span><br><span class="line">春天来了: 3次</span><br><span class="line">夏天来了: 1次</span><br><span class="line">夏天来了: 2次</span><br><span class="line">夏天来了: 3次</span><br><span class="line">秋天来了: 1次</span><br><span class="line">秋天来了: 2次</span><br><span class="line">秋天来了: 3次</span><br></pre></td></tr></table></figure>

<h2 id="守护线程是什么？"><a href="#守护线程是什么？" class="headerlink" title="守护线程是什么？"></a>守护线程是什么？</h2><p>守护线程是<strong>运行在后台的一种特殊进程</strong>。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p>
<h2 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="线程间通信方式"></a>线程间通信方式</h2><p>1、使用 Object 类的 **wait()&#x2F;notify()**。Object 类提供了线程间通信的方法：<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>，它们是多线程通信的基础。其中，<code>wait/notify</code> 必须配合 <code>synchronized</code> 使用，wait 方法释放锁，notify 方法不释放锁。wait 是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了<code>notify()</code>，notify并不释放锁，只是告诉调用过<code>wait()</code>的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放，调用 <code>wait()</code> 的一个或多个线程就会解除 wait 状态，重新参与竞争对象锁，程序如果可以再次得到锁，就可以继续向下运行。</p>
<p>2、使用 <strong>volatile</strong> 关键字。基于volatile关键字实现线程间相互通信，其底层使用了共享内存。简单来说，就是多个线程同时监听一个变量，当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。</p>
<p>3、使用JUC工具类 <strong>CountDownLatch</strong>。jdk1.5 之后在<code>java.util.concurrent</code>包下提供了很多并发编程相关的工具类，简化了并发编程开发，<code>CountDownLatch</code> 基于 AQS 框架，相当于也是维护了一个线程间共享变量 state。</p>
<p>4、基于 <strong>LockSupport</strong> 实现线程间的阻塞和唤醒。<code>LockSupport</code> 是一种非常灵活的实现线程间阻塞和唤醒的工具，使用它不用关注是等待线程先进行还是唤醒线程先运行，但是得知道线程的名字。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>线程本地变量。当使用<code>ThreadLocal</code>维护变量时，<code>ThreadLocal</code>为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程。</p>
<h3 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h3><p>每个线程都有一个<code>ThreadLocalMap</code>（<code>ThreadLocal</code>内部类），Map中元素的键为<code>ThreadLocal</code>，而值对应线程的变量副本。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/threadlocal.png" alt="img"></p>
<p>调用<code>threadLocal.set()</code>–&gt;调用<code>getMap(Thread)</code>–&gt;返回当前线程的<code>ThreadLocalMap&lt;ThreadLocal, value&gt;</code>–&gt;<code>map.set(this, value)</code>，this是<code>threadLocal</code>本身。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>get()</code>–&gt;调用<code>getMap(Thread)</code>–&gt;返回当前线程的<code>ThreadLocalMap&lt;ThreadLocal, value&gt;</code>–&gt;<code>map.getEntry(this)</code>，返回<code>value</code>。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>threadLocals</code>的类型<code>ThreadLocalMap</code>的键为<code>ThreadLocal</code>对象，因为每个线程中可有多个<code>threadLocal</code>变量，如<code>longLocal</code>和<code>stringLocal</code>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalDemo &#123;</span><br><span class="line">    ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void set() &#123;</span><br><span class="line">        longLocal.set(Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line">    public Long get() &#123;</span><br><span class="line">        return longLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ThreadLocalDemo threadLocalDemo = new ThreadLocalDemo();</span><br><span class="line">        threadLocalDemo.set();</span><br><span class="line">        System.out.println(threadLocalDemo.get());</span><br><span class="line"></span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            threadLocalDemo.set();</span><br><span class="line">            System.out.println(threadLocalDemo.get());</span><br><span class="line">        &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        thread.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(threadLocalDemo.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadLocal</code>并不是用来解决共享资源的多线程访问问题，因为每个线程中的资源只是副本，不会共享。因此<code>ThreadLocal</code>适合作为线程上下文变量，简化线程内传参。</p>
<h3 id="ThreadLocal内存泄漏的原因？"><a href="#ThreadLocal内存泄漏的原因？" class="headerlink" title="ThreadLocal内存泄漏的原因？"></a>ThreadLocal内存泄漏的原因？</h3><p>每个线程都有⼀个<code>ThreadLocalMap</code>的内部属性，map的key是<code>ThreaLocal</code>，定义为弱引用，value是强引用类型。垃圾回收的时候会⾃动回收key，而value的回收取决于Thread对象的生命周期。一般会通过线程池的方式复用线程节省资源，这也就导致了线程对象的生命周期比较长，这样便一直存在一条强引用链的关系：<code>Thread</code> –&gt; <code>ThreadLocalMap</code>–&gt;<code>Entry</code>–&gt;<code>Value</code>，随着任务的执行，value就有可能越来越多且无法释放，最终导致内存泄漏。</p>
<p>解决⽅法：每次使⽤完<code>ThreadLocal</code>就调⽤它的<code>remove()</code>⽅法，手动将对应的键值对删除，从⽽避免内存泄漏。</p>
<h3 id="ThreadLocal使用场景有哪些？"><a href="#ThreadLocal使用场景有哪些？" class="headerlink" title="ThreadLocal使用场景有哪些？"></a>ThreadLocal使用场景有哪些？</h3><p><strong>场景1</strong></p>
<p>ThreadLocal 用作保存每个线程独享的对象，为每个线程都创建一个副本，这样每个线程都可以修改自己所拥有的副本, 而不会影响其他线程的副本，确保了线程安全。</p>
<p>这种场景通常用于保存线程不安全的工具类，典型的使用的类就是 SimpleDateFormat。</p>
<p>假如需求为500个线程都要用到 SimpleDateFormat，使用线程池来实现线程的复用，否则会消耗过多的内存等资源，如果我们每个任务都创建了一个 simpleDateFormat 对象，也就是说，500个任务对应500个 simpleDateFormat 对象。但是这么多对象的创建是有开销的，而且这么多对象同时存在在内存中也是一种内存的浪费。可以将simpleDateFormat 对象给提取了出来，变成静态变量，但是这样一来就会有线程不安全的问题。我们想要的效果是，既不浪费过多的内存，同时又想保证线程安全。此时，可以使用 ThreadLocal来达到这个目的，每个线程都拥有一个自己的 simpleDateFormat 对象。</p>
<p><strong>场景2</strong></p>
<p>ThreadLocal 用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过 ThreadLocal 直接获取到，避免了传参，类似于全局变量的概念。</p>
<p>比如Java web应用中，每个线程有自己单独的<code>Session</code>实例，就可以使用<code>ThreadLocal</code>来实现。</p>
<h2 id="什么是AQS？"><a href="#什么是AQS？" class="headerlink" title="什么是AQS？"></a>什么是AQS？</h2><p>AQS（AbstractQueuedSynchronizer）是java.util.concurrent包下的核心类，我们经常使用的ReentrantLock、CountDownLatch，都是基于AQS抽象同步式队列实现的。</p>
<p>AQS作为一个抽象类，通常是通过继承来使用的。它本身是没有同步接口的，只是定义了同步状态和同步获取和同步释放的方法。</p>
<p>JUC包下面大部分同步类，都是基于AQS的同步状态的获取与释放来实现的，然后AQS是个双向链表。</p>
<h2 id="为什么AQS是双向链表而不是单向的？"><a href="#为什么AQS是双向链表而不是单向的？" class="headerlink" title="为什么AQS是双向链表而不是单向的？"></a>为什么AQS是双向链表而不是单向的？</h2><p>双向链表有两个指针，一个指针指向前置节点，一个指针指向后继节点。所以，双向链表可以支持常量 O(1) 时间复杂度的情况下找到前驱节点。因此，双向链表在插入和删除操作的时候，要比单向链表简单、高效。</p>
<p>从双向链表的特性来看，AQS 使用双向链表有2个方面的原因：</p>
<ol>
<li>没有竞争到锁的线程加入到阻塞队列，并且阻塞等待的前提是，当前线程所在节点的前置节点是正常状态，这样设计是为了避免链表中存在异常线程导致无法唤醒后续线程的问题。所以，线程阻塞之前需要判断前置节点的状态，如果没有指针指向前置节点，就需要从 Head 节点开始遍历，性能非常低。</li>
<li>在 Lock 接口里面有一个lockInterruptibly()方法，这个方法表示处于锁阻塞的线程允许被中断。也就是说，没有竞争到锁的线程加入到同步队列等待以后，是允许外部线程通过interrupt()方法触发唤醒并中断的。这个时候，被中断的线程的状态会修改成 CANCELLED。而被标记为 CANCELLED 状态的线程，是不需要去竞争锁的，但是它仍然存在于双向链表里面。这就意味着在后续的锁竞争中，需要把这个节点从链表里面移除，否则会导致锁阻塞的线程无法被正常唤醒。在这种情况下，如果是单向链表，就需要从 Head 节点开始往下逐个遍历，找到并移除异常状态的节点。同样效率也比较低，还会导致锁唤醒的操作和遍历操作之间的竞争。</li>
</ol>
<h2 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h2><p>AQS，<code>AbstractQueuedSynchronizer</code>，抽象队列同步器，定义了一套多线程访问共享资源的同步器框架，许多并发工具的实现都依赖于它，如常用的<code>ReentrantLock/Semaphore/CountDownLatch</code>。</p>
<p>AQS使用一个<code>volatile</code>的int类型的成员变量<code>state</code>来表示同步状态，通过CAS修改同步状态的值。当线程调用 lock 方法时 ，如果 <code>state</code>&#x3D;0，说明没有任何线程占有共享资源的锁，可以获得锁并将 <code>state</code>加1。如果 <code>state</code>不为0，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态（独占或共享 ）构造成为一个节点（Node）并将其加入同步队列并进行自旋，当同步状态释放时，会把首节点中的后继节点对应的线程唤醒，使其再次尝试获取同步状态。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/aqs.png" alt="img"></p>
<h2 id="ReentrantLock-是如何实现可重入性的"><a href="#ReentrantLock-是如何实现可重入性的" class="headerlink" title="ReentrantLock 是如何实现可重入性的?"></a>ReentrantLock 是如何实现可重入性的?</h2><p><code>ReentrantLock</code>内部自定义了同步器sync，在加锁的时候通过CAS算法，将线程对象放到一个双向链表中，每次获取锁的时候，检查当前维护的那个线程ID和当前请求的线程ID是否 一致，如果一致，同步状态加1，表示锁被当前线程获取了多次。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>按照<strong>线程访问顺序</strong>获取对象锁。<code>synchronized</code>是非公平锁，<code>Lock</code>默认是非公平锁，可以设置为公平锁，公平锁会影响性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="共享式与独占式锁"><a href="#共享式与独占式锁" class="headerlink" title="共享式与独占式锁"></a>共享式与独占式锁</h3><p>共享式与独占式的最主要<strong>区别</strong>在于：同一时刻独占式只能有<strong>一个线程</strong>获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。例如读操作可以有多个线程同时进行，而写操作同一时刻只能有一个线程进行写操作，其他操作都会被阻塞。</p>
<h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><p>悲观锁，<strong>每次访问资源都会加锁</strong>，执行完同步代码释放锁，<code>synchronized</code>和<code>ReentrantLock</code>属于悲观锁。</p>
<p>乐观锁，不会锁定资源，所有的线程都能访问并修改同一个资源，如果没有冲突就修改成功并退出，否则就会继续循环尝试。乐观锁最常见的实现就是<code>CAS</code>。</p>
<p>适用场景：</p>
<ul>
<li>悲观锁适合<strong>写操作多</strong>的场景。</li>
<li>乐观锁适合<strong>读操作多</strong>的场景，不加锁可以提升读操作的性能。</li>
</ul>
<h2 id="乐观锁有什么问题"><a href="#乐观锁有什么问题" class="headerlink" title="乐观锁有什么问题?"></a>乐观锁有什么问题?</h2><p>乐观锁避免了悲观锁独占对象的问题，提高了并发性能，但它也有缺点:</p>
<ul>
<li>乐观锁只能保证<strong>一个共享变量</strong>的原子操作。</li>
<li>长时间自旋可能导致<strong>开销大</strong>。假如CAS长时间不成功而一直自旋，会给CPU带来很大的开销。</li>
<li><strong>ABA问题</strong>。CAS的原理是通过比对内存值与预期值是否一样而判断内存值是否被改过，但是会有以下问题：假如内存值原来是A， 后来被一条线程改为B，最后又被改成了A，则CAS认为此内存值并没有发生改变。可以引入版本号解决这个问题，每次变量更新都把版本号加一。</li>
</ul>
<h2 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h2><p>CAS全称<code>Compare And Swap</code>，比较与交换，是乐观锁的主要实现方式。CAS在不使用锁的情况下实现多线程之间的变量同步。<code>ReentrantLock</code>内部的AQS和原子类内部都使用了CAS。</p>
<p>CAS算法涉及到三个操作数：</p>
<ul>
<li>需要读写的内存值V。</li>
<li>进行比较的值A。</li>
<li>要写入的新值B。</li>
</ul>
<p>只有当V的值等于A时，才会使用原子方式用新值B来更新V的值，否则会继续重试直到成功更新值。</p>
<p>以<code>AtomicInteger</code>为例，<code>AtomicInteger</code>的<code>getAndIncrement()</code>方法底层就是CAS实现，关键代码是 <code>compareAndSwapInt(obj, offset, expect, update)</code>，其含义就是，如果<code>obj</code>内的<code>value</code>和<code>expect</code>相等，就证明没有其他线程改变过这个变量，那么就更新它为<code>update</code>，如果不相等，那就会继续重试直到成功更新值。</p>
<h2 id="CAS存在的问题？"><a href="#CAS存在的问题？" class="headerlink" title="CAS存在的问题？"></a>CAS存在的问题？</h2><p>CAS 三大问题：</p>
<ol>
<li><p><strong>ABA问题</strong>。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从<code>A－B－A</code>变成了<code>1A－2B－3A</code>。</p>
<p>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，原子更新带有版本号的引用类型。</p>
</li>
<li><p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p>
</li>
<li><p><strong>只能保证一个共享变量的原子操作</strong>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p>
<p>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p>
</li>
</ol>
<h2 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h2><p>在JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore工具类提供了一种并发流程控制的手段。</p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch用于某个线程等待其他线程<strong>执行完任务</strong>再执行，与thread.join()功能类似。常见的应用场景是开启多个线程同时执行某个任务，等到所有任务执行完再执行特定操作，如汇总统计结果。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line">    static final int N = 4;</span><br><span class="line">    static CountDownLatch latch = new CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">       for(int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            new Thread(new Thread1()).start();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       latch.await(1000, TimeUnit.MILLISECONDS); //调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行;等待timeout时间后count值还没变为0的话就会继续执行</span><br><span class="line">       System.out.println(&quot;task finished&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Thread1 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;starts working&quot;);</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-0starts working</span><br><span class="line">Thread-1starts working</span><br><span class="line">Thread-2starts working</span><br><span class="line">Thread-3starts working</span><br><span class="line">task finished</span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier(同步屏障)，用于一组线程互相等待到某个状态，然后这组线程再<strong>同时</strong>执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数parties指让多少个线程或者任务等待至某个状态；参数barrierAction为当这些线程都达到某个状态时会执行的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line">    <span class="comment">// 请求的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is ready&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**等待60秒，保证子线程完全执行结束*/</span></span><br><span class="line">            cyclicBarrier.await(<span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----CyclicBarrierException------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下，可以看出CyclicBarrier是可以重用的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">threadnum:0is ready</span><br><span class="line">threadnum:1is ready</span><br><span class="line">threadnum:2is ready</span><br><span class="line">threadnum:3is ready</span><br><span class="line">threadnum:4is ready</span><br><span class="line">threadnum:4is finish</span><br><span class="line">threadnum:3is finish</span><br><span class="line">threadnum:2is finish</span><br><span class="line">threadnum:1is finish</span><br><span class="line">threadnum:0is finish</span><br><span class="line">threadnum:5is ready</span><br><span class="line">threadnum:6is ready</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当四个线程都到达barrier状态后，会从四个线程中选择一个线程去执行Runnable。</p>
<h3 id="CyclicBarrier和CountDownLatch区别"><a href="#CyclicBarrier和CountDownLatch区别" class="headerlink" title="CyclicBarrier和CountDownLatch区别"></a>CyclicBarrier和CountDownLatch区别</h3><p>CyclicBarrier 和 CountDownLatch 都能够实现线程之间的等待。</p>
<p>CountDownLatch用于某个线程等待其他线程<strong>执行完任务</strong>再执行。CyclicBarrier用于一组线程互相等待到某个状态，然后这组线程再<strong>同时</strong>执行。 CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，可用于处理更为复杂的业务场景。</p>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore类似于锁，它用于控制同时访问特定资源的线程数量，控制并发线程数。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class SemaphoreDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final int N = 7;</span><br><span class="line">        Semaphore s = new Semaphore(3);</span><br><span class="line">        for(int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            new Worker(s, i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Worker extends Thread &#123;</span><br><span class="line">        private Semaphore s;</span><br><span class="line">        private int num;</span><br><span class="line">        public Worker(Semaphore s, int num) &#123;</span><br><span class="line">            this.s = s;</span><br><span class="line">            this.num = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line">                System.out.println(&quot;worker&quot; + num +  &quot; using the machine&quot;);</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                System.out.println(&quot;worker&quot; + num +  &quot; finished the task&quot;);</span><br><span class="line">                s.release();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下，可以看出并非按照线程访问顺序获取资源的锁，即</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">worker0 using the machine</span><br><span class="line">worker1 using the machine</span><br><span class="line">worker2 using the machine</span><br><span class="line">worker2 finished the task</span><br><span class="line">worker0 finished the task</span><br><span class="line">worker3 using the machine</span><br><span class="line">worker4 using the machine</span><br><span class="line">worker1 finished the task</span><br><span class="line">worker6 using the machine</span><br><span class="line">worker4 finished the task</span><br><span class="line">worker3 finished the task</span><br><span class="line">worker6 finished the task</span><br><span class="line">worker5 using the machine</span><br><span class="line">worker5 finished the task</span><br></pre></td></tr></table></figure>

<h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><h3 id="基本类型原子类"><a href="#基本类型原子类" class="headerlink" title="基本类型原子类"></a>基本类型原子类</h3><p>使用原子的方式更新基本类型</p>
<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean ：布尔型原子类</li>
</ul>
<p>AtomicInteger 类常用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure>

<p>AtomicInteger 类主要利用 CAS (compare and swap) 保证原子操作，从而避免加锁的高开销。</p>
<h3 id="数组类型原子类"><a href="#数组类型原子类" class="headerlink" title="数组类型原子类"></a>数组类型原子类</h3><p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li>AtomicIntegerArray：整形数组原子类</li>
<li>AtomicLongArray：长整形数组原子类</li>
<li>AtomicReferenceArray ：引用类型数组原子类</li>
</ul>
<p>AtomicIntegerArray 类常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> <span class="comment">//获取 index=i 位置元素的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure>

<h3 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h3><ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicStampedReference：带有版本号的引用类型原子类。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li>AtomicMarkableReference ：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来</li>
</ul>
<h2 id="什么是Daemon线程？"><a href="#什么是Daemon线程？" class="headerlink" title="什么是Daemon线程？"></a>什么是Daemon线程？</h2><p>后台(daemon)线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说，只要有任何非后台线程还在运行，程序就不会终止。必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程。</p>
<p>注意：后台进程在不执行finally子句的情况下就会终止其run()方法。</p>
<p>比如：JVM的垃圾回收线程就是Daemon线程，Finalizer也是守护线程。</p>
<h2 id="SynchronizedMap和ConcurrentHashMap有什么区别？"><a href="#SynchronizedMap和ConcurrentHashMap有什么区别？" class="headerlink" title="SynchronizedMap和ConcurrentHashMap有什么区别？"></a>SynchronizedMap和ConcurrentHashMap有什么区别？</h2><p>SynchronizedMap一次锁住整张表来保证线程安全，所以每次只能有一个线程来访问map。</p>
<p>JDK1.8 ConcurrentHashMap采用CAS和synchronized来保证并发安全。数据结构采用数组+链表&#x2F;红黑二叉树。synchronized只锁定当前链表或红黑二叉树的首节点，支持并发访问、修改。 另外ConcurrentHashMap使用了一种不同的迭代方式。当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据 ，iterator完成后再将头指针替换为新的数据 ，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。</p>
<h2 id="什么是Future？"><a href="#什么是Future？" class="headerlink" title="什么是Future？"></a>什么是Future？</h2><p>在并发编程中，不管是继承thread类还是实现runnable接口，都无法保证获取到之前的执行结果。通过实现Callback接口，并用Future可以来接收多线程的执行结果。</p>
<p>Future表示一个可能还没有完成的异步任务的结果，针对这个结果可以添加Callback以便在任务执行成功或失败后作出相应的操作。</p>
<p>举个例子：比如去吃早点时，点了包子和凉菜，包子需要等3分钟，凉菜只需1分钟，如果是串行的一个执行，在吃上早点的时候需要等待4分钟，但是因为你在等包子的时候，可以同时准备凉菜，所以在准备凉菜的过程中，可以同时准备包子，这样只需要等待3分钟。Future就是后面这种执行模式。</p>
<p>Future接口主要包括5个方法：</p>
<ol>
<li>get()方法可以当任务结束后返回一个结果，如果调用时，工作还没有结束，则会阻塞线程，直到任务执行完毕</li>
<li>get(long timeout,TimeUnit unit)做多等待timeout的时间就会返回结果</li>
<li>cancel(boolean mayInterruptIfRunning)方法可以用来停止一个任务，如果任务可以停止（通过mayInterruptIfRunning来进行判断），则可以返回true，如果任务已经完成或者已经停止，或者这个任务无法停止，则会返回false。</li>
<li>isDone()方法判断当前方法是否完成</li>
<li>isCancel()方法判断当前方法是否取消</li>
</ol>
<h2 id="select、poll、epoll之间的区别"><a href="#select、poll、epoll之间的区别" class="headerlink" title="select、poll、epoll之间的区别"></a>select、poll、epoll之间的区别</h2><p>select，poll，epoll都是IO多路复用的机制。I&#x2F;O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I&#x2F;O则无需自己负责进行读写，异步I&#x2F;O的实现会负责把数据从内核拷贝到用户空间。</p>
<p>select的时间复杂度O(n)。它仅仅知道有I&#x2F;O事件发生了，却并不知道是哪那几个流，只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的时间复杂度，同时处理的流越多，轮询时间就越长。</p>
<p>poll的时间复杂度O(n)。poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的.</p>
<p>epoll的时间复杂度O(1)。epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I&#x2F;O事件通知我们。所以我们说epoll实际上是事件驱动的。</p>
<h2 id="ReadWriteLock-和-StampedLock-的区别"><a href="#ReadWriteLock-和-StampedLock-的区别" class="headerlink" title="ReadWriteLock 和 StampedLock 的区别"></a>ReadWriteLock 和 StampedLock 的区别</h2><p>在多线程编程中，对于共享资源的访问控制是一个非常重要的问题。在并发环境下，多个线程同时访问共享资源可能会导致数据不一致的问题，因此需要一种机制来保证数据的一致性和并发性。</p>
<p>Java提供了多种机制来实现并发控制，其中 ReadWriteLock 和 StampedLock 是两个常用的锁类。本文将分别介绍这两个类的特性、使用场景以及示例代码。</p>
<p><strong>ReadWriteLock</strong></p>
<p>ReadWriteLock 是Java提供的一个接口，全类名：<code>java.util.concurrent.locks.ReentrantLock</code>。它允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这种机制可以提高读取操作的并发性，但写入操作需要独占资源。</p>
<p><strong>特性</strong></p>
<ul>
<li>多个线程可以同时获取读锁，但只有一个线程可以获取写锁。</li>
<li>当一个线程持有写锁时，其他线程无法获取读锁和写锁，读写互斥。</li>
<li>当一个线程持有读锁时，其他线程可以同时获取读锁，读读共享。</li>
</ul>
<p><strong>使用场景</strong></p>
<p><strong>ReadWriteLock</strong> 适用于读多写少的场景，例如缓存系统、数据库连接池等。在这些场景中，读取操作占据大部分时间，而写入操作较少。</p>
<p><strong>示例代码</strong></p>
<p>下面是一个使用 ReadWriteLock 的示例，实现了一个简单的缓存系统：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，Cache 类使用 ReadWriteLock 来实现对 data 的并发访问控制。get 方法获取读锁并读取数据，put 方法获取写锁并写入数据。</p>
<p><strong>StampedLock</strong></p>
<p>StampedLock 是Java 8 中引入的一种新的锁机制，全类名：<code>java.util.concurrent.locks.StampedLock</code>，它提供了一种乐观读的机制，可以进一步提升读取操作的并发性能。</p>
<p><strong>特性</strong></p>
<ul>
<li>与 ReadWriteLock 类似，StampedLock 也支持多个线程同时获取读锁，但只允许一个线程获取写锁。</li>
<li>与 ReadWriteLock 不同的是，StampedLock 还提供了一个乐观读锁（Optimistic Read Lock），即不阻塞其他线程的写操作，但在读取完成后需要验证数据的一致性。</li>
</ul>
<p><strong>使用场景</strong></p>
<p>StampedLock 适用于读远远大于写的场景，并且对数据的一致性要求不高，例如统计数据、监控系统等。</p>
<p><strong>示例代码</strong></p>
<p>下面是一个使用 StampedLock 的示例，实现了一个计数器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> count;</span><br><span class="line">        <span class="keyword">if</span> (!lock.validate(stamp)) &#123;</span><br><span class="line">            stamp = lock.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                value = count;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，Counter 类使用 StampedLock 来实现对计数器的并发访问控制。getCount 方法首先尝试获取乐观读锁，并读取计数器的值，然后通过 validate 方法验证数据的一致性。如果验证失败，则获取悲观读锁，并重新读取计数器的值。increment 方法获取写锁，并对计数器进行递增操作。</p>
<p><strong>总结</strong></p>
<p><strong>ReadWriteLock</strong> 和 <strong>StampedLock</strong> 都是Java中用于并发控制的重要机制。</p>
<ul>
<li><strong>ReadWriteLock</strong> 适用于读多写少的场景;</li>
<li><strong>StampedLock</strong> 则适用于读远远大于写的场景，并且对数据的一致性要求不高;</li>
</ul>
<p>在实际应用中，我们需要根据具体场景来选择合适的锁机制。通过合理使用这些锁机制，我们可以提高并发程序的性能和可靠性。</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型带来的好处"><a href="#泛型带来的好处" class="headerlink" title="泛型带来的好处"></a>泛型带来的好处</h2><p>在没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是本身就是一个安全隐患。</p>
<p>那么泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GlmapperGeneric</span>&lt;<span class="title">T</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">T t</span>)</span> &#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span>()</span> &#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 不指定类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noSpecifyType</span>()</span>&#123;</span><br><span class="line">    GlmapperGeneric glmapperGeneric = <span class="keyword">new</span> GlmapperGeneric();</span><br><span class="line">    glmapperGeneric.<span class="keyword">set</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="comment">// 需要强制类型转换</span></span><br><span class="line">    String test = (String) glmapperGeneric.<span class="keyword">get</span>();</span><br><span class="line">    System.<span class="keyword">out</span>.println(test);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specifyType</span>()</span>&#123;</span><br><span class="line">    GlmapperGeneric&lt;String&gt; glmapperGeneric = <span class="keyword">new</span> GlmapperGeneric();</span><br><span class="line">    glmapperGeneric.<span class="keyword">set</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="comment">// 不需要强制类型转换</span></span><br><span class="line">    String test = glmapperGeneric.<span class="keyword">get</span>();</span><br><span class="line">    System.<span class="keyword">out</span>.println(test);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码中的 specifyType 方法中 省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上。</p>
<h2 id="泛型中通配符"><a href="#泛型中通配符" class="headerlink" title="泛型中通配符"></a>泛型中通配符</h2><p>我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V 等等，这些通配符又都是什么意思呢？</p>
<h3 id="常用的-T，E，K，V，？"><a href="#常用的-T，E，K，V，？" class="headerlink" title="常用的 T，E，K，V，？"></a>常用的 T，E，K，V，？</h3><p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。<strong>通常情况下，T，E，K，V，？是这样约定的：</strong></p>
<ul>
<li>？表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<h3 id="？无界通配符"><a href="#？无界通配符" class="headerlink" title="？无界通配符"></a>？无界通配符</h3><p>先从一个小例子看起。<a target="_blank" rel="noopener" href="https://topjavaer.cn/">最全面的Java面试网站</a></p>
<p>我有一个父类 Animal 和几个子类，如狗、猫等，现在我需要一个动物的列表，我的第一个想法是像这样的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List<span class="tag">&lt;<span class="name">Animal</span>&gt;</span> listAnimals</span><br></pre></td></tr></table></figure>

<p>但是老板的想法确实这样的：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List<span class="meta">&lt;?</span> <span class="keyword">extends</span> Animal&gt; listAnimals</span><br></pre></td></tr></table></figure>

<p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">countLegs</span> <span class="params">(List&lt;? extends Animal &gt; animals )</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal += animal.<span class="built_in">countLegs</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">countLegs1</span> <span class="params">(List&lt; Animal &gt; animals )</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal += animal.<span class="built_in">countLegs</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 不会报错</span></span><br><span class="line">    <span class="built_in">countLegs</span>( dogs );</span><br><span class="line"> <span class="comment">// 报错</span></span><br><span class="line">    <span class="built_in">countLegs1</span>(dogs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 countLegs1 时，就会飘红，提示的错误信息如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E6%B3%9B%E5%9E%8B1.png" alt="img"></p>
<p>所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 &lt;?&gt; ），表示可以持有任何类型。像 countLegs 方法中，限定了上界，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 countLegs1 就不行。</p>
<h3 id="上界通配符-extends-E"><a href="#上界通配符-extends-E" class="headerlink" title="上界通配符 &lt; ? extends E&gt;"></a>上界通配符 &lt; ? extends E&gt;</h3><blockquote>
<p>上界：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p>
</blockquote>
<p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p>
<ul>
<li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li>
<li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;K <span class="keyword">extends</span> <span class="title class_">A</span>, E <span class="keyword">extends</span> <span class="title class_">B</span>&gt; E <span class="title function_">test</span><span class="params">(K arg1, E arg2)</span>&#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> arg2;</span><br><span class="line">    arg2.compareTo(arg1);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类型参数列表中如果有多个类型参数上限，用逗号分开</p>
</blockquote>
<h3 id="下界通配符-super-E"><a href="#下界通配符-super-E" class="headerlink" title="下界通配符 &lt; ? super E&gt;"></a>下界通配符 &lt; ? super E&gt;</h3><blockquote>
<p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p>
</blockquote>
<p>在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;<span class="type">T</span>&gt; void test(<span class="type">List</span>&lt;? <span class="keyword">super</span> <span class="type">T</span>&gt; dst, <span class="type">List</span>&lt;<span class="type">T</span>&gt; src)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">T</span> t : src) &#123;</span><br><span class="line">        dst.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">    <span class="type">List</span>&lt;<span class="type">Dog</span>&gt; dogs = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">List</span>&lt;<span class="type">Animal</span>&gt; animals = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Test3</span>().test(animals,dogs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Dog 是 Animal 的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dst 类型 “大于等于” src 的类型，这里的“大于等于”是指 dst 表示的范围比 src 要大，因此装得下 dst 的容器也就能装 src 。</p>
<h3 id="？和-T-的区别"><a href="#？和-T-的区别" class="headerlink" title="？和 T 的区别"></a>？和 T 的区别</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E6%B3%9B%E5%9E%8B2.png" alt="img"></p>
<p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？不行，比如如下这种 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> operate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以</span></span><br><span class="line">？car = operate();</span><br></pre></td></tr></table></figure>

<p>简单总结下：</p>
<p>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p>
<h4 id="区别1：通过-T-来-确保-泛型参数的一致性"><a href="#区别1：通过-T-来-确保-泛型参数的一致性" class="headerlink" title="区别1：通过 T 来 确保 泛型参数的一致性"></a>区别1：通过 T 来 确保 泛型参数的一致性</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 T 来 确保 泛型参数的一致性</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="built_in">void</span></span><br><span class="line"><span class="title function_">test</span>(<span class="title class_">List</span>&lt;T&gt; dest, <span class="title class_">List</span>&lt;T&gt; src)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span></span><br><span class="line"><span class="title function_">test</span>(<span class="title class_">List</span>&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; dest, <span class="title class_">List</span>&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; src)</span><br></pre></td></tr></table></figure>

<p>像下面的代码中，约定的 T 是 Number 的子类才可以，但是申明时是用的 String ，所以就会飘红报错。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E6%B3%9B%E5%9E%8B3.png" alt="img"></p>
<p>不能保证两个 List 具有相同的元素类型的情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">GlmapperGeneric</span>&lt;<span class="title class_">String</span>&gt; glmapperGeneric = <span class="keyword">new</span> <span class="title class_">GlmapperGeneric</span>&lt;&gt;();</span><br><span class="line"><span class="title class_">List</span>&lt;<span class="title class_">String</span>&gt; dest = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="title class_">List</span>&lt;<span class="title class_">Number</span>&gt; src = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">glmapperGeneric.<span class="title function_">testNon</span>(dest,src);</span><br></pre></td></tr></table></figure>

<p>上面的代码在编译器并不会报错，但是当进入到 testNon 方法内部操作时（比如赋值），对于 dest 和 src 而言，就还是需要进行类型转换。</p>
<h4 id="区别2：类型参数可以多重限定而通配符不行"><a href="#区别2：类型参数可以多重限定而通配符不行" class="headerlink" title="区别2：类型参数可以多重限定而通配符不行"></a>区别2：类型参数可以多重限定而通配符不行</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E6%B3%9B%E5%9E%8B4.png" alt="img"></p>
<p>使用 &amp; 符号设定多重边界（Multi Bounds)，指定泛型类型 T 必须是 MultiLimitInterfaceA 和 MultiLimitInterfaceB 的共有子类型，此时变量 t 就具有了所有限定的方法和属性。对于通配符来说，因为它不是一个确定的类型，所以不能进行多重限定。</p>
<h4 id="区别3：通配符可以使用超类限定而类型参数不行"><a href="#区别3：通配符可以使用超类限定而类型参数不行" class="headerlink" title="区别3：通配符可以使用超类限定而类型参数不行"></a>区别3：通配符可以使用超类限定而类型参数不行</h4><p>类型参数 T 只具有 一种 类型限定方式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T extends <span class="selector-tag">A</span></span><br></pre></td></tr></table></figure>

<p>但是通配符 ? 可以进行 两种限定：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? extends <span class="selector-tag">A</span></span><br><span class="line">? super <span class="selector-tag">A</span></span><br></pre></td></tr></table></figure>

<h2 id="Class和-Class区别"><a href="#Class和-Class区别" class="headerlink" title="Class&lt;T&gt;和 Class&lt;?&gt;区别"></a><code>Class&lt;T&gt;</code>和 <code>Class&lt;?&gt;</code>区别</h2><p>前面介绍了 ？和 T 的区别，那么对于，<code>Class&lt;T&gt;</code>和 <code>&lt;Class&lt;?&gt;</code>又有什么区别呢？<code>Class&lt;T&gt;</code>和 <code>Class&lt;?&gt;</code></p>
<p>最常见的是在反射场景下的使用，这里以用一段发射的代码来说明下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射的方式生成  multiLimit</span></span><br><span class="line"><span class="comment">// 对象，这里比较明显的是，我们需要使用强制类型转换</span></span><br><span class="line"><span class="type">MultiLimit</span> <span class="variable">multiLimit</span> <span class="operator">=</span> (MultiLimit)</span><br><span class="line">Class.forName(<span class="string">&quot;com.glmapper.bridge.boot.generic.MultiLimit&quot;</span>).newInstance();</span><br></pre></td></tr></table></figure>

<p>对于上述代码，在运行期，如果反射的类型不是 MultiLimit 类，那么一定会报 java.lang.ClassCastException 错误。</p>
<p>对于这种情况，则可以使用下面的代码来代替，使得在在编译期就能直接 检查到类型的问题：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E6%B3%9B%E5%9E%8B5.png" alt="img"></p>
<p><code>Class&lt;T&gt;</code>在实例化的时候，T 要替换成具体类。<code>Class&lt;?&gt;</code>它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">Class</span>&lt;?&gt; clazz;</span><br><span class="line"><span class="comment">// 不可以，因为 T 需要指定类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">Class</span>&lt;<span class="type">T</span>&gt; clazzT;</span><br></pre></td></tr></table></figure>

<p>所以当不知道定声明什么类型的 Class 的时候可以定义一 个Class&lt;?&gt;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="keyword">public</span> Class&lt;T&gt; clazzT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那如果也想 <code>public Class&lt;T&gt; clazzT;</code>这样的话，就必须让当前的类也指定 T ，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="comment">// 不会报错</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;T&gt; clazzT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h1><h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h2><p>JVM，全称Java Virtual Machine（Java虚拟机），是通过在实际的计算机上仿真模拟各种计算机功能来实现的。由<strong>一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域等</strong>组成。JVM屏蔽了与操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行，这也是Java能够“<strong>一次编译，到处运行的</strong>”原因。</p>
<h2 id="讲一下JVM内存结构？"><a href="#讲一下JVM内存结构？" class="headerlink" title="讲一下JVM内存结构？"></a>讲一下JVM内存结构？</h2><p>JVM内存结构分为5大区域，<strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>、<strong>堆</strong>、<strong>方法区</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%840.png" alt="img"></p>
<p><strong>程序计数器</strong></p>
<p>线程私有的，作为当前线程的行号指示器，用于记录当前虚拟机正在执行的线程指令地址。程序计数器主要有两个作用：</p>
<ol>
<li>当前线程所执行的字节码的行号指示器，通过它实现<strong>代码的流程控制</strong>，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于<strong>记录当前线程执行的位置</strong>，当线程被切换回来的时候能够知道它上次执行的位置。</li>
</ol>
<p>程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<p><strong>虚拟机栈</strong></p>
<p>Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口信息</strong>。每一次函数调用都会有一个对应的栈帧被压入虚拟机栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p>
<p>局部变量表是用于存放方法参数和方法内的局部变量。</p>
<p>每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，在方法调用过程中，会进行动态链接，将这个符号引用转化为直接引用。</p>
<ul>
<li>部分符号引用在类加载阶段的时候就转化为直接引用，这种转化就是静态链接</li>
<li>部分符号引用在运行期间转化为直接引用，这种转化就是动态链接</li>
</ul>
<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</p>
<p>可以通过<code>-Xss</code>参数来指定每个线程的虚拟机栈内存大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss2M</span><br></pre></td></tr></table></figure>

<p><strong>本地方法栈</strong></p>
<p>虚拟机栈为虚拟机执行 <code>Java</code> 方法服务，而本地方法栈则为虚拟机使用到的 <code>Native</code> 方法服务。<code>Native</code> 方法一般是用其它语言（C、C++等）编写的。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p><strong>堆</strong></p>
<p>堆用于存放对象实例，是垃圾收集器管理的主要区域，因此也被称作<code>GC</code>堆。堆可以细分为：新生代（<code>Eden</code>空间、<code>From Survivor</code>、<code>To Survivor</code>空间）和老年代。</p>
<p>通过 <code>-Xms</code>设定程序启动时占用内存大小，通过<code>-Xmx</code>设定程序运行期间最大可占用的内存大小。如果程序运行需要占用更多的内存，超出了这个设置值，就会抛出<code>OutOfMemory</code>异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms1M -Xmx2M</span><br></pre></td></tr></table></figure>

<p>1.方法区</p>
<p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>对方法区进行垃圾回收的主要目标是<strong>对常量池的回收和对类的卸载</strong>。</p>
<p>2.永久代</p>
<p>方法区是 JVM 的规范，而永久代<code>PermGen</code>是方法区的一种实现方式，并且只有 <code>HotSpot</code> 有永久代。对于其他类型的虚拟机，如<code>JRockit</code>没有永久代。由于方法区主要存储类的相关信息，所以对于动态生成类的场景比较容易出现永久代的内存溢出。</p>
<p>3.元空间</p>
<p>JDK 1.8 的时候，<code>HotSpot</code>的永久代被彻底移除了，使用元空间替代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。两者最大的区别在于：元空间并不在虚拟机中，而是使用直接内存。</p>
<p>为什么要将永久代替换为元空间呢?</p>
<p>永久代内存受限于 JVM 可用内存，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是相比永久代内存溢出的概率更小。</p>
<p><strong>运行时常量池</strong></p>
<p>运行时常量池是方法区的一部分，在类加载之后，会将编译器生成的各种字面量和符号引号放到运行时常量池。在运行期间动态生成的常量，如 String 类的 intern()方法，也会被放入运行时常量池。</p>
<p><strong>直接内存</strong></p>
<p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误出现。</p>
<p>NIO的Buffer提供了<code>DirectBuffer</code>，可以直接访问系统物理内存，避免堆内内存到堆外内存的数据拷贝操作，提高效率。<code>DirectBuffer</code>直接分配在物理内存中，并不占用堆空间，其可申请的最大内存受操作系统限制，不受最大堆内存的限制。</p>
<p>直接内存的读写操作比堆内存快，可以提升程序I&#x2F;O操作的性能。通常在I&#x2F;O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到直接内存。</p>
<h2 id="Java对象的定位方式"><a href="#Java对象的定位方式" class="headerlink" title="Java对象的定位方式"></a>Java对象的定位方式</h2><p>Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针两种：</p>
<ul>
<li>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</li>
<li>直接指针。reference 中存储的直接就是对象的地址。对象包含到对象类型数据的指针，通过这个指针可以访问对象类型数据。使用直接指针访问方式最大的好处就是访问对象速度快，它节省了一次指针定位的时间开销，虚拟机hotspot主要是使用直接指针来访问对象。</li>
</ul>
<h2 id="说一下堆栈的区别？"><a href="#说一下堆栈的区别？" class="headerlink" title="说一下堆栈的区别？"></a>说一下堆栈的区别？</h2><ol>
<li>堆的<strong>物理地址分配</strong>是不连续的，性能较慢；栈的物理地址分配是连续的，性能相对较快。</li>
<li>堆存放的是<strong>对象的实例和数组</strong>；栈存放的是<strong>局部变量，操作数栈，返回结果</strong>等。</li>
<li>堆是<strong>线程共享</strong>的；栈是<strong>线程私有</strong>的。</li>
</ol>
<h2 id="什么情况下会发生栈溢出？"><a href="#什么情况下会发生栈溢出？" class="headerlink" title="什么情况下会发生栈溢出？"></a>什么情况下会发生栈溢出？</h2><ul>
<li>当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出<code>StackOverFlowError</code>异常。这种情况通常是因为方法递归没终止条件。</li>
<li>新建线程的时候没有足够的内存去创建对应的虚拟机栈，虚拟机会抛出<code>OutOfMemoryError</code>异常。比如线程启动过多就会出现这种情况。</li>
</ul>
<h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><p>Class 文件结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//类文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//类的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类的索引</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要参数如下：</p>
<p><strong>魔数</strong>：<code>class</code>文件标志。</p>
<p><strong>文件版本</strong>：高版本的 Java 虚拟机可以执行低版本编译器生成的类文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的类文件。</p>
<p><strong>常量池</strong>：存放字面量和符号引用。字面量类似于 Java 的常量，如字符串，声明为<code>final</code>的常量值等。符号引用包含三类：类和接口的全限定名，方法的名称和描述符，字段的名称和描述符。</p>
<p><strong>访问标志</strong>：识别类或者接口的访问信息，比如这个<code>Class</code>是类还是接口，是否为 <code>public</code> 或者 <code>abstract</code> 类型等等。</p>
<p><strong>当前类的索引</strong>：类索引用于确定这个类的全限定名。</p>
<h2 id="什么是类加载？类加载的过程？"><a href="#什么是类加载？类加载的过程？" class="headerlink" title="什么是类加载？类加载的过程？"></a>什么是类加载？类加载的过程？</h2><p>类的加载指的是将类的<code>class</code>文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个此类的对象，通过这个对象可以访问到方法区对应的类信息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E7%B1%BB%E5%8A%A0%E8%BD%BD.png" alt="img"></p>
<p><strong>加载</strong></p>
<ol>
<li>通过类的全限定名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的<code>Class</code>对象，作为方法区类信息的访问入口</li>
</ol>
<p><strong>验证</strong></p>
<p>确保Class文件的字节流中包含的信息符合虚拟机规范，保证在运行后不会危害虚拟机自身的安全。主要包括四种验证：<strong>文件格式验证，元数据验证，字节码验证，符号引用验证</strong>。</p>
<p><strong>准备</strong></p>
<p>为类变量分配内存并设置类变量初始值的阶段。</p>
<p><strong>解析</strong></p>
<p>虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用用于描述目标，直接引用直接指向目标的地址。</p>
<p><strong>初始化</strong></p>
<p>开始执行类中定义的<code>Java</code>代码，初始化阶段是调用类构造器的过程。</p>
<h2 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h2><p>一个类加载器收到一个类的加载请求时，它首先不会自己尝试去加载它，而是把这个请求<strong>委派</strong>给父类加载器去完成，这样层层委派，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png" alt="img"></p>
<p>双亲委派模型的具体实现代码在 <code>java.lang.ClassLoader</code>中，此类的 <code>loadClass()</code> 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 <code>ClassNotFoundException</code>，此时尝试自己去加载。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么需要双亲委派模型？"><a href="#为什么需要双亲委派模型？" class="headerlink" title="为什么需要双亲委派模型？"></a>为什么需要双亲委派模型？</h2><p>双亲委派模型的好处：可以防止内存中出现多份同样的字节码。如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个<code>java.lang.Object</code>的同名类并放在<code>ClassPath</code>中，多个类加载器都去加载这个类到内存中，系统中将会出现多个不同的<code>Object</code>类，那么类之间的比较结果及类的唯一性将无法保证。</p>
<h2 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h2><ul>
<li><p>实现通过类的全限定名获取该类的二进制字节流的代码块叫做类加载器。</p>
<p>主要有一下四种类加载器:</p>
<ul>
<li><strong>启动类加载器</strong>：用来加载 Java 核心类库，无法被 Java 程序直接引用。</li>
<li><strong>扩展类加载器</strong>：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li><strong>系统类加载器</strong>：它根据应用的类路径来加载 Java 类。可通过<code>ClassLoader.getSystemClassLoader()</code>获取它。</li>
<li><strong>自定义类加载器</strong>：通过继承<code>java.lang.ClassLoader</code>类的方式实现。</li>
</ul>
</li>
</ul>
<h2 id="类的实例化顺序？"><a href="#类的实例化顺序？" class="headerlink" title="类的实例化顺序？"></a>类的实例化顺序？</h2><ol>
<li>父类中的<code>static</code>代码块，当前类的<code>static</code>代码块</li>
<li>父类的普通代码块</li>
<li>父类的构造函数</li>
<li>当前类普通代码块</li>
<li>当前类的构造函数</li>
</ol>
<h2 id="如何判断一个对象是否存活？"><a href="#如何判断一个对象是否存活？" class="headerlink" title="如何判断一个对象是否存活？"></a>如何判断一个对象是否存活？</h2><p>对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不再被任何途径引用的对象）。判断对象是否存活有两种方法：引用计数法和可达性分析。</p>
<p><strong>引用计数法</strong></p>
<p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p>
<p>这种方法很难解决对象之间相互循环引用的问题。比如下面的代码，<code>obj1</code> 和 <code>obj2</code> 互相引用，这种情况下，引用计数器的值都是1，不会被垃圾回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCount</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ReferenceCount</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCount</span>();</span><br><span class="line">		<span class="type">ReferenceCount</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCount</span>();</span><br><span class="line">		obj1.instance = obj2;</span><br><span class="line">		obj2.instance = obj1;</span><br><span class="line">		obj1 = <span class="literal">null</span>;</span><br><span class="line">		obj2 = <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可达性分析</strong></p>
<p>通过<code>GC Root</code>对象为起点，从这些节点向下搜索，搜索所走过的路径叫引用链，当一个对象到<code>GC Root</code>没有任何的引用链相连时，说明这个对象是不可用的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%900.png" alt="img"></p>
<h2 id="可作为GC-Roots的对象有哪些？"><a href="#可作为GC-Roots的对象有哪些？" class="headerlink" title="可作为GC Roots的对象有哪些？"></a>可作为GC Roots的对象有哪些？</h2><ol>
<li>虚拟机栈中引用的对象</li>
<li>本地方法栈中Native方法引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
</ol>
<h2 id="什么情况下类会被卸载？"><a href="#什么情况下类会被卸载？" class="headerlink" title="什么情况下类会被卸载？"></a>什么情况下类会被卸载？</h2><p>需要同时满足以下 3 个条件类才可能会被卸载 ：</p>
<ul>
<li>该类所有的实例都已经被回收。</li>
<li>加载该类的类加载器已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的类进行回收，但不一定会进行回收。</p>
<h2 id="强引用、软引用、弱引用、虚引用是什么，有什么区别？"><a href="#强引用、软引用、弱引用、虚引用是什么，有什么区别？" class="headerlink" title="强引用、软引用、弱引用、虚引用是什么，有什么区别？"></a>强引用、软引用、弱引用、虚引用是什么，有什么区别？</h2><p><strong>强引用</strong>：在程序中普遍存在的引用赋值，类似<code>Object obj = new Object()</code>这种引用关系。只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
<p><strong>软引用</strong>：如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//软引用</span></span><br><span class="line">SoftReference&lt;String&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>

<p><strong>弱引用</strong>：在进行垃圾回收时，不管当前内存空间足够与否，都会回收只具有弱引用的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//弱引用</span></span><br><span class="line">WeakReference&lt;String&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>

<p><strong>虚引用</strong>：虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。<strong>虚引用主要是为了能在对象被收集器回收时收到一个系统通知</strong>。</p>
<h2 id="GC是什么？为什么要GC？"><a href="#GC是什么？为什么要GC？" class="headerlink" title="GC是什么？为什么要GC？"></a>GC是什么？为什么要GC？</h2><p>GC（<code>Garbage Collection</code>），垃圾回收，是Java与C++的主要区别之一。作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码。这是因为在Java虚拟机中，存在自动内存管理和垃圾清理机制。对JVM中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，保证JVM中的内存空间，防止出现内存泄露和溢出问题。</p>
<h2 id="Minor-GC-和-Full-GC的区别？"><a href="#Minor-GC-和-Full-GC的区别？" class="headerlink" title="Minor GC 和 Full GC的区别？"></a>Minor GC 和 Full GC的区别？</h2><ul>
<li><strong>Minor GC</strong>：回收新生代，因为新生代对象存活时间很短，因此 <code>Minor GC</code>会频繁执行，执行的速度一般也会比较快。</li>
<li><strong>Full GC</strong>：回收老年代和新生代，老年代的对象存活时间长，因此 <code>Full GC</code> 很少执行，执行速度会比 <code>Minor GC</code> 慢很多。</li>
</ul>
<h2 id="内存的分配策略？"><a href="#内存的分配策略？" class="headerlink" title="内存的分配策略？"></a>内存的分配策略？</h2><p><strong>对象优先在 Eden 分配</strong></p>
<p>大多数情况下，对象在新生代 <code>Eden</code> 上分配，当 <code>Eden</code> 空间不够时，触发 <code>Minor GC</code>。</p>
<p><strong>大对象直接进入老年代</strong></p>
<p>大对象是指需要连续内存空间的对象，最典型的大对象有长字符串和大数组。可以设置JVM参数 <code>-XX:PretenureSizeThreshold</code>，大于此值的对象直接在老年代分配。</p>
<p><strong>长期存活的对象进入老年代</strong></p>
<p>通过参数 <code>-XX:MaxTenuringThreshold</code> 可以设置对象进入老年代的年龄阈值。对象在<code>Survivor</code>区每经过一次 <code>Minor GC</code>，年龄就增加 1 岁，当它的年龄增加到一定程度，就会被晋升到老年代中。</p>
<p><strong>动态对象年龄判定</strong></p>
<p>并非对象的年龄必须达到 <code>MaxTenuringThreshold</code> 才能晋升老年代，如果在 <code>Survivor</code> 中相同年龄所有对象大小的总和大于 <code>Survivor</code> 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需达到 <code>MaxTenuringThreshold</code> 年龄阈值。</p>
<p><strong>空间分配担保</strong></p>
<p>在发生 <code>Minor GC</code> 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 <code>Minor GC</code> 是安全的。如果不成立的话虚拟机会查看 <code>HandlePromotionFailure</code> 的值是否允许担保失败。如果允许，那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 <code>Minor GC</code>；如果小于，或者 <code>HandlePromotionFailure</code> 的值为不允许担保失败，那么就要进行一次 <code>Full GC</code>。</p>
<h2 id="Full-GC-的触发条件？"><a href="#Full-GC-的触发条件？" class="headerlink" title="Full GC 的触发条件？"></a>Full GC 的触发条件？</h2><p>对于 Minor GC，其触发条件比较简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 触发条件相对复杂，有以下情况会发生 full GC：</p>
<p><strong>调用 System.gc()</strong></p>
<p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<p><strong>老年代空间不足</strong></p>
<p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组、注意编码规范避免内存泄露。除此之外，可以通过 <code>-Xmn</code> 参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 <code>-XX:MaxTenuringThreshold</code> 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<p><strong>空间分配担保失败</strong></p>
<p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p>
<p><strong>JDK 1.7 及以前的永久代空间不足</strong></p>
<p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 <code>java.lang.OutOfMemoryError</code>。</p>
<h2 id="垃圾回收算法有哪些？"><a href="#垃圾回收算法有哪些？" class="headerlink" title="垃圾回收算法有哪些？"></a>垃圾回收算法有哪些？</h2><p>垃圾回收算法有四种，分别是<strong>标记清除法、标记整理法、复制算法、分代收集算法</strong>。</p>
<p><strong>标记清除算法</strong></p>
<p>首先利用可达性去遍历内存，把存活对象和垃圾对象进行标记。标记结束后统一将所有标记的对象回收掉。这种垃圾回收算法效率较低，并且会<strong>产生大量不连续的空间碎片</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" alt="img"></p>
<p><strong>复制清除算法</strong></p>
<p>半区复制，用于新生代垃圾回收。将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。</p>
<p>特点：实现简单，运行高效，但可用内存缩小为了原来的一半，浪费空间。</p>
<p><strong>标记整理算法</strong></p>
<p>根据老年代的特点提出的一种标记算法，标记过程仍然与<code>标记-清除</code>算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" alt="img"></p>
<p><strong>分类收集算法</strong></p>
<p>根据各个年代的特点采用最适当的收集算法。</p>
<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用复制算法</li>
<li>老年代使用标记清除算法或者标记整理算法</li>
</ul>
<p>在新生代中，每次垃圾收集时都有大批对象死去，只有少量存活，使用复制算法比较合适，只需要付出少量存活对象的复制成本就可以完成收集。老年代对象存活率高，适合使用标记-清理或者标记-整理算法进行垃圾回收。</p>
<h2 id="有哪些垃圾回收器？"><a href="#有哪些垃圾回收器？" class="headerlink" title="有哪些垃圾回收器？"></a>有哪些垃圾回收器？</h2><p>垃圾回收器主要分为以下几种：<code>Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1</code>。</p>
<p>这7种垃圾收集器的特点：</p>
<table>
<thead>
<tr>
<th align="center">收集器</th>
<th align="center">串行、并行or并发</th>
<th align="center">新生代&#x2F;老年代</th>
<th align="center">算法</th>
<th align="center">目标</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Serial</strong></td>
<td align="center">串行</td>
<td align="center">新生代</td>
<td align="center">复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">单CPU环境下的Client模式</td>
</tr>
<tr>
<td align="center"><strong>ParNew</strong></td>
<td align="center">并行</td>
<td align="center">新生代</td>
<td align="center">复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">多CPU环境时在Server模式下与CMS配合</td>
</tr>
<tr>
<td align="center"><strong>Parallel Scavenge</strong></td>
<td align="center">并行</td>
<td align="center">新生代</td>
<td align="center">复制算法</td>
<td align="center">吞吐量优先</td>
<td align="center">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td align="center"><strong>Serial Old</strong></td>
<td align="center">串行</td>
<td align="center">老年代</td>
<td align="center">标记-整理</td>
<td align="center">响应速度优先</td>
<td align="center">单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td align="center"><strong>Parallel Old</strong></td>
<td align="center">并行</td>
<td align="center">老年代</td>
<td align="center">标记-整理</td>
<td align="center">吞吐量优先</td>
<td align="center">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td align="center"><strong>CMS</strong></td>
<td align="center">并发</td>
<td align="center">老年代</td>
<td align="center">标记-清除</td>
<td align="center">响应速度优先</td>
<td align="center">集中在互联网站或B&#x2F;S系统服务端上的Java应用</td>
</tr>
<tr>
<td align="center"><strong>G1</strong></td>
<td align="center">并发</td>
<td align="center">both</td>
<td align="center">标记-整理+复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">面向服务端应用，将来替换CMS</td>
</tr>
</tbody></table>
<p><strong>Serial 收集器</strong></p>
<p><strong>单线程收集器</strong>，使用一个垃圾收集线程去进行垃圾回收，在进行垃圾回收的时候必须暂停其他所有的工作线程（ <code>Stop The World</code> ），直到它收集结束。</p>
<p>特点：简单高效；内存消耗小；没有线程交互的开销，单线程收集效率高；需暂停所有的工作线程，用户体验不好。</p>
<p><strong>ParNew 收集器</strong></p>
<p><code>Serial</code>收集器的<strong>多线程版本</strong>，除了使用多线程进行垃圾收集外，其他行为、参数与 <code>Serial</code> 收集器基本一致。</p>
<p><strong>Parallel Scavenge 收集器</strong></p>
<p><strong>新生代收集器</strong>，基于<strong>复制清除算法</strong>实现的收集器。特点是<strong>吞吐量优先</strong>，能够并行收集的多线程收集器，允许多个垃圾回收线程同时运行，降低垃圾收集时间，提高吞吐量。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值（<code>吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）</code>）。<code>Parallel Scavenge</code> 收集器关注点是<strong>吞吐量，高效率的利用 CPU 资源</strong>。<code>CMS</code> 垃圾收集器关注点更多的是<strong>用户线程的停顿时间</strong>。</p>
<p><code>Parallel Scavenge</code>收集器提供了两个参数用于<strong>精确控制吞吐量</strong>，分别是控制最大垃圾收集停顿时间的<code>-XX：MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>-XX：GCTimeRatio</code>参数。</p>
<ul>
<li><code>-XX：MaxGCPauseMillis</code>参数的值是一个大于0的毫秒数，收集器将尽量保证内存回收花费的时间不超过用户设定值。</li>
<li><code>-XX：GCTimeRatio</code>参数的值大于0小于100，即垃圾收集时间占总时间的比率，相当于吞吐量的倒数。</li>
</ul>
<p><strong>Serial Old 收集器</strong></p>
<p><code>Serial</code> 收集器的老年代版本，单线程收集器，使用<strong>标记整理算法</strong>。</p>
<p><strong>Parallel Old 收集器</strong></p>
<p><code>Parallel Scavenge</code> 收集器的老年代版本。多线程垃圾收集，使用<strong>标记整理算法</strong>。</p>
<p><strong>CMS 收集器</strong></p>
<p><code>Concurrent Mark Sweep</code> ，并发标记清除，追求获取<strong>最短停顿时间</strong>，实现了让<strong>垃圾收集线程与用户线程基本上同时工作</strong>。</p>
<p><code>CMS</code> 垃圾回收基于<strong>标记清除算法</strong>实现，整个过程分为四个步骤：</p>
<ul>
<li>初始标记： 暂停所有用户线程（<code>Stop The World</code>），记录直接与 <code>GC Roots</code> 直接相连的对象 。</li>
<li>并发标记：从<code>GC Roots</code>开始对堆中对象进行可达性分析，找出存活对象，耗时较长，但是不需要停顿用户线程。</li>
<li>重新标记： 在并发标记期间对象的引用关系可能会变化，需要重新进行标记。此阶段也会暂停所有用户线程。</li>
<li>并发清除：清除标记对象，这个阶段也是可以与用户线程同时并发的。</li>
</ul>
<p>在整个过程中，耗时最长的是并发标记和并发清除阶段，这两个阶段垃圾收集线程都可以与用户线程一起工作，所以从总体上来说，<code>CMS</code>收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p><strong>优点</strong>：并发收集，停顿时间短。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>标记清除算法导致收集结束有<strong>大量空间碎片</strong>。</li>
<li><strong>产生浮动垃圾</strong>，在并发清理阶段用户线程还在运行，会不断有新的垃圾产生，这一部分垃圾出现在标记过程之后，<code>CMS</code>无法在当次收集中回收它们，只好等到下一次垃圾回收再处理；</li>
</ul>
<p><strong>G1收集器</strong></p>
<p>G1垃圾收集器的目标是在不同应用场景中<strong>追求高吞吐量和低停顿之间的最佳平衡</strong>。</p>
<p>G1将整个堆分成相同大小的分区（<code>Region</code>），有四种不同类型的分区：<code>Eden、Survivor、Old和Humongous</code>。分区的大小取值范围为 1M 到 32M，都是2的幂次方。分区大小可以通过<code>-XX:G1HeapRegionSize</code>参数指定。<code>Humongous</code>区域用于存储大对象。G1规定只要大小超过了一个分区容量一半的对象就认为是大对象。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/g1%E5%88%86%E5%8C%BA.png" alt="img"></p>
<p>G1 收集器对各个分区回收所获得的空间大小和回收所需时间的经验值进行排序，得到一个优先级列表，每次根据用户设置的最大回收停顿时间，优先回收价值最大的分区。</p>
<p><strong>特点</strong>：可以由用户<strong>指定</strong>期望的垃圾收集停顿时间。</p>
<p>G1 收集器的回收过程分为以下几个步骤：</p>
<ul>
<li><strong>初始标记</strong>。暂停所有其他线程，记录直接与 <code>GC Roots</code> 直接相连的对象，耗时较短 。</li>
<li><strong>并发标记</strong>。从<code>GC Roots</code>开始对堆中对象进行可达性分析，找出要回收的对象，耗时较长，不过可以和用户程序并发执行。</li>
<li><strong>最终标记</strong>。需对其他线程做短暂的暂停，用于处理并发标记阶段对象引用出现变动的区域。</li>
<li><strong>筛选回收</strong>。对各个分区的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，然后把决定回收的分区的存活对象复制到空的分区中，再清理掉整个旧的分区的全部空间。这里的操作涉及存活对象的移动，会暂停用户线程，由多条收集器线程并行完成。</li>
</ul>
<h2 id="常用的-JVM-调优的命令都有哪些？"><a href="#常用的-JVM-调优的命令都有哪些？" class="headerlink" title="常用的 JVM 调优的命令都有哪些？"></a>常用的 JVM 调优的命令都有哪些？</h2><p><strong>jps</strong>：列出本机所有 Java 进程的<strong>进程号</strong>。</p>
<p>常用参数如下：</p>
<ul>
<li><code>-m</code> 输出<code>main</code>方法的参数</li>
<li><code>-l</code> 输出完全的包名和应用主类名</li>
<li><code>-v</code> 输出<code>JVM</code>参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jps -lvm</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="comment">//4124 com.zzx.Application -javaagent:E:\IDEA2019\lib\idea_rt.jar=10291:E:\IDEA2019\bin -Dfile.encoding=UTF-8</span></span><br></pre></td></tr></table></figure>

<p><strong>jstack</strong>：查看某个 Java 进程内的<strong>线程堆栈信息</strong>。使用参数<code>-l</code>可以打印额外的锁信息，发生死锁时可以使用<code>jstack -l pid</code>观察锁持有情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack -l <span class="number">4124</span> | more</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;http-nio-8001-exec-10&quot;</span> #<span class="number">40</span> daemon prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x000000002542f000</span> nid=<span class="number">0x4028</span> waiting on condition [<span class="number">0x000000002cc9e000</span>]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait <span class="keyword">for</span>  &lt;<span class="number">0x000000077420d7e8</span>&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">175</span>)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:<span class="number">2039</span>)</span><br><span class="line">        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:<span class="number">442</span>)</span><br><span class="line">        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:<span class="number">103</span>)</span><br><span class="line">        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:<span class="number">31</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:<span class="number">1074</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1134</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:<span class="number">61</span>)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br></pre></td></tr></table></figure>

<p><code>WAITING (parking)</code>指线程处于挂起中，在等待某个条件发生，来把自己唤醒。</p>
<p><strong>jstat</strong>：用于查看虚拟机各种<strong>运行状态信息（类装载、内存、垃圾收集等运行数据）</strong>。使用参数<code>-gcuitl</code>可以查看垃圾回收的统计信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil <span class="number">4124</span></span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">  <span class="number">0.00</span>   <span class="number">0.00</span>  <span class="number">67.21</span>  <span class="number">19.20</span>  <span class="number">96.36</span>  <span class="number">94.96</span>     <span class="number">10</span>    <span class="number">0.084</span>     <span class="number">3</span>    <span class="number">0.191</span>    <span class="number">0.275</span></span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><strong>S0</strong>：<code>Survivor0</code>区当前使用比例</li>
<li><strong>S1</strong>：<code>Survivor1</code>区当前使用比例</li>
<li><strong>E</strong>：<code>Eden</code>区使用比例</li>
<li><strong>O</strong>：老年代使用比例</li>
<li><strong>M</strong>：元数据区使用比例</li>
<li><strong>CCS</strong>：压缩使用比例</li>
<li><strong>YGC</strong>：年轻代垃圾回收次数</li>
<li><strong>FGC</strong>：老年代垃圾回收次数</li>
<li><strong>FGCT</strong>：老年代垃圾回收消耗时间</li>
<li><strong>GCT</strong>：垃圾回收消耗总时间</li>
</ul>
<p><strong>jmap</strong>：查看<strong>堆内存快照</strong>。通过<code>jmap</code>命令可以获得运行中的堆内存的快照，从而可以对堆内存进行离线分析。</p>
<p>查询进程4124的堆内存快照，输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&gt;jmap -heap <span class="number">4124</span></span><br><span class="line">Attaching to process ID <span class="number">4124</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.221</span>-b11</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with <span class="number">6</span> thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = <span class="number">0</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">100</span></span><br><span class="line">   MaxHeapSize              = <span class="number">4238344192</span> (<span class="number">4042.</span>0MB)</span><br><span class="line">   NewSize                  = <span class="number">88604672</span> (<span class="number">84.</span>5MB)</span><br><span class="line">   MaxNewSize               = <span class="number">1412431872</span> (<span class="number">1347.</span>0MB)</span><br><span class="line">   OldSize                  = <span class="number">177733632</span> (<span class="number">169.</span>5MB)</span><br><span class="line">   NewRatio                 = <span class="number">2</span></span><br><span class="line">   SurvivorRatio            = <span class="number">8</span></span><br><span class="line">   MetaspaceSize            = <span class="number">21807104</span> (<span class="number">20.</span>796875MB)</span><br><span class="line">   CompressedClassSpaceSize = <span class="number">1073741824</span> (<span class="number">1024.</span>0MB)</span><br><span class="line">   MaxMetaspaceSize         = <span class="number">17592186044415</span> <span class="type">MB</span></span><br><span class="line">   <span class="variable">G1HeapRegionSize</span>         <span class="operator">=</span> <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = <span class="number">327155712</span> (<span class="number">312.</span>0MB)</span><br><span class="line">   used     = <span class="number">223702392</span> (<span class="number">213.</span>33922576904297MB)</span><br><span class="line">   free     = <span class="number">103453320</span> (<span class="number">98.</span>66077423095703MB)</span><br><span class="line">   <span class="number">68.37795697725736</span>% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = <span class="number">21495808</span> (<span class="number">20.</span>5MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">21495808</span> (<span class="number">20.</span>5MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = <span class="number">23068672</span> (<span class="number">22.</span>0MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">23068672</span> (<span class="number">22.</span>0MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">PS Old <span class="type">Generation</span></span><br><span class="line">   <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">217579520</span> (<span class="number">207.</span>5MB)</span><br><span class="line">   used     = <span class="number">41781472</span> (<span class="number">39.</span>845916748046875MB)</span><br><span class="line">   free     = <span class="number">175798048</span> (<span class="number">167.</span>65408325195312MB)</span><br><span class="line">   <span class="number">19.20285144484187</span>% used</span><br><span class="line"></span><br><span class="line"><span class="number">27776</span> interned Strings occupying <span class="number">3262336</span> bytes.</span><br></pre></td></tr></table></figure>

<p><strong>jinfo</strong>：<code>jinfo -flags 1</code>。查看当前的应用JVM参数配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID <span class="number">1</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.111</span>-b14</span><br><span class="line">Non-<span class="keyword">default</span> VM flags: -XX:CICompilerCount=<span class="number">2</span> -XX:InitialHeapSize=<span class="number">31457280</span> -XX:MaxHeapSize=<span class="number">480247808</span> -XX:MaxNewSize=<span class="number">160038912</span> -XX:MinHeapDeltaBytes=<span class="number">196608</span> -XX:NewSize=<span class="number">10485760</span> -XX:OldSize=<span class="number">20971520</span> -XX:+UseCompressedClassPointers -XX:+UseCompressedOops</span><br><span class="line">Command line:</span><br></pre></td></tr></table></figure>

<p><strong>查看所有参数</strong>：<code>java -XX:+PrintFlagsFinal -version</code>。用于查看最终值，初始值可能被修改掉（查看初始值可以使用java -XX:+PrintFlagsInitial）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Global flags]</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">AdaptiveSizeDecrementScaleFactor</span>          <span class="operator">=</span> <span class="number">4</span>                                   &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">AdaptiveSizeMajorGCDecayTimeScale</span>         <span class="operator">=</span> <span class="number">10</span>                                  &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">AdaptiveSizePausePolicy</span>                   <span class="operator">=</span> <span class="number">0</span>                                   &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">AdaptiveSizePolicyCollectionCostMargin</span>    <span class="operator">=</span> <span class="number">50</span>                                  &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">AdaptiveSizePolicyInitializingSteps</span>       <span class="operator">=</span> <span class="number">20</span>                                  &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">AdaptiveSizePolicyOutputInterval</span>          <span class="operator">=</span> <span class="number">0</span>                                   &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">AdaptiveSizePolicyWeight</span>                  <span class="operator">=</span> <span class="number">10</span>                                  &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">AdaptiveSizeThroughPutPolicy</span>              <span class="operator">=</span> <span class="number">0</span>                                   &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">AdaptiveTimeWeight</span>                        <span class="operator">=</span> <span class="number">25</span>                                  &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">AdjustConcurrency</span>                         <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">AggressiveOpts</span>                            <span class="operator">=</span> <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     ....</span><br></pre></td></tr></table></figure>

<h2 id="对象头了解吗？"><a href="#对象头了解吗？" class="headerlink" title="对象头了解吗？"></a>对象头了解吗？</h2><p>Java 内存中的对象由以下三部分组成：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充字节</strong>。</p>
<p>而对象头由以下三部分组成：<strong>mark word</strong>、<strong>指向类信息的指针</strong>和<strong>数组长度</strong>（数组才有）。</p>
<p><code>mark word</code>包含：对象的哈希码、分代年龄和锁标志位。</p>
<p>对象的实例数据就是 Java 对象的属性和值。</p>
<p>对齐填充字节：因为JVM要求对象占的内存大小是 8bit 的倍数，因此后面有几个字节用于把对象的大小补齐至 8bit 的倍数。</p>
<p><strong>内存对齐的主要作用是：</strong></p>
<ol>
<li>平台原因：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</li>
<li>性能原因：经过内存对齐后，CPU的内存访问速度大大提升。</li>
</ol>
<h2 id="Object-o-new-Object-占用多少个字节？"><a href="#Object-o-new-Object-占用多少个字节？" class="headerlink" title="Object o &#x3D; new Object()占用多少个字节？"></a>Object o &#x3D; new Object()占用多少个字节？</h2><p>答案是16个字节。</p>
<p>首先先分析对象的内存布局。</p>
<p>在 JVM 中，Java对象保存在堆中时，由以下三部分组成：</p>
<p><strong>对象头（Object Header）</strong>：包括关于堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。由两个词<code>mark word</code>和<code>classpointer</code>组成，如果是数组对象的话，还会有一个<code>length field</code>。</p>
<ul>
<li>mark word：通常是一组位域，用于存储对象自身的运行时数据，如hashCode、GC分代年龄、锁同步信息等等。占用64个比特（64位系统），8个字节。</li>
<li>classpointer：类指针，是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。占用64个比特（64位系统），8个字节。开启压缩类指针后，占用32个比特，4个字节。</li>
</ul>
<p><strong>实例数据（Instance Data）</strong>：存储了代码中定义的各种字段的内容，包括从父类继承下来的字段和子类中定义的字段。如果对象无属性字段，则这里就不会有数据。根据字段类型的不同占不同的字节，例如boolean类型占1个字节，int类型占4个字节等等。为了提高存储空间的利用率，这部分数据的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。</p>
<p><strong>对齐填充（Padding）</strong>：对象可以有对齐数据也可以没有。默认情况下，Java虚拟机堆中对象的起始地址需要对齐至8的整数倍。如果一个对象的对象头和实例数据占用的总大小不到8字节的整数倍，则以此来填充对象大小至8字节的整数倍。</p>
<blockquote>
<p><strong>为什么要对齐填充</strong>？字段内存对齐的其中一个原因，是让字段只出现在同一CPU的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。其实对其填充的最终目的是为了计算机<strong>高效寻址</strong>。</p>
</blockquote>
<p>经过上面的分析之后，就可以知道Object o &#x3D; new Object()具体占用多少内存了（以64位系统为例）。</p>
<ul>
<li><strong>在开启指针压缩的情况下</strong>，markword占用8字节，classpointer占用4字节，Instance data无数据，总共是12字节，由于对象需要为8的整数倍，Padding会补充4个字节，总共占用16字节。</li>
<li><strong>在没有开启指针压缩的情况下</strong>，markword占用8字节，classpointer占用8字节，Instance data无数据，也是占用16字节。</li>
</ul>
<h2 id="main方法执行过程"><a href="#main方法执行过程" class="headerlink" title="main方法执行过程"></a>main方法执行过程</h2><p>以下是示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;茶白&quot;</span>);</span><br><span class="line">        p.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>main</code>方法的过程如下:</p>
<ol>
<li>编译<code>Application.java</code>后得到 <code>Application.class</code> 后，执行这个<code>class</code>文件，系统会启动一个 <code>JVM</code> 进程，从类路径中找到一个名为 <code>Application.class</code> 的二进制文件，将 <code>Application</code> 类信息加载到运行时数据区的方法区内，这个过程叫做类的加载。</li>
<li>JVM 找到 <code>Application</code> 的主程序入口，执行<code>main</code>方法。</li>
<li><code>main</code>方法的第一条语句为 <code>Person p = new Person(&quot;茶白&quot;)</code>，就是让 JVM 创建一个<code>Person</code>对象，但是这个时候方法区中是没有 <code>Person</code> 类的信息的，所以 JVM 马上加载 <code>Person</code> 类，把 <code>Person</code> 类的信息放到方法区中。</li>
<li>加载完 <code>Person</code> 类后，JVM 在堆中分配内存给 <code>Person</code> 对象，然后调用构造函数初始化 <code>Person</code> 对象，这个 <code>Person</code> 对象持有<strong>指向方法区中的 Person 类的类型信息</strong>的引用。</li>
<li>执行<code>p.getName()</code>时，JVM 根据 p 的引用找到 p 所指向的对象，然后根据此对象持有的引用定位到方法区中 <code>Person</code> 类的类型信息的方法表，获得 <code>getName()</code> 的字节码地址。</li>
<li>执行<code>getName()</code>方法。</li>
</ol>
<h2 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h2><ol>
<li><strong>类加载检查</strong>：当虚拟机遇到一条 <code>new</code> 指令时，首先检查是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那先执行类加载。</li>
<li><strong>分配内存</strong>：在类加载检查通过后，接下来虚拟机将为对象实例分配内存。</li>
<li><strong>初始化</strong>。分配到的内存空间都初始化为零值，通过这个操作保证了对象的字段可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li><strong>设置对象头</strong>。<code>Hotspot</code> 虚拟机的对象头包括：存储对象自身的运行时数据（哈希码、分代年龄、锁标志等等）、类型指针和数据长度（数组对象才有），类型指针就是对象指向它的类信息的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
<li><strong>按照<code>Java</code>代码进行初始化</strong>。</li>
</ol>
<h2 id="如何排查-OOM-的问题？"><a href="#如何排查-OOM-的问题？" class="headerlink" title="如何排查 OOM 的问题？"></a>如何排查 OOM 的问题？</h2><blockquote>
<p>线上JVM必须配置<code>-XX:+HeapDumpOnOutOfMemoryError</code> 和<code>-XX:HeapDumpPath=/tmp/heapdump.hprof</code>，当OOM发生时自动 dump 堆内存信息到指定目录</p>
</blockquote>
<p>排查 OOM 的方法如下：</p>
<ul>
<li>查看服务器运行日志日志，捕捉到内存溢出异常</li>
<li>jstat 查看监控JVM的内存和GC情况，评估问题大概出在什么区域</li>
<li>使用MAT工具载入dump文件，分析大对象的占用情况</li>
</ul>
<h2 id="什么是内存溢出和内存泄露？"><a href="#什么是内存溢出和内存泄露？" class="headerlink" title="什么是内存溢出和内存泄露？"></a>什么是内存溢出和内存泄露？</h2><p>内存溢出指的是程序申请内存时，<strong>没有足够的内存</strong>供申请者使用，比如给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM，即内存溢出。</p>
<p>内存泄露是指程序中间动态分配了内存，但在程序结束时没有释放这部分内存，从而造成那部分<strong>内存不可用</strong>的情况。这种情况重启计算机可以解决，但也有可能再次发生内存泄露。内存泄露和硬件没有关系，它是由软件设计缺陷引起的。</p>
<p>像IO操作或者网络连接等，在使用完成之后没有调用close()方法将其连接关闭，那么它们占用的内存是不会自动被GC回收的，此时就会产生内存泄露。</p>
<p>比如操作数据库时，通过SessionFactory获取一个session：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Session session=sessionFactory.openSession();</span><br></pre></td></tr></table></figure>

<p>完成后我们必须调用session.close()方法关闭，否则就会产生内存泄露，因为sessionFactory这个长生命周期对象一直持有session这个短生命周期对象的引用。</p>
<p>那两者有什么不同呢？</p>
<p>内存泄露可以通过完善代码来避免，内存溢出可以通过调整配置来减少发生频率，但无法彻底避免。</p>
<p>如何避免内存泄露和溢出呢？</p>
<ol>
<li><strong>尽早释放无用对象的引用</strong>。比如使用临时变量的时候，让引用变量在退出活动域后自动设置为null，暗示垃圾收集器来收集该对象，防止发生内存泄露。</li>
<li><strong>尽量少用静态变量</strong>。因为静态变量是全局的，GC不会回收。</li>
<li><strong>避免集中创建对象尤其是大对象</strong>，如果可以的话尽量使用流操作。</li>
<li>尽量运用<strong>池化技术</strong>（数据库连接池等）以提高系统性能。</li>
<li><strong>避免在循环中创建过多对象</strong>。</li>
</ol>
<h1 id="java8"><a href="#java8" class="headerlink" title="java8"></a>java8</h1><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>面向对象编程：面向对象的语言，一切皆对象，如果想要调用一个函数，函数必须属于一个类或对象，然后在使用类或对象进行调用。面向对象编程可能需要多写很多重复的代码行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do something...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数式编程：在某些编程语言中，如js、c++，我们可以直接写一个函数，然后在需要的时候进行调用，即函数式编程。</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>在Java8以前，使用<code>Collections</code>的sort方法对字符串排序的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;dabin&quot;</span>, <span class="string">&quot;tyson&quot;</span>, <span class="string">&quot;sophia&quot;</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Java8 推荐使用lambda表达式，简化这种写法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;dabin&quot;</span>, <span class="string">&quot;tyson&quot;</span>, <span class="string">&quot;sophia&quot;</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a)); <span class="comment">//简化写法一</span></span><br><span class="line">names.sort((a, b) -&gt; b.compareTo(a)); <span class="comment">//简化写法二，省略入参类型，Java 编译器能够根据类型推断机制判断出参数类型</span></span><br></pre></td></tr></table></figure>

<p>可以看到使用lambda表示式之后，代码变得很简短并且易于阅读。</p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>Functional Interface：函数式接口，只包含一个抽象方法的接口。只有函数式接口才能缩写成 Lambda 表达式。@FunctionalInterface 定义类为一个函数式接口，如果添加了第二个抽象方法，编译器会立刻抛出错误提示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Converter</span>&lt;F, T&gt; &#123;</span><br><span class="line">    T <span class="title function_">convert</span><span class="params">(F from)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionalInterfaceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">converted</span> <span class="operator">=</span> converter.convert(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(converted);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * output</span></span><br><span class="line"><span class="comment">     * 666</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内置的函数式接口"><a href="#内置的函数式接口" class="headerlink" title="内置的函数式接口"></a>内置的函数式接口</h2><p>Comparator 和 Runnable，Java 8 为他们都添加了 @FunctionalInterface 注解，以用来支持 Lambda 表达式。</p>
<h3 id="Predicate-断言"><a href="#Predicate-断言" class="headerlink" title="Predicate 断言"></a>Predicate 断言</h3><p>指定入参类型，并返回 boolean 值的函数式接口。用来组合一个复杂的逻辑判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">predicate.test(<span class="string">&quot;dabin&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><p>Java8 将 Comparator 升级成函数式接口，可以使用lambda表示式简化代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-05 23:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComparatorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Comparator&lt;Person&gt; comparator = Comparator.comparing(p -&gt; p.firstName);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;dabin&quot;</span>, <span class="string">&quot;wang&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xiaobin&quot;</span>, <span class="string">&quot;wang&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印-20</span></span><br><span class="line">        System.out.println(comparator.compare(p1, p2));</span><br><span class="line">        <span class="comment">// 打印20</span></span><br><span class="line">        System.out.println(comparator.reversed().compare(p1, p2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String firstName, String lastName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>Consumer 接口接收一个泛型参数，然后调用 accept，对这个参数做一系列消费操作。</p>
<p>Consumer 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-05 23:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Consumer&lt;Integer&gt; consumer = x -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x + <span class="number">6</span>;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            System.out.println(<span class="string">&quot;茶白&quot;</span> + a);</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer.accept(<span class="number">660</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * output</span></span><br><span class="line"><span class="comment">     * 666</span></span><br><span class="line"><span class="comment">     * 茶白666</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例2：在stream里，对入参做一些操作，主要是用于forEach，对传入的参数，做一系列的业务操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CopyOnWriteArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) elements[i];</span><br><span class="line">        action.accept(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CopyOnWriteArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//forEach需要传入Consumer参数</span></span><br><span class="line">list</span><br><span class="line">    .stream()</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>示例3：addThen方法使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-05 23:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumersTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Consumer&lt;Integer&gt; consumer1 = x -&gt; System.out.println(<span class="string">&quot;first x : &quot;</span> + x);</span><br><span class="line">        Consumer&lt;Integer&gt; consumer2 = x -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;second x : &quot;</span> + x);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;throw exception second&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        Consumer&lt;Integer&gt; consumer3 = x -&gt; System.out.println(<span class="string">&quot;third x : &quot;</span> + x);</span><br><span class="line"></span><br><span class="line">        consumer1.andThen(consumer2).andThen(consumer3).accept(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * output</span></span><br><span class="line"><span class="comment">     * first x : 1</span></span><br><span class="line"><span class="comment">     * second x : 1</span></span><br><span class="line"><span class="comment">     * Exception in thread &quot;main&quot; java.lang.NullPointerException: throw exception second</span></span><br><span class="line"><span class="comment">     * 	at com.dabin.java8.ConsumersTest.lambda$main$1(ConsumersTest.java:15)</span></span><br><span class="line"><span class="comment">     * 	...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>使用 <code>java.util.Stream</code> 对一个包含一个或多个元素的集合做各种操作，原集合不变，返回新集合。只能对实现了 <code>java.util.Collection</code> 接口的类做流的操作。<code>Map</code> 不支持 <code>Stream</code> 流。<code>Stream</code> 流支持同步执行，也支持并发执行。</p>
<h3 id="Filter-过滤"><a href="#Filter-过滤" class="headerlink" title="Filter 过滤"></a>Filter 过滤</h3><p>Filter<code>的入参是一个</code>Predicate，用于筛选出我们需要的集合元素。原集合不变。filter 会过滤掉不符合特定条件的，下面的代码会过滤掉<code>nameList</code>中不以茶白开头的字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-06 00:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        nameList.add(<span class="string">&quot;茶白1&quot;</span>);</span><br><span class="line">        nameList.add(<span class="string">&quot;茶白2&quot;</span>);</span><br><span class="line">        nameList.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        nameList.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nameList</span><br><span class="line">                .stream()</span><br><span class="line">                .filter((s) -&gt; s.startsWith(<span class="string">&quot;茶白&quot;</span>))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * output</span></span><br><span class="line"><span class="comment">     * 茶白1</span></span><br><span class="line"><span class="comment">     * 茶白2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sorted-排序"><a href="#Sorted-排序" class="headerlink" title="Sorted 排序"></a>Sorted 排序</h3><p>自然排序，不改变原集合，返回排序后的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-06 00:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        nameList.add(<span class="string">&quot;茶白3&quot;</span>);</span><br><span class="line">        nameList.add(<span class="string">&quot;茶白1&quot;</span>);</span><br><span class="line">        nameList.add(<span class="string">&quot;茶白2&quot;</span>);</span><br><span class="line">        nameList.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        nameList.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nameList</span><br><span class="line">                .stream()</span><br><span class="line">                .filter((s) -&gt; s.startsWith(<span class="string">&quot;茶白&quot;</span>))</span><br><span class="line">                .sorted()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * output</span></span><br><span class="line"><span class="comment">     * 茶白1</span></span><br><span class="line"><span class="comment">     * 茶白2</span></span><br><span class="line"><span class="comment">     * 茶白3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逆序排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nameList</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted(Comparator.reverseOrder());</span><br></pre></td></tr></table></figure>

<p>对元素某个字段排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.stream().sorted(Comparator.comparing(Student::getAge).reversed());</span><br><span class="line">list.stream().sorted(Comparator.comparing(Student::getAge));</span><br></pre></td></tr></table></figure>

<h3 id="Map-转换"><a href="#Map-转换" class="headerlink" title="Map 转换"></a>Map 转换</h3><p>将每个字符串转为大写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-06 00:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        nameList.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        nameList.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nameList</span><br><span class="line">                .stream()</span><br><span class="line">                .map(String::toUpperCase)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * output</span></span><br><span class="line"><span class="comment">     * AAA</span></span><br><span class="line"><span class="comment">     * BBB</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Match-匹配"><a href="#Match-匹配" class="headerlink" title="Match 匹配"></a>Match 匹配</h3><p>验证 nameList 中的字符串是否有以<code>茶白</code>开头的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-06 00:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        nameList.add(<span class="string">&quot;茶白1&quot;</span>);</span><br><span class="line">        nameList.add(<span class="string">&quot;茶白2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">startWithDabin</span> <span class="operator">=</span></span><br><span class="line">                nameList</span><br><span class="line">                    .stream()</span><br><span class="line">                    .map(String::toUpperCase)</span><br><span class="line">                    .anyMatch((s) -&gt; s.startsWith(<span class="string">&quot;茶白&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(startWithDabin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * output</span></span><br><span class="line"><span class="comment">     * true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Count-计数"><a href="#Count-计数" class="headerlink" title="Count 计数"></a>Count 计数</h3><p>统计 <code>stream</code> 流中的元素总数，返回值是 <code>long</code> 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-06 00:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        nameList.add(<span class="string">&quot;茶白1&quot;</span>);</span><br><span class="line">        nameList.add(<span class="string">&quot;茶白2&quot;</span>);</span><br><span class="line">        nameList.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span></span><br><span class="line">                nameList</span><br><span class="line">                    .stream()</span><br><span class="line">                    .map(String::toUpperCase)</span><br><span class="line">                    .filter((s) -&gt; s.startsWith(<span class="string">&quot;茶白&quot;</span>))</span><br><span class="line">                    .count();</span><br><span class="line"></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * output</span></span><br><span class="line"><span class="comment">     * 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><p>类似拼接。可以实现将 <code>list</code> 归约成一个值。它的返回类型是 <code>Optional</code> 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-06 00:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        nameList.add(<span class="string">&quot;茶白1&quot;</span>);</span><br><span class="line">        nameList.add(<span class="string">&quot;茶白2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Optional&lt;String&gt; reduced =</span><br><span class="line">                nameList</span><br><span class="line">                        .stream()</span><br><span class="line">                        .sorted()</span><br><span class="line">                        .reduce((s1, s2) -&gt; s1 + <span class="string">&quot;#&quot;</span> + s2);</span><br><span class="line"></span><br><span class="line">        reduced.ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * output</span></span><br><span class="line"><span class="comment">     * 茶白1#茶白2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>flatMap 用于将多个Stream连接成一个Stream。</p>
<p>下面的例子，把几个小的list转换到一个大的list。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 把几个小的list转换到一个大的list。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-06 00:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; team1 = Arrays.asList(<span class="string">&quot;茶白1&quot;</span>, <span class="string">&quot;茶白2&quot;</span>, <span class="string">&quot;茶白3&quot;</span>);</span><br><span class="line">        List&lt;String&gt; team2 = Arrays.asList(<span class="string">&quot;茶白4&quot;</span>, <span class="string">&quot;茶白5&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; players = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        players.add(team1);</span><br><span class="line">        players.add(team2);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; flatMapList = players.stream()</span><br><span class="line">                .flatMap(pList -&gt; pList.stream())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(flatMapList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * output</span></span><br><span class="line"><span class="comment">     * [大彬1, 茶白2, 茶白3, 茶白4, 茶白5]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的例子中，将words数组中的元素按照字符拆分，然后对字符去重。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-06 00:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        words.add(<span class="string">&quot;茶白最强&quot;</span>);</span><br><span class="line">        words.add(<span class="string">&quot;茶白666&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将words数组中的元素按照字符拆分，然后对字符去重</span></span><br><span class="line">        List&lt;String&gt; stringList = words.stream()</span><br><span class="line">                .flatMap(word -&gt; Arrays.stream(word.split(<span class="string">&quot;&quot;</span>)))</span><br><span class="line">                .distinct()</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        stringList.forEach(e -&gt; System.out.print(e + <span class="string">&quot;, &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * output</span></span><br><span class="line"><span class="comment">     * 大, 彬, 最, 强, 6,</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>著作权归茶白所有 原文链接：<a target="_blank" rel="noopener" href="https://www.topjavaer.cn/java/java8/5-stream.html">https://www.topjavaer.cn/java/java8/5-stream.html</a></p>
<h2 id="Parallel-Streams"><a href="#Parallel-Streams" class="headerlink" title="Parallel-Streams"></a>Parallel-Streams</h2><p>并行流。<code>stream</code> 流是支持<strong>顺序</strong>和<strong>并行</strong>的。顺序流操作是单线程操作，串行化的流无法带来性能上的提升，通常我们会使用多线程来并行执行任务，处理速度更快。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-06 00:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        List&lt;String&gt; strs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(max);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="type">UUID</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID();</span><br><span class="line">            strs.add(uuid.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; sortedStrs = strs.stream().sorted().collect(Collectors.toList());</span><br><span class="line">        System.out.println(sortedStrs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * output</span></span><br><span class="line"><span class="comment">     * [029be6d0-e77e-4188-b511-f1571cdbf299, 02d97425-b696-483a-80c6-e2ef51c05d83, 0632f1e9-e749-4bce-8bac-1cf6c9e93afa, ...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>Java8 针对 map 操作增加了一些方法，非常方便</p>
<p>1、删除元素使用<code>removeIf()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-07 00:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;dabin1&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;dabin2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除value没有含有1的键值对</span></span><br><span class="line">        map.values().removeIf(value -&gt; !value.contains(<span class="string">&quot;1&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * output</span></span><br><span class="line"><span class="comment">     * &#123;1=dabin1&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<code>putIfAbsent(key, value) </code> 如果指定的 key 不存在，则 put 进去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-07 00:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;茶白1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            map.putIfAbsent(i, <span class="string">&quot;茶白&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        map.forEach((id, val) -&gt; System.out.print(val + <span class="string">&quot;, &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * output</span></span><br><span class="line"><span class="comment">     * 茶白0, 茶白1, 茶白2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、map 转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-07 08:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;2&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; newMap = map.entrySet().stream()</span><br><span class="line">                .collect(Collectors.toMap(e -&gt; e.getKey(), e -&gt; <span class="string">&quot;茶白&quot;</span> + String.valueOf(e.getValue())));</span><br><span class="line"></span><br><span class="line">        newMap.forEach((key, val) -&gt; System.out.print(val + <span class="string">&quot;, &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * output</span></span><br><span class="line"><span class="comment">     * 茶白1, 茶白2,</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、map遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 茶白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-07 08:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;茶白1&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;茶白2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式1</span></span><br><span class="line">        map.keySet().forEach(k -&gt; &#123;</span><br><span class="line">            System.out.print(map.get(k) + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式2</span></span><br><span class="line">        map.entrySet().iterator().forEachRemaining(e -&gt; System.out.print(e.getValue() + <span class="string">&quot;, &quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式3</span></span><br><span class="line">        map.entrySet().forEach(entry -&gt; &#123;</span><br><span class="line">            System.out.print(entry.getValue() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式4</span></span><br><span class="line">        map.values().forEach(v -&gt; &#123;</span><br><span class="line">            System.out.print(v + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>首先，看一下整个架构图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041101996.png" alt="img"></p>
<p>接下来简单解释一下。</p>
<p><strong>Server</strong>：服务器。Tomcat 就是一个 Server 服务器。</p>
<p><strong>Service</strong>：在服务器中可以有多个 Service，只不过在我们常用的这套 Catalina 容器的Tomcat 中只包含一个 Service，在 Service 中包含连接器和容器。一个完整的 Service 才能完成对请求的接收和处理。</p>
<p><strong>连接器</strong>：Coyote 是连接器具体的实现。用于与新来的请求建立连接并解析数据。因为 Tomcat 支持的 IO 模型有 NIO、NIO2、APR，而支持的应用层协议有 HTTP1.1、HTTP2、AJP。所以针对不同的 IO 模型和应用层协议请求，在一个 Service 中可以有多个连接器来适用不同的协议的IO请求。</p>
<p>EndPoint ：Coyote 通信端点，即通信监听的接口，是具体 Socket 接收和发送处理器，是用来实现 TCP&#x2F;IP 传输协议的。</p>
<p>Acceptor：用于接收请求的 socket。</p>
<p>Executor：线程池，在接收到请求的 socket 后会从线程池中分配一条来执行后面的操作。</p>
<p>Processor ：Coyote 协议处理接口，是用来实现 HTTP 应用层协议的，接收 EndPoint 、容器传来的 Socket 字节流，解析成 request 或 response 对象。</p>
<p>ProtocolHandler：Coyote 协议接口，通过 EndPoint 和 Processor，实现针对具体协议的处理能力。</p>
<p>Adapter：容器只负责处理数据，对于请求协议不同的数据，容器会无法处理，所以在 ProtocolHandler 处理生成的 request 对象后，还需要将其转成 Tomcat 定义好的统一格式的 ServletRequest 对象，Adapter 就是用来进行这样的操作的。</p>
<p><strong>容器</strong>： Tomcat 的核心组件， 用于处理请求并返回数据。Catalina 是其具体的实现。</p>
<p>Engine：表示整个 Catalina 的 Servlet 引擎，用来管理多个虚拟站点，一个 Service 最多只能有一个 Engine。但是一个 Engine 可以包含多个 Host。</p>
<p>Host：表示一个主机地址，或者说一个站点，一个 Host 下有可以配置多个 Context。</p>
<p>Context：表示一个 web 应用，一个 Web 应用可以包含多个 Wrapper</p>
<p>Wrapper：表示一个 Servlet，是容器中的最底层组件。</p>
<p>各组件的比例关系</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041102664.png" alt="img"></p>
<h2 id="各组件的实现与执行"><a href="#各组件的实现与执行" class="headerlink" title="各组件的实现与执行"></a>各组件的实现与执行</h2><h3 id="组件实现"><a href="#组件实现" class="headerlink" title="组件实现"></a>组件实现</h3><p>前面提到的各个组件名都是接口或者抽象方法，在实际处理请求时执行的都是其子类或者实现类。</p>
<p>Server、Service、Engine、Host、Context都是接口， 下图中罗列了这些接口的默认 实现类。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041102161.png" alt="img"></p>
<p>Adapter 的实现是 CoyoteAdapter</p>
<p>对于 Endpoint组件来说，在Tomcat中没有对应的Endpoint接口， 但是有一个抽象类AbstractEndpoint ，其下有三个实现类： NioEndpoint、Nio2Endpoint、AprEndpoint ， 这三个实现类，分别对应于前面讲解链接器 Coyote 时， 提到的链接器支持的三种IO模型：NIO，NIO2，APR ，tomcat8.5版本中，默认采用的是 NioEndpoint。</p>
<p>ProtocolHandler ： Coyote协议接口，通过封装Endpoint和Processor ， 实现针对具体协议的处理功能。Tomcat按照协议和IO提供了6个实现类。</p>
<p>AJP协议：</p>
<p>1） AjpNioProtocol ：采用NIO的IO模型。</p>
<p>2） AjpNio2Protocol：采用NIO2的IO模型。</p>
<p>3） AjpAprProtocol ：采用APR的IO模型，需要依赖于APR库。</p>
<p>HTTP协议：</p>
<p>1） Http11NioProtocol ：采用NIO的IO模型，默认使用的协议（如果服务器没有安装APR）。</p>
<p>2） Http11Nio2Protocol：采用NIO2的IO模型。</p>
<p>3） Http11AprProtocol ：采用APR的IO模型，需要依赖于APR库。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041102287.png" alt="img"></p>
<p>这些组件均存在初始化、启动、停止等周期方法，所以 Tomcat 设计了一个 LifeCycle 接口，用于定义这些组件生命周期中需要执行的共同方法，这些组件实现类都实现了这个接口。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041103085.png" alt="img"></p>
<h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041103964.png" alt="img"></p>
<p>1） 启动tomcat ， 需要调用 bin&#x2F;startup.bat (在linux 目录下 , 需要调用 bin&#x2F;startup.sh) ， 在</p>
<p>startup.bat 脚本中, 调用了catalina.bat。</p>
<p>2） 在catalina.bat 脚本文件中，调用了BootStrap 中的main方法。</p>
<p>3）在BootStrap 的main 方法中调用了 init 方法 ， 来创建Catalina 及 初始化类加载器。</p>
<p>4）在BootStrap 的main 方法中调用了 load 方法 ， 在其中又调用了Catalina的load方法。</p>
<p>5）在Catalina 的load 方法中 , 需要进行一些初始化的工作, 并需要构造Digester 对象, 用于解析 XML。</p>
<p>6） 然后在调用后续组件的初始化操作 。。。</p>
<p>加载Tomcat的配置文件，初始化容器组件 ，监听对应的端口号， 准备接受客户端请求 。</p>
<p>简而言之就是进行各组件逐级执行 init() 和 start() 方法。</p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>当一个请求进入 Tomcat 时，执行情况如下( 因为 Tomcat 只有一个 Service，所以下面就将 Service 和 Engine 写在同一个框中）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041103891.png" alt="img"></p>
<p>定位主要通过 Mapper 组件来实现，其本质就是一个 K、V键值对，在解析时首先会将请求网址进行解析，将其中的 Host 部分在 Mapper 类中的 hosts属性（MappedHost数组，保存所有的 Host 信息）中进行查找，找到后再解析 Context 部分，在该 MapperHost 中又有 contextList 属性（保存所有的 context 信息），然后再向下找，最终得到对应的 Servlet，执行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041103701.png" alt="img"></p>
<p>除此之外，为了增强各组件之间的拓展性，Tomcat 中定义了 Pipeline 和 Valve 两个接口，Pipeline 用于构建责任链， 后者代表责任链上的每个处理器。Pipeline 中维护了一个基础的 Valve，它始终位于Pipeline的末端（最后执行），封装了具体的请求处理和输出响应的过程。当然，我们也可以调用addValve()方法， 为Pipeline 添加其他的Valve，后添加的Valve 位于基础的Valve之前，并按照添加顺序执行。Pipiline通过获得首个Valve来启动整合链条的执行 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041104675.png" alt="img"></p>
<p>所以最终的执行如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041104148.png" alt="img"></p>
<p>步骤如下:</p>
<p>1）Connector组件Endpoint中的Acceptor监听客户端套接字连接并接收Socket。</p>
<p>2）将连接交给线程池Executor处理，开始执行请求响应任务。</p>
<p>3）Processor组件读取消息报文，解析请求行、请求体、请求头，封装成Request对象。</p>
<p>4）Mapper组件根据请求行的URL值和请求头的Host值匹配由哪个Host容器、Context容器、Wrapper容器处理请求。</p>
<p>5）CoyoteAdaptor组件负责将Connector组件和Engine容器关联起来，把生成的Request对象和响应对象Response传递到Engine容器中，调用 Pipeline。</p>
<p>6）Engine容器的管道开始处理，管道中包含若干个Valve、每个Valve负责部分处理逻辑。执行完Valve后会执行基础的 Valve–StandardEngineValve，负责调用Host容器的Pipeline。</p>
<p>7）Host容器的管道开始处理，流程类似，最后执行 Context容器的Pipeline。</p>
<p>8）Context容器的管道开始处理，流程类似，最后执行 Wrapper容器的Pipeline。</p>
<p>9）Wrapper容器的管道开始处理，流程类似，最后执行 Wrapper容器对应的Servlet对象的处理方法。</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>首先看一下 tomcat 的目录结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041104182.png" alt="img"></p>
<p>核心配置文件在 conf 目录下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041104312.png" alt="img"></p>
<h3 id="Server-xml-重点"><a href="#Server-xml-重点" class="headerlink" title="Server.xml(重点)"></a>Server.xml(重点)</h3><p>其中最重要的就是 server.xml，主要配置了 tomcat 容器的所有配置。下面来看一下其中有哪些配置。</p>
<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a><strong>Server</strong></h4><p>是 server.xml 的根元素，用于创建一个 Server 实例，默认的实现是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Server</span> port=<span class="string">&quot;8005&quot;</span> shutdown=<span class="string">&quot;SHUTDOWN&quot;</span>&gt; </span><br><span class="line">... </span><br><span class="line">&lt;/<span class="title class_">Server</span>&gt;</span><br></pre></td></tr></table></figure>

<p>port：Tomcat监听的关闭服务器的端口</p>
<p>shutdown：关闭服务器的指令字符串。</p>
<p><strong>Server 内嵌的子元素为 Listener、GlobalNamingResources、Service。</strong></p>
<p>配置的5个Listener 的含义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 用于以日志形式输出服务器 、操作系统、<span class="variable constant_">JVM</span>的版本信息 --&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.startup.VersionLoggerListener&quot;</span> /&gt;</span></span> </span><br><span class="line"></span><br><span class="line">&lt;!-- 用于加载（服务器启动） 和 销毁 （服务器停止） <span class="variable constant_">APR</span>。 如果找不到<span class="variable constant_">APR</span>库， 则会输出日志， 并 不影响<span class="title class_">Tomcat</span>启动 --&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.AprLifecycleListener&quot;</span> <span class="attr">SSLEngine</span>=<span class="string">&quot;on&quot;</span> /&gt;</span></span> </span><br><span class="line"></span><br><span class="line">&lt;!-- 用于避免<span class="variable constant_">JRE</span>内存泄漏问题 --&gt;</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 用户加载（服务器启动） 和 销毁（服务器停止） 全局命名服务 --&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot;</span> /&gt;</span></span> </span><br><span class="line"></span><br><span class="line">&lt;!-- 用于在<span class="title class_">Context</span>停止时重建<span class="title class_">Executor</span> 池中的线程， 以避免<span class="title class_">ThreadLocal</span> 相关的内存泄漏 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>GlobalNamingResources 中定义了全局命名服务</p>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>用于创建 Service 实例，<strong>内嵌的元素为：Listener、Executor、Connector、Engine</strong>，其中 ： Listener 用于为Service添加生命周期监听器， Executor 用于配置Service 共享线程池，Connector 用于配置Service 包含的链接器， Engine 用于配置Service中链接器对应的Servlet 容器引擎。默认 Service 就叫 Catalina。</p>
<h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><p>默认情况，Service 并未配置共享线程池，各个连接器使用的都是各自的线程池（默认size为10）。如果我们想添加一个线程池，可以在 Service 标签中添加如下配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Executor</span> name=<span class="string">&quot;tomcatThreadPool&quot;</span> </span><br><span class="line">    namePrefix=<span class="string">&quot;catalina-exec-&quot;</span> </span><br><span class="line">    maxThreads=<span class="string">&quot;200&quot;</span> </span><br><span class="line">    minSpareThreads=<span class="string">&quot;100&quot;</span> </span><br><span class="line">    maxIdleTime=<span class="string">&quot;60000&quot;</span> </span><br><span class="line">    maxQueueSize=<span class="string">&quot;Integer.MAX_VALUE&quot;</span>                 </span><br><span class="line">　　 prestartminSpareThreads=<span class="string">&quot;false&quot;</span> threadPriority=<span class="string">&quot;5&quot;</span> </span><br><span class="line">　　className=<span class="string">&quot;org.apache.catalina.core.StandardThreadExecutor&quot;</span>/&gt;    </span><br></pre></td></tr></table></figure>

<p>相关属性说明：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041105579.png" alt="img"></p>
<h4 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h4><p>用于创建连接器实例，默认情况下，server.xml 配置了两个连接器，一个支持 HTTP 协议，一个支持 AJP 协议。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Connector</span> port=<span class="string">&quot;8080&quot;</span> protocol=<span class="string">&quot;HTTP/1.1&quot;</span> connectionTimeout=<span class="string">&quot;20000&quot;</span> redirectPort=<span class="string">&quot;8443&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8009&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;AJP/1.3&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>1） port： 端口号，Connector 用于创建服务端Socket 并进行监听， 以等待客户端请求链接。如果该属性设置为0，Tomcat将会随机选择一个可用的端口号给当前Connector 使用。</p>
<p>2） protocol ： 当前Connector 支持的访问协议。 默认为 HTTP&#x2F;1.1 ， 并采用自动切换机制选择一个基于 JAVA NIO 的链接器或者基于本地APR的链接器（根据本地是否含有Tomcat的本地库判定）。如果不希望采用上述自动切换的机制， 而是明确指定协议， 可以使用以下值。</p>
<p>Http协议：</p>
<p>org.apache.coyote.http11.Http11NioProtocol ， 非阻塞式 Java NIO 链接器</p>
<p>org.apache.coyote.http11.Http11Nio2Protocol ， 非阻塞式 JAVA NIO2 链接器</p>
<p>org.apache.coyote.http11.Http11AprProtocol ， APR 链接器</p>
<p>AJP协议：</p>
<p>org.apache.coyote.ajp.AjpNioProtocol ， 非阻塞式 Java NIO 链接器</p>
<p>org.apache.coyote.ajp.AjpNio2Protocol ，非阻塞式 JAVA NIO2 链接器</p>
<p>org.apache.coyote.ajp.AjpAprProtocol ， APR 链接器</p>
<p>3） connectionTimeOut : Connector 接收链接后的等待超时时间， 单位为 毫秒。 -1 表示不超时。</p>
<p>4） redirectPort：当前Connector 不支持SSL请求， 接收到了一个请求， 并且也符合securityconstraint 约束， 需要SSL传输，Catalina自动将请求重定向到指定的端口。</p>
<p>5） executor ： 指定共享线程池的名称， 也可以通过maxThreads、minSpareThreads 等属性配置内部线程池。</p>
<p>6） URIEncoding : 用于指定编码URI的字符编码， Tomcat8.x版本默认的编码为 UTF-8 , Tomcat7.x版本默认为ISO-8859-1。</p>
<h4 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h4><p>Engine 作为Servlet 引擎的顶级元素，内部可以嵌入： Cluster、Listener、Realm、Valve和 Host。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Engine</span> name=<span class="string">&quot;Catalina&quot;</span> defaultHost=<span class="string">&quot;localhost&quot;</span>&gt; </span><br><span class="line">...</span><br><span class="line">&lt;/<span class="title class_">Engine</span>&gt;</span><br></pre></td></tr></table></figure>

<p>1） name： 用于指定Engine 的名称， 默认为Catalina 。该名称会影响一部分Tomcat的存储路径（如临时文件）。</p>
<p>2） defaultHost ： 默认使用的虚拟主机名称， 当客户端请求指向的主机无效时， 将交由默认的虚拟主机处理， 默认为localhost。 <strong>在 ip 地址解析时首先根据defaultHost 设置的 Host从 Host 列表中找对用的 Host 跳转，如果没有再从 Host 列表中查找对应的，如果列表中没有，那么就会访问不到。</strong></p>
<p>除此之外，在默认的配置文件中还包含 Realn 标签，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Realm</span> className=<span class="string">&quot;org.apache.catalina.realm.LockOutRealm&quot;</span>&gt;</span><br><span class="line">        &lt;!-- <span class="title class_">This</span> <span class="title class_">Realm</span> uses the <span class="title class_">UserDatabase</span> configured <span class="keyword">in</span> the <span class="variable language_">global</span> <span class="variable constant_">JNDI</span></span><br><span class="line">             resources under the key <span class="string">&quot;UserDatabase&quot;</span>.  <span class="title class_">Any</span> edits</span><br><span class="line">             that are performed against <span class="variable language_">this</span> <span class="title class_">UserDatabase</span> are immediately</span><br><span class="line">             available <span class="keyword">for</span> use by the <span class="title class_">Realm</span>.  --&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span> <span class="attr">resourceName</span>=<span class="string">&quot;UserDatabase&quot;</span>/&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Realm</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- Editable user database that can also be used by</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">         UserDatabaseRealm to authenticate users</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">auth</span>=<span class="string">&quot;Container&quot;</span> <span class="attr">description</span>=<span class="string">&quot;User database that can be updated and saved&quot;</span> <span class="attr">factory</span>=<span class="string">&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</span> <span class="attr">name</span>=<span class="string">&quot;UserDatabase&quot;</span> <span class="attr">pathname</span>=<span class="string">&quot;conf/tomcat-users.xml&quot;</span> <span class="attr">type</span>=<span class="string">&quot;org.apache.catalina.UserDatabase&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><code>&lt;Realm&gt;</code> 标签是用来配置用户权限的。</p>
<p>首先说一下 tomcat 的权限管理。因为在 tomcat 中可以配置多个 web 项目，而 tomcat 为这些项目的管理创建了管理页面，也就是默认 webapps 下 host-manager 与 manager 文件夹的项目页面，为了保证安全性，访问这两个项目需要设置权限，但是如果对每个新用户都单独的设置权限比较繁琐麻烦，所以在 tomcat 中定义了几种不同的权限，我们可以自己配置 “角色”(可以看作是特定权限的集合) 和 “用户”(设置登录名、密码，与角色相关联)，然后就可以通过自定义的 “用户” 去访问管理页面。”角色” 和 “用户” 的配置默认可以在 tomcat-users.xml 中配置。当 tomcat 启动后，就会通过 conf 目录下的 server.xml 中的 Realm 标签来检查权限。</p>
<p><code>&lt;Realm&gt;</code> 支持多种 Realm 管理方式：</p>
<p>1 JDBCRealm 用户授权信息存储于某个关系型数据库中，通过JDBC驱动获取信息验证</p>
<p>2 DataSourceRealm 用户授权信息存储于关于型数据中，通过JNDI配置JDBC数据源的方式获取信息验证</p>
<p>3 JNDIRealm 用户授权信息存储在基于LDAP的目录服务的服务器中，通过JNDI驱动获取并验证</p>
<p><strong>4 UserDatabaseRealm 默认的配置方式，信息存储于XML文档中 conf&#x2F;tomcat-users.xml</strong></p>
<p>5 MemoryRealm 用户信息存储于内存的集合中，对象集合的数据来源于xml文档 conf&#x2F;tomcat-users.xml</p>
<p>6 JAASRealm 通过JAAS框架访问授权信息</p>
<p>上面代码块中可以看出Realm就是使用默认的 UserDatabaseRealm 方式配置。而它的 resourceName 就对应之前 <code>&lt;GlobalNamingResources&gt;</code> 中配置的 conf 目录下的 tomcat-users.xml 文件。</p>
<p><strong>如果在Engine下配置Realm， 那么此配置将在当前Engine下的所有Host中共享。 同样，如果在Host中配置Realm ， 则在当前Host下的所有Context中共享。底层会覆盖掉上层对同一个资源的配置。</strong></p>
<h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a><strong>Host</strong></h4><p>用于配置一个虚拟主机， 它支持以下嵌入元素：Alias、Cluster、Listener、Valve、Realm、Context。一个 Engine 标签下可以配置多个 Host。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Host</span> appBase=<span class="string">&quot;webapps&quot;</span> autoDeploy=<span class="string">&quot;true&quot;</span> name=<span class="string">&quot;localhost&quot;</span> unpackWARs=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/<span class="title class_">Host</span>&gt;</span><br></pre></td></tr></table></figure>

<p>属性说明：</p>
<p>1） name: 当前Host通用的网络名称， 必须与DNS服务器上的注册信息一致。 Engine中包含的Host必须存在一个名称与Engine的defaultHost设置一致。</p>
<p>2） appBase： 当前Host的应用基础目录， 当前Host上部署的Web应用均在该目录下（可以是绝对目录，相对路径）。默认为webapps。</p>
<p>3） unpackWARs： 设置为true， Host在启动时会将appBase目录下war包解压为目录。设置为 false， Host将直接从war文件启动。</p>
<p>4） autoDeploy： 控制tomcat是否在运行时定期检测并自动部署新增或变更的web应用。</p>
<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>用于配置一个 Web 应用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Context</span> docBase=<span class="string">&quot;myApp&quot;</span> path=<span class="string">&quot;/myApp&quot;</span>&gt; </span><br><span class="line">.... </span><br><span class="line">&lt;/<span class="title class_">Context</span>&gt;</span><br></pre></td></tr></table></figure>

<p>属性描述：</p>
<p>1） docBase：Web应用目录或者War包的部署路径。可以是绝对路径，也可以是相对于 Host appBase的相对路径。</p>
<p>2） path：Web应用的Context 路径。如果我们Host名为localhost， 则该web应用访问的根路径为：<a target="_blank" rel="noopener" href="http://localhost:8080/myApp%E3%80%82%E5%AE%83%E6%94%AF%E6%8C%81%E7%9A%84%E5%86%85%E5%B5%8C%E5%85%83%E7%B4%A0%E4%B8%BA%EF%BC%9ACookieProcessor%EF%BC%8C">http://localhost:8080/myApp。它支持的内嵌元素为：CookieProcessor，open in new window</a> Loader， Manager，Realm，Resources，WatchedResource，JarScanner，Valve。</p>
<h3 id="tomcat-user-xml-权限管理"><a href="#tomcat-user-xml-权限管理" class="headerlink" title="tomcat-user.xml(权限管理)"></a>tomcat-user.xml(权限管理)</h3><p>上面的 realm 标签说到这个文件是配合 realm 标签来设置用户权限的，所以就来看一下具体是如何设置的。</p>
<p>首先看一下默认配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">  <span class="title class_">Licensed</span> to the <span class="title class_">Apache</span> <span class="title class_">Software</span> <span class="title class_">Foundation</span> (<span class="variable constant_">ASF</span>) under one or more</span><br><span class="line">  contributor license agreements.  <span class="title class_">See</span> the <span class="variable constant_">NOTICE</span> file distributed <span class="keyword">with</span></span><br><span class="line">  <span class="variable language_">this</span> work <span class="keyword">for</span> additional information regarding copyright ownership.</span><br><span class="line">  <span class="title class_">The</span> <span class="variable constant_">ASF</span> licenses <span class="variable language_">this</span> file to <span class="title class_">You</span> under the <span class="title class_">Apache</span> <span class="title class_">License</span>, <span class="title class_">Version</span> <span class="number">2.0</span></span><br><span class="line">  (the <span class="string">&quot;License&quot;</span>); you may not use <span class="variable language_">this</span> file except <span class="keyword">in</span> compliance <span class="keyword">with</span></span><br><span class="line">  the <span class="title class_">License</span>.  <span class="title class_">You</span> may obtain a copy <span class="keyword">of</span> the <span class="title class_">License</span> at</span><br><span class="line"></span><br><span class="line">      <span class="attr">http</span>:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"></span><br><span class="line">  <span class="title class_">Unless</span> required by applicable law or agreed to <span class="keyword">in</span> writing, software</span><br><span class="line">  distributed under the <span class="title class_">License</span> is distributed on an <span class="string">&quot;AS IS&quot;</span> <span class="variable constant_">BASIS</span>,</span><br><span class="line">  <span class="variable constant_">WITHOUT</span> <span class="variable constant_">WARRANTIES</span> <span class="variable constant_">OR</span> <span class="variable constant_">CONDITIONS</span> <span class="variable constant_">OF</span> <span class="variable constant_">ANY</span> <span class="variable constant_">KIND</span>, either express or implied.</span><br><span class="line">  <span class="title class_">See</span> the <span class="title class_">License</span> <span class="keyword">for</span> the specific language governing permissions and</span><br><span class="line">  limitations under the <span class="title class_">License</span>.</span><br><span class="line">--&gt;</span><br><span class="line">&lt;tomcat-users xmlns=&quot;http://tomcat.apache.org/xml&quot;</span><br><span class="line">              xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">              xsi:schemaLocation=&quot;http://tomcat.apache.org/xml tomcat-users.xsd&quot;</span><br><span class="line">              version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">  NOTE:  By default, no user is included in the &quot;manager-gui&quot; role required</span><br><span class="line">  to operate the &quot;/manager/html&quot; web application.  If you wish to use this app,</span><br><span class="line">  you must define such a user - the username and password are arbitrary. It is</span><br><span class="line">  strongly recommended that you do NOT use one of the users in the commented out</span><br><span class="line">  section below since they are intended for use with the examples web</span><br><span class="line">  application.</span><br><span class="line">--&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">  NOTE:  The sample user and role entries below are intended for use with the</span><br><span class="line">  examples web application. They are wrapped in a comment and thus are ignored</span><br><span class="line">  when reading this file. If you wish to configure these users for use with the</span><br><span class="line">  examples web application, do not forget to remove the &lt;!.. ..&gt; that surrounds</span><br><span class="line">  them. You will also need to set the passwords to something appropriate.</span><br><span class="line">--&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">  &lt;role rolename=&quot;tomcat&quot;/&gt;</span><br><span class="line">  &lt;role rolename=&quot;role1&quot;/&gt;</span><br><span class="line">  &lt;user username=&quot;tomcat&quot; password=&quot;&lt;must-be-changed&gt;&quot; roles=&quot;tomcat&quot;/&gt;</span><br><span class="line">  &lt;user username=&quot;both&quot; password=&quot;&lt;must-be-changed&gt;&quot; roles=&quot;tomcat,role1&quot;/&gt;</span><br><span class="line">  &lt;user username=&quot;role1&quot; password=&quot;&lt;must-be-changed&gt;&quot; roles=&quot;role1&quot;/&gt;</span><br><span class="line">--&gt;</span><br><span class="line">&lt;/tomcat-users&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;tomcat-users&gt;</code> 标签内有两个子标签，<code>&lt;role&gt;</code> 和 <code>&lt;user&gt;</code>，role 是用来设置 “角色”，而 user 是用来设置登陆 “用户” 的。管理页面是 webapps 下的 host-manager 与 manager 目录，分别来管理所有主机以及所有的 web项目。如果我们只将注释的部分打开，还是不能访问管理页面，因为 tomcat 设置了特定的权限名，首先是 manager：</p>
<p>manager-gui 允许访问html接口(即URL路径为&#x2F;manager&#x2F;html&#x2F;*)</p>
<p>manager-script 允许访问纯文本接口(即URL路径为&#x2F;manager&#x2F;text&#x2F;*)</p>
<p>manager-jmx 允许访问JMX代理接口(即URL路径为&#x2F;manager&#x2F;jmxproxy&#x2F;*)</p>
<p>manager-status 允许访问Tomcat只读状态页面(即URL路径为&#x2F;manager&#x2F;status&#x2F;*)</p>
<p>对于 host-manager：</p>
<p>admin-gui 允许访问html接口(即URL路径为&#x2F;host-manager&#x2F;html&#x2F;*)</p>
<p>admin-script 允许访问纯文本接口(即URL路径为&#x2F;host-manager&#x2F;text&#x2F;*)</p>
<p>admin-jmx 允许访问JMX代理接口(即URL路径为&#x2F;host-manager&#x2F;jmxproxy&#x2F;*)</p>
<p>admin-status 允许访问Tomcat只读状态页面(即URL路径为&#x2F;host-manager&#x2F;status&#x2F;*)</p>
<p>如果我们想让某个角色直接能访问这两个项目页面，可以将 roles 配置成下面的设置，然后就可以访问 manager 和 host-manager 页面了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;user username=<span class="string">&quot;tomcat&quot;</span> password=<span class="string">&quot;tomcat&quot;</span> roles=<span class="string">&quot;admin-script,admin-gui,manager-gui,manager-script&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Web-xml-不常用"><a href="#Web-xml-不常用" class="headerlink" title="Web.xml(不常用)"></a>Web.xml(不常用)</h3><p>web.xml 目前已经很少再用了，所以这部分内容简单了解下即可。web.xml 文件分为 tomcat 安装目录的 conf 下的以及各个项目的 WEB-INF 目录下的。conf 下的是全局配置，所有 web 项目都会受到影响，而 WEB-INF 下的只会作用于当前项目，但是如果与 conf 下的 web.xml 配置冲突，那么就会覆盖掉 conf的。</p>
<h4 id="ServletContext-初始化全局参数"><a href="#ServletContext-初始化全局参数" class="headerlink" title="ServletContext 初始化全局参数"></a>ServletContext 初始化全局参数</h4><p>K、V键值对。可以在应用程序中使用 javax.servlet.ServletContext.getInitParameter()方法获取参数值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt; </span><br><span class="line">　　<span class="language-xml"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span>　</span><br><span class="line">　　<span class="language-xml"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span> </span><br><span class="line">　　<span class="language-xml"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Spring Config File Location<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span> &lt;</span><br><span class="line">&lt;/context-param&gt;　　</span><br></pre></td></tr></table></figure>

<h4 id="会话设置"><a href="#会话设置" class="headerlink" title="会话设置"></a>会话设置</h4><p>用于配置Web应用会话，包括 超时时间、Cookie配置以及会话追踪模式。它将覆盖server.xml 和 context.xml 中的配置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;session-config&gt;</span><br><span class="line">　　<span class="language-xml"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span> </span><br><span class="line">　　<span class="language-xml"><span class="tag">&lt;<span class="name">cookie-config</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">　　　　<span class="tag">&lt;<span class="name">name</span>&gt;</span>JESSIONID<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">　　　　<span class="tag">&lt;<span class="name">domain</span>&gt;</span>www.itcast.cn<span class="tag">&lt;/<span class="name">domain</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">　　　　<span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">　　　　<span class="tag">&lt;<span class="name">comment</span>&gt;</span>Session Cookie<span class="tag">&lt;/<span class="name">comment</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">　　　　<span class="tag">&lt;<span class="name">http-only</span>&gt;</span>true<span class="tag">&lt;/<span class="name">http-only</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">　　　　<span class="tag">&lt;<span class="name">secure</span>&gt;</span>false<span class="tag">&lt;/<span class="name">secure</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">　　　　<span class="tag">&lt;<span class="name">max-age</span>&gt;</span>3600<span class="tag">&lt;/<span class="name">max-age</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">　　<span class="tag">&lt;/<span class="name">cookie-config</span>&gt;</span></span> </span><br><span class="line">　　<span class="language-xml"><span class="tag">&lt;<span class="name">tracking-mode</span>&gt;</span>COOKIE<span class="tag">&lt;/<span class="name">tracking-mode</span>&gt;</span></span> </span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure>

<p>1） session-timeout ： 会话超时时间，单位：分钟</p>
<p>2） cookie-config： 用于配置会话追踪Cookie</p>
<p>name：Cookie的名称</p>
<p>domain：Cookie的域名</p>
<p>path：Cookie的路径</p>
<p>comment：注释</p>
<p>http-only：cookie只能通过HTTP方式进行访问，JS无法读取或修改，此项可以增加网站访问的安全性。</p>
<p>secure：此cookie只能通过HTTPS连接传递到服务器，而HTTP 连接则不会传递该信息。注意是从浏览器传递到服务器，服务器端的Cookie对象不受此项影响。</p>
<p>max-age：以秒为单位表示cookie的生存期，默认为-1表示是会话Cookie，浏览器关闭时就会消失。</p>
<p>3） tracking-mode ：用于配置会话追踪模式，Servlet3.0版本中支持的追踪模式：COOKIE、URL、SSL</p>
<p>A. COOKIE : 通过HTTP Cookie 追踪会话是最常用的会话追踪机制， 而且Servlet规范也要求所有的Servlet规范都需要支持Cookie追踪。</p>
<p>B. URL : URL重写是最基本的会话追踪机制。当客户端不支持Cookie时，可以采用URL重写的方式。当采用URL追踪模式时，请求路径需要包含会话标识信息，Servlet容器会根据路径中的会话标识设置请求的会话信息。如： http：<a target="_blank" rel="noopener" href="http://www.myserver.com/user/index.html;jessionid=1234567890%E3%80%82">&#x2F;&#x2F;www.myserver.com/user/index.html;jessionid=1234567890。open in new window</a></p>
<p>C. SSL : 对于SSL请求， 通过SSL会话标识确定请求会话标识。</p>
<h4 id="Servlet-配置"><a href="#Servlet-配置" class="headerlink" title="Servlet 配置"></a>Servlet 配置</h4><p>Servlet 的配置主要是两部分， servlet 和 servlet-mapping ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt; </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span> </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.itcast.web.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span> </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>fileName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>init.conf<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span> </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span> </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span> </span><br><span class="line">&lt;/servlet&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/myservet/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span>        </span><br></pre></td></tr></table></figure>

<p>1）servlet-name : 指定servlet的名称， 该属性在web.xml中唯一。</p>
<p>2）servlet-class : 用于指定servlet类名</p>
<p>3）init-param： 用于指定servlet的初始化参数， 在应用中可以通过HttpServlet.getInitParameter 获取。</p>
<p>4） load-on-startup： 用于控制在Web应用启动时，Servlet的加载顺序。 值小于0，web应用启动时，不加载该servlet, 第一次访问时加载。</p>
<p>5） enabled： true ， false 。 若为false ，表示Servlet不处理任何请求。</p>
<p>6） url-pattern： 用于指定URL表达式，一个 servlet-mapping可以同时配置多个 url-pattern。</p>
<p>Servlet 中文件上传配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt; </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>uploadServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span> </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.itcast.web.UploadServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span>                     </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">multipart-config</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>C://path<span class="tag">&lt;/<span class="name">location</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">max-file-size</span>&gt;</span>10485760<span class="tag">&lt;/<span class="name">max-file-size</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">max-request-size</span>&gt;</span>10485760<span class="tag">&lt;/<span class="name">max-request-size</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">file-size-threshold</span>&gt;</span>0<span class="tag">&lt;/<span class="name">file-size-threshold</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">multipart-config</span>&gt;</span></span> </span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure>

<p>1） location：存放生成的文件地址。</p>
<p>2） max-file-size：允许上传的文件最大值。 默认值为-1， 表示没有限制。</p>
<p>3） max-request-size：针对该 multi&#x2F;form-data 请求的最大数量，默认值为-1， 表示无限制。</p>
<p>4） file-size-threshold：当数量量大于该值时， 内容会被写入文件。</p>
<h4 id="Listener-配置"><a href="#Listener-配置" class="headerlink" title="Listener 配置"></a>Listener 配置</h4><p>Listener用于监听servlet中的事件，例如context、request、session对象的创建、修改、删除，并触发响应事件。Listener是观察者模式的实现，在servlet中主要用于对context、request、session对象的生命周期进行监控。在servlet2.5规范中共定义了8中Listener。在启动时，ServletContextListener的执行顺序与web.xml 中的配置顺序一致， 停止时执行顺序相反。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt; </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">listener-</span> <span class="attr">class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span> </span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Filter-配置"><a href="#Filter-配置" class="headerlink" title="Filter 配置"></a>Filter 配置</h4><p>fifilter 用于配置web应用过滤器， 用来过滤资源请求及响应。 经常用于认证、日志、加密、数据转换等操作， 配置如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt; </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span> </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.itcast.web.MyFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span> </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span> </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>language<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>CN<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span> </span><br><span class="line">&lt;/filter&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span> </span><br></pre></td></tr></table></figure>

<p>1） filter-name： 用于指定过滤器名称，在web.xml中，过滤器名称必须唯一。</p>
<p>2） filter-class ： 过滤器的全限定类名， 该类必须实现Filter接口。</p>
<p>3） async-supported： 该过滤器是否支持异步</p>
<p>4） init-param ：用于配置Filter的初始化参数， 可以配置多个， 可以通过 FilterConfig.getInitParameter获取</p>
<p>5） url-pattern： 指定该过滤器需要拦截的URL。</p>
<h4 id="欢迎页面配置"><a href="#欢迎页面配置" class="headerlink" title="欢迎页面配置"></a>欢迎页面配置</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;welcome-file-list&gt; </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span> </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span> </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span> </span><br><span class="line">&lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure>

<p>尝试请求的顺序，从上到下。</p>
<h4 id="错误页面配置"><a href="#错误页面配置" class="headerlink" title="错误页面配置"></a>错误页面配置</h4><p>error-page 用于配置Web应用访问异常时定向到的页面，支持HTTP响应码和异常类两种形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;error-page&gt; </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span> </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span> </span><br><span class="line">&lt;/error-page&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/500.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.Exception<span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span>                 </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="安全与优化"><a href="#安全与优化" class="headerlink" title="安全与优化"></a>安全与优化</h2><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><h4 id="配置安全"><a href="#配置安全" class="headerlink" title="配置安全"></a>配置安全</h4><p>1） 删除webapps目录下的所有文件，禁用tomcat管理界面；</p>
<p>2） 注释或删除tomcat-users.xml文件内的所有用户权限；</p>
<p>3） 更改关闭tomcat指令或禁用；tomcat的server.xml中定义了可以直接关闭 Tomcat 实例的管理端口（默认8005）。可以通过 telnet连接上该端口之后，输入 SHUTDOWN （此为默认关闭指令）即可关闭 Tomcat 实例（注意，此时虽然实例关闭了，但是进程还是存在的）。由于默认关闭Tomcat 的端口和指令都很简单。默认端口为8005，指令为SHUTDOWN 。</p>
<p>方案一：更改端口号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Server</span> port=<span class="string">&quot;8456&quot;</span> shutdown=<span class="string">&quot;itcast_shut&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>方案二：禁用8005 端口，设为-1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Server</span> port=<span class="string">&quot;-1&quot;</span> shutdown=<span class="string">&quot;SHUTDOWN&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>4） 定义错误页面，如果不定义在发生异常后会显示代码类名以及位置，会泄漏目录结构。在webapps&#x2F;ROOT目录下定义错误页面 404.html，500.html；然后在tomcat&#x2F;conf&#x2F;web.xml中进行配置 ， 配置错误页面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;error-page&gt; </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span> </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span> </span><br><span class="line">&lt;/error-page&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/500.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="应用安全"><a href="#应用安全" class="headerlink" title="应用安全"></a>应用安全</h4><p>应用安全是指在某些隐私页面应该是登陆用户或者管理员用户才能访问的，而对于这些页面在权限不够时应该被拦截，可以使用拦截器或者一些安全框架，比如 SpringSecurity、Shiro 等。</p>
<h4 id="传输安全"><a href="#传输安全" class="headerlink" title="传输安全"></a>传输安全</h4><p>传统的网络应用协议 HTTP 并不安全，此时可以使用 HTTPS 来代替，它在 HTTP 的基础上加入 SSL&#x2F;TLS 来进行数据加密，保护交换数据不被泄漏、窃取。</p>
<p>HTTPS和HTTP的区别主要为以下四点：</p>
<p>1） HTTPS协议需要到证书颁发机构CA申请SSL证书, 然后与域名进行绑定，HTTP不用申请证书；</p>
<p>2） HTTP是超文本传输协议，属于应用层信息传输，HTTPS 则是具有SSL加密传安全性传输协议，对数据的传输进行加密，相当于HTTP的升级版；</p>
<p>3） HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是8080，后者是8443。</p>
<p>4） HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</p>
<p>HTTPS协议优势：</p>
<p>1） 提高网站排名，有利于SEO。谷歌已经公开声明两个网站在搜索结果方面相同，如果一个网站启用了SSL，它可能会获得略高于没有SSL网站的等级，而且百度也表明对安装了SSL的网站表示友好。因此，网站上的内容中启用SSL都有明显的SEO优势。</p>
<p>2） 隐私信息加密，防止流量劫持。特别是涉及到隐私信息的网站，互联网大型的数据泄露的事件频发发生，网站进行信息加密势在必行。北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</p>
<p>3） 浏览器受信任。 自从各大主流浏览器大力支持HTTPS协议之后，访问HTTP的网站都会提示“不安全”的警告信息。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>ApacheBench（ab）是一款ApacheServer基准的测试工具，用户测试Apache Server的服务能力（每秒处理请求数），它不仅可以用户Apache的测试，还可以用于测试Tomcat、Nginx、lighthttp、IIS等服务器。</p>
<p>安装：yum install httpd-tools</p>
<p>执行：b -n 1000 -c 100 -p data.json -T application&#x2F;json <a target="_blank" rel="noopener" href="http://localhost:9000/course/search.do?page=1&pageSize=10">http://localhost:9000/course/search.do?page=1&pageSize=10open in new window</a></p>
<p>参数说明：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041105367.png" alt="img"></p>
<p>如果此请求需要携带 Post 数据，那么需要自定义一个文件来保存这个数据，一般使用 json 格式来保存传输</p>
<p>执行结果部分：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041105702.png" alt="img"></p>
<p>参数说明：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041106869.png" alt="img"></p>
<p>重点需要关注的参数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041106517.png" alt="img"></p>
<h4 id="JVM-优化"><a href="#JVM-优化" class="headerlink" title="JVM 优化"></a>JVM 优化</h4><p>因为 Tomcat 是一台 Java 服务器，所以它的优化就可以归结到 JVM 的优化上，而 Tomcat 在JVM 上的优化可以分为垃圾回收器的选择以及一些参数配置。关于垃圾回收器和相关参数配置这里就不过多阐述了，这里只介绍下如何在 Tomcat 启动时携带我们想要的配置。</p>
<p>windows 下： 修改bin&#x2F;catalina.bat 文件，在第一行添加 ： set JAVA_OPTS&#x3D;-server -Dfile.encoding&#x3D;UTF-8 具体配置</p>
<p>linux 下：修改 bin&#x2F;catalina.sh 文件，在第一行添加： JAVA_OPTS&#x3D;” -server 具体配置”</p>
<h4 id="Tomcat-配置优化"><a href="#Tomcat-配置优化" class="headerlink" title="Tomcat 配置优化"></a>Tomcat 配置优化</h4><p>连接器的配置是决定 Tomcat 性能的关键，在一般情况下使用默认的就可以了，但是在程序比较吃力时，就需要手动配置它来提高效率，完整的配置如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Connector</span> port=<span class="string">&quot;8080&quot;</span> </span><br><span class="line">    protocol=<span class="string">&quot;HTTP/1.1&quot;</span> </span><br><span class="line">    executor=<span class="string">&quot;tomcatThreadPool&quot;</span> </span><br><span class="line">    maxThreads=<span class="string">&quot;1000&quot;</span> </span><br><span class="line">    minSpareThreads=<span class="string">&quot;100&quot;</span> </span><br><span class="line">    acceptCount=<span class="string">&quot;1000&quot;</span> </span><br><span class="line">    maxConnections=<span class="string">&quot;1000&quot;</span> </span><br><span class="line">    connectionTimeout=<span class="string">&quot;20000&quot;</span> </span><br><span class="line">    compression=<span class="string">&quot;on&quot;</span> </span><br><span class="line">    compressionMinSize=<span class="string">&quot;2048&quot;</span> </span><br><span class="line">    disableUploadTimeout=<span class="string">&quot;true&quot;</span> </span><br><span class="line">    redirectPort=<span class="string">&quot;8443&quot;</span> </span><br><span class="line">    <span class="title class_">URIEncoding</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>相关参数：</p>
<p>maxThreads：表示Tomcat可创建的最大的线程数；</p>
<p>minSpareThreads：最小空闲线程数，Tomcat初始化时创建的线程数，该值应该少于maxThreads，缺省值为4；</p>
<p>acceptCount：指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理，默认为10个；</p>
<p>maxConnections：服务器在任何给定时间接受和处理的最大连接数。</p>
<p>connectionTimeout：网络连接超时时间，单位为毫秒，如果设置为“0”则表示永不超时，不建议这样设置；</p>
<p>compression：默认为 off，开启是连接器在试图节省服务器的带宽使用 HTTP&#x2F;1.1 GZIP 压缩。关闭会自动在压缩和传输之间进行权衡。</p>
<p>compressionMinSize：在 compression 开启时，可以通过这个来配置进行压缩的最小数据量。默认为 “2048”。</p>
<p>disableUploadTimeout：上传文件时是否使用超时机制，默认开启，由 ConnectionTimeout 决定，如果为 false，那么只会在设置的 connectionUploadTimeout 设置的时间后才会断开。</p>
<p>redirectPort：如果此连接器支持非 SSL 请求，并且收到匹配需要 SSL 传输的请求，Catalina 将自动将请求重定向到此处指定的端口号。</p>
<p>如果只是想简单配置，可以只配置 maxConnections、maxThreads、acceptCount。</p>
<h2 id="Tomcat-附加功能-WebSocket"><a href="#Tomcat-附加功能-WebSocket" class="headerlink" title="Tomcat 附加功能 WebSocket"></a>Tomcat 附加功能 WebSocket</h2><p>我们在浏览网页时，一般使用的是HTTP 协议或者 HTTPS 协议，这种方式是一种 “请求—响应” 模式，也就是只支持从客户端发送请求，服务器收到后进行处理，然后返回一个响应，但是不能主动发送数据给客户端，这样某些场景下的实现就比较困难，甚至无法实现，比如聊天室实时聊天，可能有人会说直接将在 servlet 中处理向要发送消息的客户端发送不就行了，但是因为是 “请求-响应” 模式，当其他客户端与服务器一段时间没有通信，连接就会断开，服务器也就无法转发消息了。而 WebSocket 则是基于 HTTP 的一种长连接协议，并且是双向通道，可以实现服务器主动向客户端发送消息。</p>
<h3 id="WebSocket-请求过程"><a href="#WebSocket-请求过程" class="headerlink" title="WebSocket 请求过程"></a>WebSocket 请求过程</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041106746.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041106123.png" alt="img"></p>
<p>WebSocket 请求和普通的HTTP请求有几点不同：</p>
<p>\1. GET请求的地址不是类似 http:&#x2F;&#x2F;，而是以 ws:&#x2F;&#x2F; 开头的地址；</p>
<p>\2. 请求头 Connection: Upgrade 和 请求头 Upgrade: websocket 表示这个连接将要被转换为WebSocket 连接；</p>
<p>\3. Sec-WebSocket-Key 是用于标识这个连接， 是一个BASE64编码的密文, 要求服务端响应一个对应加密的Sec-WebSocket-Accept头信息作为应答；</p>
<p>\4. Sec-WebSocket-Version 指定了WebSocket的协议版本;</p>
<p>\5. HTTP101 状态码表明服务端已经识别并切换为WebSocket协议 , Sec-WebSocket-Accept是服务端与客户端一致的秘钥计算出来的信息。</p>
<p>Tomcat的7.0.5 版本开始支持WebSocket,并且实现了Java WebSocket规范(JSR356), 而在7.0.5版本之前(7.0.2之后)则采用自定义API, 即WebSocketServlet实现。Java WebSocket应用由一系列的WebSocketEndpoint组成。Endpoint 是一个java对象，代表WebSocket链接的一端，对于服务端，我们可以视为处理具体WebSocket消息的接口， 就像Servlet之与http请求一样。我们可以通过两种方式定义Endpoint:</p>
<p>1). 第一种是编程式， 即继承类 javax.websocket.Endpoint并实现其方法。</p>
<p>2). 第二种是注解式, 即定义一个POJO, 并添加 @ServerEndpoint相关注解。Endpoint实例在WebSocket握手时创建，并在客户端与服务端链接过程中有效，最后在链接关闭时结束。在Endpoint接口中明确定义了与其生命周期相关的方法， 规范实现者确保生命周期的各个阶段调用实例的相关方法。生命周期方法如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202305041106264.png" alt="img"></p>
<p>通过为Session添加MessageHandler消息处理器来接收消息，当采用注解方式定义Endpoint时，我们还可以通过 @OnMessage 注解指定接收消息的方法。发送消息则由RemoteEndpoint 完成， 其实例由Session维护， 根据使用情况， 我们可以通过Session.getBasicRemote获取同步消息发送的实例 ， 然后调用其sendXxx()方法就可以发送消息， 可以通过Session.getAsyncRemote 获取异步消息发送实例。</p>
<h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><h2 id="Spring的优点"><a href="#Spring的优点" class="headerlink" title="Spring的优点"></a>Spring的优点</h2><ul>
<li>通过控制反转和依赖注入实现<strong>松耦合</strong>。</li>
<li>支持<strong>面向切面</strong>的编程，并且把应用业务逻辑和系统服务分开。</li>
<li>通过切面和模板减少样板式代码。</li>
<li>声明式事务的支持。可以从单调繁冗的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。</li>
<li>方便集成各种优秀框架。内部提供了对各种优秀框架的直接支持（如：Hessian、Quartz、MyBatis等）。</li>
<li>方便程序的测试。Spring支持Junit4，添加注解便可以测试Spring程序。</li>
</ul>
<h2 id="Spring-用到了哪些设计模式？"><a href="#Spring-用到了哪些设计模式？" class="headerlink" title="Spring 用到了哪些设计模式？"></a>Spring 用到了哪些设计模式？</h2><p>1、<strong>简单工厂模式</strong>：<code>BeanFactory</code>就是简单工厂模式的体现，根据传入一个唯一标识来获得 Bean 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    assertBeanFactoryActive();</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<strong>工厂方法模式</strong>：<code>FactoryBean</code>就是典型的工厂方法模式。spring在使用<code>getBean()</code>调用获得该bean时，会自动调用该bean的<code>getObject()</code>方法。每个 Bean 都会对应一个 <code>FactoryBean</code>，如 <code>SqlSessionFactory</code> 对应 <code>SqlSessionFactoryBean</code>。</p>
<p>3、<strong>单例模式</strong>：一个类仅有一个实例，提供一个访问它的全局访问点。Spring 创建 Bean 实例默认是单例的。</p>
<p>4、<strong>适配器模式</strong>：SpringMVC中的适配器<code>HandlerAdatper</code>。由于应用会有多个Controller实现，如果需要直接调用Controller方法，那么需要先判断是由哪一个Controller处理请求，然后调用相应的方法。当增加新的 Controller，需要修改原来的逻辑，违反了开闭原则（对修改关闭，对扩展开放）。</p>
<p>为此，Spring提供了一个适配器接口，每一种 Controller 对应一种 <code>HandlerAdapter</code> 实现类，当请求过来，SpringMVC会调用<code>getHandler()</code>获取相应的Controller，然后获取该Controller对应的 <code>HandlerAdapter</code>，最后调用<code>HandlerAdapter</code>的<code>handle()</code>方法处理请求，实际上调用的是Controller的<code>handleRequest()</code>。每次添加新的 Controller 时，只需要增加一个适配器类就可以，无需修改原有的逻辑。</p>
<p>常用的处理器适配器：<code>SimpleControllerHandlerAdapter</code>，<code>HttpRequestHandlerAdapter</code>，<code>AnnotationMethodHandlerAdapter</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine handler for the current request.</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"></span><br><span class="line"><span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpRequestHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;<span class="comment">//handler是被适配的对象，这里使用的是对象的适配器模式</span></span><br><span class="line">        <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpRequestHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        ((HttpRequestHandler) handler).handleRequest(request, response);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、<strong>代理模式</strong>：spring 的 aop 使用了动态代理，有两种方式<code>JdkDynamicAopProxy</code>和<code>Cglib2AopProxy</code>。</p>
<p>6、<strong>观察者模式</strong>：spring 中 observer 模式常用的地方是 listener 的实现，如<code>ApplicationListener</code>。</p>
<p>7、<strong>模板模式</strong>： Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等，就使用到了模板模式。</p>
<h2 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h2><p><strong>面向切面</strong>编程，作为面向对象的一种补充，将公共逻辑（事务管理、日志、缓存等）封装成切面，跟业务代码进行分离，可以减少系统的重复代码和降低模块之间的耦合度。切面就是那些与业务无关，但所有业务模块都会调用的公共逻辑。</p>
<h2 id="AOP有哪些实现方式？"><a href="#AOP有哪些实现方式？" class="headerlink" title="AOP有哪些实现方式？"></a>AOP有哪些实现方式？</h2><p>AOP有两种实现方式：静态代理和动态代理。</p>
<p><strong>静态代理</strong></p>
<p>静态代理：代理类在编译阶段生成，在编译阶段将通知织入Java字节码中，也称编译时增强。AspectJ使用的是静态代理。</p>
<p>缺点：代理对象需要与目标对象实现一样的接口，并且实现接口的方法，会有冗余代码。同时，一旦接口增加方法，目标对象与代理对象都要维护。</p>
<p><strong>动态代理</strong></p>
<p>动态代理：代理类在程序运行时创建，AOP框架不会去修改字节码，而是在内存中临时生成一个代理对象，在运行期间对业务方法进行增强，不会生成新类。</p>
<h2 id="Spring-AOP的实现原理"><a href="#Spring-AOP的实现原理" class="headerlink" title="Spring AOP的实现原理"></a>Spring AOP的实现原理</h2><p><code>Spring</code>的<code>AOP</code>实现原理其实很简单，就是通过<strong>动态代理</strong>实现的。如果我们为<code>Spring</code>的某个<code>bean</code>配置了切面，那么<code>Spring</code>在创建这个<code>bean</code>的时候，实际上创建的是这个<code>bean</code>的一个代理对象，我们后续对<code>bean</code>中方法的调用，实际上调用的是代理类重写的代理方法。而<code>Spring</code>的<code>AOP</code>使用了两种动态代理，分别是<strong>JDK的动态代理</strong>，以及<strong>CGLib的动态代理</strong>。</p>
<h2 id="JDK动态代理和CGLIB动态代理的区别？"><a href="#JDK动态代理和CGLIB动态代理的区别？" class="headerlink" title="JDK动态代理和CGLIB动态代理的区别？"></a>JDK动态代理和CGLIB动态代理的区别？</h2><p>Spring AOP中的动态代理主要有两种方式：JDK动态代理和CGLIB动态代理。</p>
<p><strong>JDK动态代理</strong></p>
<p>如果目标类实现了接口，Spring AOP会选择使用JDK动态代理目标类。代理类根据目标类实现的接口动态生成，不需要自己编写，生成的动态代理类和目标类都实现相同的接口。JDK动态代理的核心是<code>InvocationHandler</code>接口和<code>Proxy</code>类。</p>
<p>缺点：<strong>目标类必须有实现的接口</strong>。如果某个类没有实现接口，那么这个类就不能用JDK动态代理。</p>
<p><strong>CGLIB动态代理</strong></p>
<p><strong>通过继承实现</strong>。如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library）可以在运行时动态生成类的字节码，动态创建目标类的子类对象，在子类对象中增强目标类。</p>
<p>CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为<code>final</code>，那么它是无法使用CGLIB做动态代理的。</p>
<p>优点：目标类不需要实现特定的接口，更加灵活。</p>
<p>什么时候采用哪种动态代理？</p>
<ol>
<li>如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP</li>
<li>如果目标对象实现了接口，可以强制使用CGLIB实现AOP</li>
<li>如果目标对象没有实现了接口，必须采用CGLIB库</li>
</ol>
<p><strong>两者的区别</strong>：</p>
<ol>
<li>jdk动态代理使用jdk中的类Proxy来创建代理对象，它使用反射技术来实现，不需要导入其他依赖。cglib需要引入相关依赖：<code>asm.jar</code>，它使用字节码增强技术来实现。</li>
<li>当目标类实现了接口的时候Spring Aop默认使用jdk动态代理方式来增强方法，没有实现接口的时候使用cglib动态代理方式增强方法。</li>
</ol>
<h2 id="Spring-AOP相关术语"><a href="#Spring-AOP相关术语" class="headerlink" title="Spring AOP相关术语"></a>Spring AOP相关术语</h2><p>（1）<strong>切面</strong>（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。</p>
<p>（2）<strong>连接点</strong>（Join point）：指方法，在Spring AOP中，一个连接点总是代表一个方法的执行。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p>
<p>（3）<strong>通知</strong>（Advice）：在AOP术语中，切面的工作被称为通知。</p>
<p>（4）<strong>切入点</strong>（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p>
<p>（5）<strong>引入</strong>（Introduction）：引入允许我们向现有类添加新方法或属性。</p>
<p>（6）<strong>目标对象</strong>（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。</p>
<p>（7）<strong>织入</strong>（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有以下时间点可以进行织入：</p>
<ul>
<li>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</li>
<li>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</li>
<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</li>
</ul>
<h2 id="Spring通知有哪些类型？"><a href="#Spring通知有哪些类型？" class="headerlink" title="Spring通知有哪些类型？"></a>Spring通知有哪些类型？</h2><p>在AOP术语中，切面的工作被称为通知。通知实际上是程序运行时要通过Spring AOP框架来触发的代码段。</p>
<p>Spring切面可以应用5种类型的通知：</p>
<ol>
<li><strong>前置通知</strong>（Before）：在目标方法被调用之前调用通知功能；</li>
<li><strong>后置通知</strong>（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>
<li><strong>返回通知</strong>（After-returning ）：在目标方法成功执行之后调用通知；</li>
<li><strong>异常通知</strong>（After-throwing）：在目标方法抛出异常后调用通知；</li>
<li><strong>环绕通知</strong>（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的逻辑。</li>
</ol>
<h2 id="什么是IOC？"><a href="#什么是IOC？" class="headerlink" title="什么是IOC？"></a>什么是IOC？</h2><p>IOC：<strong>控制反转</strong>，由Spring容器管理bean的整个生命周期。通过反射实现对其他对象的控制，包括初始化、创建、销毁等，解放手动创建对象的过程，同时降低类之间的耦合度。</p>
<h2 id="IOC的好处？"><a href="#IOC的好处？" class="headerlink" title="IOC的好处？"></a>IOC的好处？</h2><p>ioc的思想最核心的地方在于，资源不由使用资源者管理，而由不使用资源的第三方管理，这可以带来很多好处。第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。</p>
<p>也就是说，甲方要达成某种目的不需要直接依赖乙方，它只需要达到的目的告诉第三方机构就可以了，比如甲方需要一双袜子，而乙方它卖一双袜子，它要把袜子卖出去，并不需要自己去直接找到一个卖家来完成袜子的卖出。它也只需要找第三方，告诉别人我要卖一双袜子。这下好了，甲乙双方进行交易活动，都不需要自己直接去找卖家，相当于程序内部开放接口，卖家由第三方作为参数传入。甲乙互相不依赖，而且只有在进行交易活动的时候，甲才和乙产生联系。反之亦然。这样做什么好处么呢，甲乙可以在对方不真实存在的情况下独立存在，而且保证不交易时候无联系，想交易的时候可以很容易的产生联系。甲乙交易活动不需要双方见面，避免了双方的互不信任造成交易失败的问题。因为交易由第三方来负责联系，而且甲乙都认为第三方可靠。那么交易就能很可靠很灵活的产生和进行了。</p>
<p>这就是ioc的核心思想。生活中这种例子比比皆是，支付宝在整个淘宝体系里就是庞大的ioc容器，交易双方之外的第三方，提供可靠性可依赖可灵活变更交易方的资源管理中心。另外人事代理也是，雇佣机构和个人之外的第三方。</p>
<h2 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h2><p>在Spring创建对象的过程中，把对象依赖的属性注入到对象中。依赖注入主要有两种方式：构造器注入和属性注入。</p>
<h2 id="IOC容器初始化过程？"><a href="#IOC容器初始化过程？" class="headerlink" title="IOC容器初始化过程？"></a>IOC容器初始化过程？</h2><ol>
<li>从XML中读取配置文件。</li>
<li>将bean标签解析成 BeanDefinition，如解析 property 元素， 并注入到 BeanDefinition 实例中。</li>
<li>将 BeanDefinition 注册到容器 BeanDefinitionMap 中。</li>
<li>BeanFactory 根据 BeanDefinition 的定义信息创建实例化和初始化 bean。</li>
</ol>
<p>单例bean的初始化以及依赖注入一般都在容器初始化阶段进行，只有懒加载（lazy-init为true）的单例bean是在应用第一次调用getBean()时进行初始化和依赖注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext</span></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br></pre></td></tr></table></figure>

<p>多例bean 在容器启动时不实例化，即使设置 lazy-init 为 false 也没用，只有调用了getBean()才进行实例化。</p>
<p><code>loadBeanDefinitions</code>采用了模板模式，具体加载 <code>BeanDefinition</code> 的逻辑由各个子类完成。</p>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/20220709213529.png" alt="img"></p>
<p>1.调用bean的构造方法创建Bean</p>
<p>2.通过反射调用setter方法进行属性的依赖注入</p>
<p>3.如果Bean实现了<code>BeanNameAware</code>接口，Spring将调用<code>setBeanName</code>()，设置 <code>Bean</code>的name（xml文件中bean标签的id）</p>
<p>4.如果Bean实现了<code>BeanFactoryAware</code>接口，Spring将调用<code>setBeanFactory()</code>把bean factory设置给Bean</p>
<p>5.如果存在<code>BeanPostProcessor</code>，Spring将调用它们的<code>postProcessBeforeInitialization</code>（预初始化）方法，在Bean初始化前对其进行处理</p>
<p>6.如果Bean实现了<code>InitializingBean</code>接口，Spring将调用它的<code>afterPropertiesSet</code>方法，然后调用xml定义的 init-method 方法，两个方法作用类似，都是在初始化 bean 的时候执行</p>
<p>7.如果存在<code>BeanPostProcessor</code>，Spring将调用它们的<code>postProcessAfterInitialization</code>（后初始化）方法，在Bean初始化后对其进行处理</p>
<p>8.Bean初始化完成，供应用使用，这里分两种情况：</p>
<p>8.1 如果Bean为单例的话，那么容器会返回Bean给用户，并存入缓存池。如果Bean实现了<code>DisposableBean</code>接口，Spring将调用它的<code>destory</code>方法，然后调用在xml中定义的 <code>destory-method</code>方法，这两个方法作用类似，都是在Bean实例销毁前执行。</p>
<p>8.2 如果Bean是多例的话，容器将Bean返回给用户，剩下的生命周期由用户控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BeanFactory和FactoryBean的区别？"><a href="#BeanFactory和FactoryBean的区别？" class="headerlink" title="BeanFactory和FactoryBean的区别？"></a>BeanFactory和FactoryBean的区别？</h2><p><strong>BeanFactory</strong>：管理Bean的容器，Spring中生成的Bean都是由这个接口的实现来管理的。</p>
<p><strong>FactoryBean</strong>：通常是用来创建比较复杂的bean，一般的bean 直接用xml配置即可，但如果一个bean的创建过程中涉及到很多其他的bean 和复杂的逻辑，直接用xml配置比较麻烦，这时可以考虑用FactoryBean，可以隐藏实例化复杂Bean的细节。</p>
<p>当配置文件中bean标签的class属性配置的实现类是FactoryBean时，通过 getBean()方法返回的不是FactoryBean本身，而是调用FactoryBean#getObject()方法所返回的对象，相当于FactoryBean#getObject()代理了getBean()方法。如果想得到FactoryBean必须使用 ‘&amp;’ + beanName 的方式获取。</p>
<p>Mybatis 提供了 <code>SqlSessionFactoryBean</code>，可以简化 <code>SqlSessionFactory</code>的配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ApplicationEvent&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    notNull(dataSource, <span class="string">&quot;Property &#x27;dataSource&#x27; is required&quot;</span>);</span><br><span class="line">    notNull(sqlSessionFactoryBuilder, <span class="string">&quot;Property &#x27;sqlSessionFactoryBuilder&#x27; is required&quot;</span>);</span><br><span class="line">    state((configuration == <span class="literal">null</span> &amp;&amp; configLocation == <span class="literal">null</span>) || !(configuration != <span class="literal">null</span> &amp;&amp; configLocation != <span class="literal">null</span>),</span><br><span class="line">              <span class="string">&quot;Property &#x27;configuration&#x27; and &#x27;configLocation&#x27; can not specified with together&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sqlSessionFactory = buildSqlSessionFactory();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> SqlSessionFactory <span class="title function_">buildSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="comment">//复杂逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> SqlSessionFactory <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">      afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionFactory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 xml 配置 SqlSessionFactoryBean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;tradeSqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;trade&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath*:mapper/trade/*Mapper.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.bytebeats.mybatis3.domain.trade&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring 将会在应用启动时创建 <code>SqlSessionFactory</code>，并使用 <code>sqlSessionFactory</code> 这个名字存储起来。</p>
<h2 id="BeanFactory和ApplicationContext有什么区别？"><a href="#BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="BeanFactory和ApplicationContext有什么区别？"></a>BeanFactory和ApplicationContext有什么区别？</h2><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p>
<p>两者区别如下：</p>
<p>1、功能上的区别。BeanFactory是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>
<p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能，如继承MessageSource、支持国际化、统一的资源文件访问方式、同时加载多个配置文件等功能。</p>
<p>2、加载方式的区别。BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>
<p>而ApplicationContext是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单例Bean，那么在需要的时候，不需要等待创建bean，因为它们已经创建好了。</p>
<p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p>3、创建方式的区别。BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p>
<p>4、注册方式的区别。BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>
<h2 id="Bean注入容器有哪些方式？"><a href="#Bean注入容器有哪些方式？" class="headerlink" title="Bean注入容器有哪些方式？"></a>Bean注入容器有哪些方式？</h2><p>1、**@Configuration + @Bean**</p>
<p>@Configuration用来声明一个配置类，然后使用 @Bean 注解，用于声明一个bean，将其加入到Spring容器中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setName(<span class="string">&quot;茶白&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<strong>通过包扫描特定注解的方式</strong></p>
<p>@ComponentScan放置在我们的配置类上，然后可以指定一个路径，进行扫描带有特定注解的bean，然后加至容器中。</p>
<p>特定注解包括@Controller、@Service、@Repository、@Component</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.dabin.test.*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Demo1.class);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、**@Import注解导入**</p>
<p>@Import注解平时开发用的不多，但是也是非常重要的，在进行Spring扩展时经常会用到，它经常搭配自定义注解进行使用，然后往容器中导入一个配置文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="comment">/*把用到的资源导入到当前容器中*/</span></span><br><span class="line"><span class="meta">@Import(&#123;Person.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(App.class, args);</span><br><span class="line">        System.out.println(context.getBean(Person.class));</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、<strong>实现BeanDefinitionRegistryPostProcessor进行后置处理。</strong></p>
<p>在Spring容器启动的时候会执行 BeanDefinitionRegistryPostProcessor 的 postProcessBeanDefinitionRegistry 方法，就是等beanDefinition加载完毕之后，对beanDefinition进行后置处理，可以在此进行调整IOC容器中的beanDefinition，从而干扰到后面进行初始化bean。</p>
<p>在下面的代码中，我们手动向beanDefinitionRegistry中注册了person的BeanDefinition。最终成功将person加入到applicationContext中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">        <span class="type">MyBeanDefinitionRegistryPostProcessor</span> <span class="variable">beanDefinitionRegistryPostProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBeanDefinitionRegistryPostProcessor</span>();</span><br><span class="line">        applicationContext.addBeanFactoryPostProcessor(beanDefinitionRegistryPostProcessor);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.rootBeanDefinition(Person.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;person&quot;</span>, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、<strong>使用FactoryBean接口</strong></p>
<p>如下图代码，使用@Configuration + @Bean的方式将 PersonFactoryBean 加入到容器中，这里没有向容器中直接注入 Person，而是注入 PersonFactoryBean，然后从容器中拿Person这个类型的bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PersonFactoryBean <span class="title function_">personFactoryBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PersonFactoryBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Demo1.class);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Person.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>1、<strong>singleton</strong>：单例，Spring中的bean默认都是单例的。</p>
<p>2、<strong>prototype</strong>：每次请求都会创建一个新的bean实例。</p>
<p>3、<strong>request</strong>：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</p>
<p>4、<strong>session</strong>：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP session内有效。</p>
<p>5、<strong>global-session</strong>：全局session作用域。</p>
<h2 id="Spring自动装配的方式有哪些？"><a href="#Spring自动装配的方式有哪些？" class="headerlink" title="Spring自动装配的方式有哪些？"></a>Spring自动装配的方式有哪些？</h2><p>Spring的自动装配有三种模式：<strong>byType</strong>(根据类型)，<strong>byName</strong>(根据名称)、<strong>constructor</strong>(根据构造函数)。</p>
<p><strong>byType</strong></p>
<p>找到与依赖类型相同的bean注入到另外的bean中，这个过程需要借助setter注入来完成，因此必须存在set方法，否则注入失败。</p>
<p>当xml文件中存在多个相同类型名称不同的实例Bean时，Spring容器依赖注入仍然会失败，因为存在多种适合的选项，Spring容器无法知道该注入那种，此时我们需要为Spring容器提供帮助，指定注入那个Bean实例。可以通过<code>＜bean＞</code>标签的autowire-candidate设置为false来过滤那些不需要注入的实例Bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;com.zejian.spring.springIoc.dao.impl.UserDaoImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- autowire-candidate=&quot;false&quot; 过滤该类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao2&quot;</span> <span class="attr">autowire-candidate</span>=<span class="string">&quot;false&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zejian.spring.springIoc.dao.impl.UserDaoImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- byType 根据类型自动装配userDao--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zejian.spring.springIoc.service.impl.UserServiceImpl&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>byName</strong></p>
<p>将属性名与bean名称进行匹配，如果找到则注入依赖bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;com.zejian.spring.springIoc.dao.impl.UserDaoImpl&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zejian.spring.springIoc.dao.impl.UserDaoImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- byName 根据名称自动装配，找到UserServiceImpl名为 userDao属性并注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zejian.spring.springIoc.service.impl.UserServiceImpl&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>constructor</strong></p>
<p>存在单个实例则优先按类型进行参数匹配（无论名称是否匹配），当存在多个类型相同实例时，按名称优先匹配，如果没有找到对应名称，则注入失败。</p>
<h2 id="Autowired和-Resource的区别？"><a href="#Autowired和-Resource的区别？" class="headerlink" title="@Autowired和@Resource的区别？"></a>@Autowired和@Resource的区别？</h2><p>Autowire是spring的注解。默认情况下@Autowired是按类型匹配的(byType)。如果需要按名称(byName)匹配的话，可以使用@Qualifier注解与@Autowired结合。@Autowired 可以传递一个<code>required=false</code>的属性，false指明当userDao实例存在就注入不存就忽略，如果为true，就必须注入，若userDao实例不存在，就抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//标注成员变量</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userDao1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>Resource是j2ee的注解，默认按 byName模式自动注入。@Resource有两个中重要的属性：name和type。name属性指定bean的名字，type属性则指定bean的类型。因此使用name属性，则按byName模式的自动注入策略，如果使用type属性，则按 byType模式自动注入策略。倘若既不指定name也不指定type属性，Spring容器将通过反射技术默认按byName模式注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao  userDao;<span class="comment">//用于成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以用于set方法标注</span></span><br><span class="line"><span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.userDao= userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两种自动装配的依赖注入并不适合简单值类型，如int、boolean、long、String以及Enum等，对于这些类型，Spring容器也提供了@Value注入的方式。</p>
<p>@Value和@Autowired、@Resource类似，也是用来对属性进行注入的，只不过@Value是用来从Properties文件中来获取值的，并且@Value可以解析SpEL(Spring表达式)。</p>
<p>比如，jdbc.properties文件如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/test?characterEncoding=UTF-8&amp;allowMultiQueries=true</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>利用注解@Value获取jdbc.url和jdbc.username的值，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//占位符方式</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="comment">//SpEL表达方式，其中代表xml配置文件中的id值configProperties</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;configProperties[&#x27;jdbc.username&#x27;]&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Qualifier-注解有什么作用"><a href="#Qualifier-注解有什么作用" class="headerlink" title="@Qualifier 注解有什么作用"></a>@Qualifier 注解有什么作用</h2><p>当需要创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，可以使用<code>@Qualifier</code> 注解和 <code>@Autowired</code> 通过指定应该装配哪个 bean 来消除歧义。</p>
<h2 id="Bean和-Component有什么区别？"><a href="#Bean和-Component有什么区别？" class="headerlink" title="@Bean和@Component有什么区别？"></a>@Bean和@Component有什么区别？</h2><p>都是使用注解定义 Bean。@Bean 是使用 Java 代码装配 Bean，@Component 是自动装配 Bean。</p>
<p>@Component 注解用在类上，表明一个类会作为组件类，并告知Spring要为这个类创建bean，每个类对应一个 Bean。</p>
<p>@Bean 注解用在方法上，表示这个方法会返回一个 Bean。@Bean 需要在配置类中使用，即类上需要加上@Configuration注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;lkm&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">student</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Bean 注解更加灵活。当需要将第三方类装配到 Spring 容器中，因为没办法源代码上添加@Component注解，只能使用@Bean 注解的方式，当然也可以使用 xml 的方式。</p>
<h2 id="Component、-Controller、-Repositor和-Service-的区别？"><a href="#Component、-Controller、-Repositor和-Service-的区别？" class="headerlink" title="@Component、@Controller、@Repositor和@Service 的区别？"></a>@Component、@Controller、@Repositor和@Service 的区别？</h2><p>@Component：最普通的组件，可以被注入到spring容器进行管理。</p>
<p>@Controller：将类标记为 Spring Web MVC 控制器。</p>
<p>@Service：将类标记为业务层组件。</p>
<p>@Repository：将类标记为数据访问组件，即DAO组件。</p>
<h2 id="Spring-事务实现方式有哪些？"><a href="#Spring-事务实现方式有哪些？" class="headerlink" title="Spring 事务实现方式有哪些？"></a>Spring 事务实现方式有哪些？</h2><p>事务就是一系列的操作原子执行。Spring事务机制主要包括声明式事务和编程式事务。</p>
<ul>
<li><strong>编程式事务</strong>：通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</li>
<li><strong>声明式事务</strong>：将事务管理代码从业务方法中分离出来，通过aop进行封装。Spring声明式事务使得我们无需要去处理获得连接、关闭连接、事务提交和回滚等这些操作。使用 <code>@Transactional</code> 注解开启声明式事务。</li>
</ul>
<p><code>@Transactional</code>相关属性如下：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">value</td>
<td>String</td>
<td>可选的限定描述符，指定使用的事务管理器</td>
</tr>
<tr>
<td align="left">propagation</td>
<td>enum: Propagation</td>
<td>可选的事务传播行为设置</td>
</tr>
<tr>
<td align="left">isolation</td>
<td>enum: Isolation</td>
<td>可选的事务隔离级别设置</td>
</tr>
<tr>
<td align="left">readOnly</td>
<td>boolean</td>
<td>读写或只读事务，默认读写</td>
</tr>
<tr>
<td align="left">timeout</td>
<td>int (in seconds granularity)</td>
<td>事务超时时间设置</td>
</tr>
<tr>
<td align="left">rollbackFor</td>
<td>Class对象数组，必须继承自Throwable</td>
<td>导致事务回滚的异常类数组</td>
</tr>
<tr>
<td align="left">rollbackForClassName</td>
<td>类名数组，必须继承自Throwable</td>
<td>导致事务回滚的异常类名字数组</td>
</tr>
<tr>
<td align="left">noRollbackFor</td>
<td>Class对象数组，必须继承自Throwable</td>
<td>不会导致事务回滚的异常类数组</td>
</tr>
<tr>
<td align="left">noRollbackForClassName</td>
<td>类名数组，必须继承自Throwable</td>
<td>不会导致事务回滚的异常类名字数组</td>
</tr>
</tbody></table>
<h2 id="有哪些事务传播行为？"><a href="#有哪些事务传播行为？" class="headerlink" title="有哪些事务传播行为？"></a>有哪些事务传播行为？</h2><p>在TransactionDefinition接口中定义了七个事务传播行为：</p>
<ol>
<li><code>PROPAGATION_REQUIRED</code>如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。如果嵌套调用的两个方法都加了事务注解，并且运行在相同线程中，则这两个方法使用相同的事务中。如果运行在不同线程中，则会开启新的事务。</li>
<li><code>PROPAGATION_SUPPORTS</code> 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。</li>
<li><code>PROPAGATION_MANDATORY</code> 如果已经存在一个事务，支持当前事务。如果不存在事务，则抛出异常<code>IllegalTransactionStateException</code>。</li>
<li><code>PROPAGATION_REQUIRES_NEW</code> 总是开启一个新的事务。需要使用JtaTransactionManager作为事务管理器。</li>
<li><code>PROPAGATION_NOT_SUPPORTED</code> 总是非事务地执行，并挂起任何存在的事务。需要使用JtaTransactionManager作为事务管理器。</li>
<li><code>PROPAGATION_NEVER</code> 总是非事务地执行，如果存在一个活动事务，则抛出异常。</li>
<li><code>PROPAGATION_NESTED</code> 如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务, 则按PROPAGATION_REQUIRED 属性执行。</li>
</ol>
<p><strong>PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别:</strong></p>
<p>使用<code>PROPAGATION_REQUIRES_NEW</code>时，内层事务与外层事务是两个独立的事务。一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。</p>
<p>使用<code>PROPAGATION_NESTED</code>时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。</p>
<h2 id="Spring事务在什么情况下会失效？"><a href="#Spring事务在什么情况下会失效？" class="headerlink" title="Spring事务在什么情况下会失效？"></a>Spring事务在什么情况下会失效？</h2><p><strong>1.访问权限问题</strong></p>
<p>java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。</p>
<p>如果事务方法的访问权限不是定义成public，这样会导致事务失效，因为spring要求被代理方法必须是<code>public</code>的。</p>
<p>翻开源码，可以看到，在<code>AbstractFallbackTransactionAttributeSource</code>类的<code>computeTransactionAttribute</code>方法中有个判断，如果目标方法不是public，则返回null，即不支持事务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">computeTransactionAttribute</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">    <span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">    <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 方法用final修饰</strong></p>
<p>如果事务方法用final修饰，将会导致事务失效。因为spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。</p>
<p>但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。</p>
<blockquote>
<p>同理，如果某个方法是static的，同样无法通过动态代理，变成事务方法。</p>
</blockquote>
<p><strong>3.对象没有被spring管理</strong></p>
<p>使用spring事务的前提是：对象要被spring管理，需要创建bean实例。如果类没有加@Controller、@Service、@Component、@Repository等注解，即该类没有交给spring去管理，那么它的方法也不会生成事务。</p>
<p><strong>4.表不支持事务</strong></p>
<p>如果MySQL使用的存储引擎是myisam，这样的话是不支持事务的。因为myisam存储引擎不支持事务。</p>
<p><strong>5.方法内部调用</strong></p>
<p>如下代码所示，update方法上面没有加 <code>@Transactional</code> 注解，调用有 <code>@Transactional</code> 注解的 updateOrder 方法，updateOrder 方法上的事务会失效。</p>
<p>因为发生了自身调用，调用该类自己的方法，而没有经过 Spring 的代理类，只有在外部调用事务才会生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.updateOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// update order</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<p>1、再声明一个service，将内部调用改为外部调用</p>
<p>2、使用编程式事务</p>
<p>3、使用AopContext.currentProxy()获取代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        ((OrderService)AopContext.currentProxy()).updateOrder(order);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// update order</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.未开启事务</strong></p>
<p>如果是spring项目，则需要在配置文件中手动配置事务相关参数。如果忘了配置，事务肯定是不会生效的。</p>
<p>如果是springboot项目，那么不需要手动配置。因为springboot已经在<code>DataSourceTransactionManagerAutoConfiguration</code>类中帮我们开启了事务。</p>
<p><strong>7.吞了异常</strong></p>
<p>有时候事务不会回滚，有可能是在代码中手动catch了异常。因为开发者自己捕获了异常，又没有手动抛出，把异常吞掉了，这种情况下spring事务不会回滚。</p>
<p>如果想要spring事务能够正常回滚，必须抛出它能够处理的异常。如果没有抛异常，则spring认为程序是正常的。</p>
<h2 id="Spring怎么解决循环依赖的问题？"><a href="#Spring怎么解决循环依赖的问题？" class="headerlink" title="Spring怎么解决循环依赖的问题？"></a>Spring怎么解决循环依赖的问题？</h2><p>首先，有两种Bean注入的方式。</p>
<p>构造器注入和属性注入。</p>
<p>对于构造器注入的循环依赖，Spring处理不了，会直接抛出<code>BeanCurrentlylnCreationException</code>异常。</p>
<p>对于属性注入的循环依赖（单例模式下），是通过三级缓存处理来循环依赖的。</p>
<p>而非单例对象的循环依赖，则无法处理。</p>
<p>下面分析单例模式下属性注入的循环依赖是怎么处理的：</p>
<p>首先，Spring单例对象的初始化大略分为三步：</p>
<ol>
<li><code>createBeanInstance</code>：实例化bean，使用构造方法创建对象，为对象分配内存。</li>
<li><code>populateBean</code>：进行依赖注入。</li>
<li><code>initializeBean</code>：初始化bean。</li>
</ol>
<p>Spring为了解决单例的循环依赖问题，使用了三级缓存：</p>
<p><code>singletonObjects</code>：完成了初始化的单例对象map，bean name –&gt; bean instance</p>
<p><code>earlySingletonObjects </code>：完成实例化未初始化的单例对象map，bean name –&gt; bean instance</p>
<p><code>singletonFactories </code>： 单例对象工厂map，bean name –&gt; ObjectFactory，单例对象实例化完成之后会加入singletonFactories。</p>
<p>在调用createBeanInstance进行实例化之后，会调用addSingletonFactory，将单例对象放到singletonFactories中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">            <span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="built_in">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如A依赖了B的实例对象，同时B也依赖A的实例对象。</p>
<ol>
<li>A首先完成了实例化，并且将自己添加到singletonFactories中</li>
<li>接着进行依赖注入，发现自己依赖对象B，此时就尝试去get(B)</li>
<li>发现B还没有被实例化，对B进行实例化</li>
<li>然后B在初始化的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects和二级缓存earlySingletonObjects没找到，尝试三级缓存singletonFactories，由于A初始化时将自己添加到了singletonFactories，所以B可以拿到A对象，然后将A从三级缓存中移到二级缓存中</li>
<li>B拿到A对象后顺利完成了初始化，然后将自己放入到一级缓存singletonObjects中</li>
<li>此时返回A中，A此时能拿到B的对象顺利完成自己的初始化</li>
</ol>
<p>由此看出，属性注入的循环依赖主要是通过将实例化完成的bean添加到singletonFactories来实现的。而使用构造器依赖注入的bean在实例化的时候会进行依赖注入，不会被添加到singletonFactories中。比如A和B都是通过构造器依赖注入，A在调用构造器进行实例化的时候，发现自己依赖B，B没有被实例化，就会对B进行实例化，此时A未实例化完成，不会被添加到singtonFactories。而B依赖于A，B会去三级缓存寻找A对象，发现不存在，于是又会实例化A，A实例化了两次，从而导致抛异常。</p>
<p>总结：1、利用缓存识别已经遍历过的节点； 2、利用Java引用，先提前设置对象地址，后完善对象。</p>
<h2 id="Spring启动过程"><a href="#Spring启动过程" class="headerlink" title="Spring启动过程"></a>Spring启动过程</h2><ol>
<li>读取web.xml文件。</li>
<li>创建 ServletContext，为 ioc 容器提供宿主环境。</li>
<li>触发容器初始化事件，调用 contextLoaderListener.contextInitialized()方法，在这个方法会初始化一个应用上下文WebApplicationContext，即 Spring 的 ioc 容器。ioc 容器初始化完成之后，会被存储到 ServletContext 中。</li>
<li>初始化web.xml中配置的Servlet。如DispatcherServlet，用于匹配、处理每个servlet请求。</li>
</ol>
<h2 id="Spring-的单例-Bean-是否有并发安全问题？"><a href="#Spring-的单例-Bean-是否有并发安全问题？" class="headerlink" title="Spring 的单例 Bean 是否有并发安全问题？"></a>Spring 的单例 Bean 是否有并发安全问题？</h2><p>当多个用户同时请求一个服务时，容器会给每一个请求分配一个线程，这时多个线程会并发执行该请求对应的业务逻辑，如果业务逻辑有对单例状态的修改（体现为此单例的成员属性），则必须考虑线程安全问题。</p>
<p><strong>无状态bean和有状态bean</strong></p>
<ul>
<li>有实例变量的bean，可以保存数据，是非线程安全的。</li>
<li>没有实例变量的bean，不能保存数据，是线程安全的。</li>
</ul>
<p>在Spring中无状态的Bean适合用单例模式，这样可以共享实例提高性能。有状态的Bean在多线程环境下不安全，一般用<code>Prototype</code>模式或者使用<code>ThreadLocal</code>解决线程安全问题。</p>
<h2 id="Spring-Bean如何保证并发安全？"><a href="#Spring-Bean如何保证并发安全？" class="headerlink" title="Spring Bean如何保证并发安全？"></a>Spring Bean如何保证并发安全？</h2><p>Spring的Bean默认都是单例的，某些情况下，单例是并发不安全的。</p>
<p>以 <code>Controller</code> 举例，假如我们在 <code>Controller</code> 中定义了成员变量。当多个请求来临，进入的都是同一个单例的 <code>Controller</code> 对象，并对此成员变量的值进行修改操作，因此会互相影响，会有并发安全的问题。</p>
<p>应该怎么解决呢？</p>
<p>为了让多个HTTP请求之间不互相影响，可以采取以下措施：</p>
<p><strong>1、单例变原型</strong></p>
<p>对 web 项目，可以 <code>Controller</code> 类上加注解 @<code>Scope(&quot;prototype&quot;)</code> 或 <code>@Scope(&quot;request&quot;)</code>，对非 web 项目，在 <code>Component</code> 类上添加注解 <code>@Scope(&quot;prototype&quot;)</code> 。</p>
<p>这种方式实现起来非常简单，但是很大程度上增大了 Bean 创建实例化销毁的服务器资源开销。</p>
<p><strong>2、尽量避免使用成员变量</strong></p>
<p>在业务允许的条件下，可以将成员变量替换为方法中的局部变量。这种方式个人认为是最恰当的。</p>
<p><strong>3、使用并发安全的类</strong></p>
<p>如果非要在单例Bean中使用成员变量，可以考虑使用并发安全的容器，如 <code>ConcurrentHashMap</code>、<code>ConcurrentHashSet</code> 等等，将我们的成员变量包装到这些并发安全的容器中进行管理即可。</p>
<p><strong>4、分布式或微服务的并发安全</strong></p>
<p>如果还要进一步考虑到微服务或分布式服务的影响，方式3便不合适了。这种情况下可以借助于可以共享某些信息的分布式缓存中间件，如Redis等。这样即可保证同一种服务的不同服务实例都拥有同一份共享信息了。</p>
<h2 id="Async注解的原理"><a href="#Async注解的原理" class="headerlink" title="@Async注解的原理"></a>@Async注解的原理</h2><p>当我们调用第三方接口或者方法的时候，我们不需要等待方法返回才去执行其它逻辑，这时如果响应时间过长，就会极大的影响程序的执行效率。所以这时就需要使用异步方法来并行执行我们的逻辑。在springboot中可以使用@Async注解实现异步操作。</p>
<p>使用@Async注解实现异步操作的步骤：</p>
<p>1.首先在启动类上添加 @EnableAsync 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span>  </span><br><span class="line">             <span class="title class_">AnnotationConfigApplicationContext</span>(App.class);</span><br><span class="line">        <span class="type">MyAsync</span> <span class="variable">service</span> <span class="operator">=</span> ctx.getBean(MyAsync.class);</span><br><span class="line">        System.out.println(service.getClass());</span><br><span class="line">        service.async1();</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread finish...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在对应的方法上添加@Async注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAsync</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;asyncTest...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码，控制台输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main thread finish...</span><br><span class="line">asyncTest...</span><br></pre></td></tr></table></figure>

<p>证明asyncTest方法异步执行了。</p>
<p>原理：</p>
<p>我们在主启动类上贴了一个@EnableAsync注解，才能使用@Async生效。@EnableAsync的作用是通过@import导入了AsyncConfigurationSelector。在AsyncConfigurationSelector的selectImports方法将ProxyAsyncConfiguration定义为Bean注入容器。在ProxyAsyncConfiguration中通过@Bean的方式注入AsyncAnnotationBeanPostProcessor类。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/20220628224208.png" alt="img"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(AsyncConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAsync &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfigurationSelector</span> <span class="keyword">extends</span> <span class="title class_">AdviceModeImportSelector</span>&lt;EnableAsync&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">			<span class="keyword">case</span> PROXY:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; ProxyAsyncConfiguration.class.getName() &#125;;</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyAsyncConfiguration</span> <span class="keyword">extends</span> <span class="title class_">AbstractAsyncConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(name = TaskManagementConfigUtils.ASYNC_ANNOTATION_PROCESSOR_BEAN_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> AsyncAnnotationBeanPostProcessor <span class="title function_">asyncAdvisor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建postProcessor</span></span><br><span class="line">        <span class="type">AsyncAnnotationBeanPostProcessor</span> <span class="variable">bpp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncAnnotationBeanPostProcessor</span>();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AsyncAnnotationBeanPostProcessor往往期创建了一个增强器AsyncAnnotationAdvisor。在AsyncAnnotationAdvisor的buildAdvice方法中，创建了AnnotationAsyncExecutionInterceptor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncAnnotationBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactoryAwareAdvisingPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">//创建一个增强器</span></span><br><span class="line">        <span class="type">AsyncAnnotationAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncAnnotationAdvisor</span>(<span class="built_in">this</span>.executor, <span class="built_in">this</span>.exceptionHandler);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        advisor.setBeanFactory(beanFactory);</span><br><span class="line">        <span class="built_in">this</span>.advisor = advisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncAnnotationAdvisor</span> <span class="keyword">extends</span> <span class="title class_">AbstractPointcutAdvisor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AsyncAnnotationAdvisor</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> Supplier&lt;Executor&gt; executor, <span class="meta">@Nullable</span> Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler)</span> &#123;</span><br><span class="line">        <span class="comment">//增强方法</span></span><br><span class="line">        <span class="built_in">this</span>.advice = buildAdvice(executor, exceptionHandler);</span><br><span class="line">        <span class="built_in">this</span>.pointcut = buildPointcut(asyncAnnotationTypes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托给AnnotationAsyncExecutionInterceptor拦截器</span></span><br><span class="line">    <span class="keyword">protected</span> Advice <span class="title function_">buildAdvice</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> Supplier&lt;Executor&gt; executor, <span class="meta">@Nullable</span> Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler)</span> &#123;</span><br><span class="line">        <span class="comment">//拦截器</span></span><br><span class="line">        <span class="type">AnnotationAsyncExecutionInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationAsyncExecutionInterceptor</span>(<span class="literal">null</span>);</span><br><span class="line">        interceptor.configure(executor, exceptionHandler);</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AnnotationAsyncExecutionInterceptor继承自AsyncExecutionInterceptor，间接实现了MethodInterceptor。该拦截器的实现的invoke方法把原来方法的调用提交到新的线程池执行，从而实现了方法的异步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncExecutionInterceptor</span> <span class="keyword">extends</span> <span class="title class_">AsyncExecutionAspectSupport</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>, Ordered &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="keyword">final</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//构建放到AsyncTaskExecutor执行Callable Task</span></span><br><span class="line">        Callable&lt;Object&gt; task = () -&gt; &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//提交到新的线程池执行</span></span><br><span class="line">        <span class="keyword">return</span> doSubmit(task, executor, invocation.getMethod().getReturnType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面分析可以看到，@Async注解其实是通过代理的方式来实现异步调用的。</p>
<p>那使用@Async有什么要注意的呢？</p>
<p>1.使用@Aysnc的时候最好配置一个线程池Executor以让线程复用节省资源，或者为SimpleAsyncTaskExecutor设置基于线程池实现的ThreadFactory，在否则会默认使用SimpleAsyncTaskExecutor，该executor会在每次调用时新建一个线程。</p>
<p>2.调用本类的异步方法是不会起作用的。这种方式绕过了代理而直接调用了方法，@Async注解会失效。</p>
<h2 id="为什么-Spring和IDEA-都不推荐使用-Autowired-注解？"><a href="#为什么-Spring和IDEA-都不推荐使用-Autowired-注解？" class="headerlink" title="为什么 Spring和IDEA 都不推荐使用 @Autowired 注解？"></a>为什么 Spring和IDEA 都不推荐使用 @Autowired 注解？</h2><p>idea 在我们经常使用的<code>@Autowired</code> 注解上添加了警告。警告内容是: <code>Field injection is not recommended</code>, 译为: <strong>不推荐使用属性注入</strong>。</p>
<p>Spring常用的注入方式有：属性注入, 构造方法注入, set 方法注入</p>
<ul>
<li>构造器注入：利用构造方法的参数注入依赖</li>
<li>set方法注入：调用setter的方法注入依赖</li>
<li>属性注入：在字段上使用@Autowired&#x2F;Resource注解</li>
</ul>
<p>其中，基于属性注入的方式，容易导致Spring 初始化失败。因为在Spring在初始化的时候，可能由于属性在被注入前就引用而导致空指针异常，进而导致容器初始化失败。</p>
<p>如果可能的话，尽量使用构造器注入。Lombok提供了一个注解<code>@RequiredArgsConstructor</code>, 可以方便我们快速进行构造注入。</p>
<p>@Autowired是属性注入，而且@Autowired默认是按照类型匹配（ByType），因此有可能会出现两个相同的类型bean，进而导致Spring 装配失败。</p>
<p>如果要使用属性注入的话，可以使用 <code>@Resource</code> 代替 <code>@Autowired</code> 注解。@Resource默认是按照名称匹配（ByName），如果找不到则是ByType注入。另外，@Autowired是Spring提供的，@Resource是JSR-250提供的，是Java标准，我们使用的IoC容器会去兼容它，这样即使更换容器，也可以正常工作。</p>
<h1 id="springmvc"><a href="#springmvc" class="headerlink" title="springmvc"></a>springmvc</h1><h2 id="说说你对-SpringMVC-的理解"><a href="#说说你对-SpringMVC-的理解" class="headerlink" title="说说你对 SpringMVC 的理解"></a>说说你对 SpringMVC 的理解</h2><p>SpringMVC是一种基于 Java 的实现MVC设计模型的请求驱动类型的轻量级Web框架，属于Spring框架的一个模块。</p>
<p>它通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful编程风格的请求。</p>
<h2 id="什么是MVC模式？"><a href="#什么是MVC模式？" class="headerlink" title="什么是MVC模式？"></a>什么是MVC模式？</h2><p>MVC的全名是<code>Model View Controller</code>，是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范。它是用一种业务逻辑、数据与界面显示分离的方法来组织代码，将众多的业务逻辑聚集到一个部件里面，在需要改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑，达到减少编码的时间。</p>
<p>View，视图是指用户看到并与之交互的界面。比如由html元素组成的网页界面，或者软件的客户端界面。MVC的好处之一在于它能为应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。</p>
<p>model，模型是指模型表示业务规则。在MVC的三个部件中，模型拥有最多的处理任务。被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。</p>
<p>controller，控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。</p>
<h2 id="SpringMVC-有哪些优点？"><a href="#SpringMVC-有哪些优点？" class="headerlink" title="SpringMVC 有哪些优点？"></a>SpringMVC 有哪些优点？</h2><ol>
<li>与 Spring 集成使用非常方便，生态好。</li>
<li>配置简单，快速上手。</li>
<li>支持 RESTful 风格。</li>
<li>支持各种视图技术，支持各种请求资源映射策略。</li>
</ol>
<h2 id="Spring-MVC和Struts的区别"><a href="#Spring-MVC和Struts的区别" class="headerlink" title="Spring MVC和Struts的区别"></a>Spring MVC和Struts的区别</h2><ol>
<li>Spring MVC是基于方法开发，Struts2是基于类开发的。<ul>
<li>Spring MVC会将用户请求的URL路径信息与Controller的某个方法进行映射，所有请求参数会注入到对应方法的形参上，生成Handler对象，对象中只有一个方法；</li>
<li>Struts每处理一次请求都会实例一个Action，Action类的所有方法使用的请求参数都是Action类中的成员变量，随着方法增多，整个Action也会变得混乱。</li>
</ul>
</li>
<li>Spring MVC支持单例开发模式，Struts只能使用多例<ul>
<li>Struts由于只能通过类的成员变量接收参数，故只能使用多例。</li>
</ul>
</li>
<li>Struts2 的核心是基于一个Filter即StrutsPreparedAndExcuteFilter，Spring MVC的核心是基于一个Servlet即DispatcherServlet(前端控制器)。</li>
<li>Struts处理速度稍微比Spring MVC慢，Struts使用了Struts标签，加载数据较慢。</li>
</ol>
<h2 id="Spring-MVC的工作原理"><a href="#Spring-MVC的工作原理" class="headerlink" title="Spring MVC的工作原理"></a>Spring MVC的工作原理</h2><p>Spring MVC的工作原理如下：</p>
<ol>
<li>DispatcherServlet 接收用户的请求</li>
<li>找到用于处理request的 handler 和 Interceptors，构造成 HandlerExecutionChain 执行链</li>
<li>找到 handler 相对应的 HandlerAdapter</li>
<li>执行所有注册拦截器的preHandler方法</li>
<li>调用 HandlerAdapter 的 handle() 方法处理请求，返回 ModelAndView</li>
<li>倒序执行所有注册拦截器的postHandler方法</li>
<li>请求视图解析和视图渲染</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/spring_mvc%E5%8E%9F%E7%90%86.png" alt="img"></p>
<h2 id="Spring-MVC的主要组件？"><a href="#Spring-MVC的主要组件？" class="headerlink" title="Spring MVC的主要组件？"></a>Spring MVC的主要组件？</h2><ul>
<li>前端控制器（DispatcherServlet）：接收用户请求，给用户返回结果。</li>
<li>处理器映射器（HandlerMapping）：根据请求的url路径，通过注解或者xml配置，寻找匹配的Handler。</li>
<li>处理器适配器（HandlerAdapter）：Handler 的适配器，调用 handler 的方法处理请求。</li>
<li>处理器（Handler）：执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装到ModelAndView对象中。</li>
<li>视图解析器（ViewResolver）：将逻辑视图名解析成真正的视图View。</li>
<li>视图（View）：接口类，实现类可支持不同的View类型（JSP、FreeMarker、Excel等）。</li>
</ul>
<h2 id="Spring-MVC的常用注解由有哪些？"><a href="#Spring-MVC的常用注解由有哪些？" class="headerlink" title="Spring MVC的常用注解由有哪些？"></a>Spring MVC的常用注解由有哪些？</h2><ul>
<li>@Controller：用于标识此类的实例是一个控制器。</li>
<li>@RequestMapping：映射Web请求（访问路径和参数）。</li>
<li>@ResponseBody：注解返回数据而不是返回页面</li>
<li>@RequestBody：注解实现接收 http 请求的 json 数据，将 json 数据转换为 java 对象。</li>
<li>@PathVariable：获得URL中路径变量中的值</li>
<li>@RestController：@Controller+@ResponseBody</li>
<li>@ExceptionHandler标识一个方法为全局异常处理的方法。</li>
</ul>
<h2 id="Controller-注解有什么用？"><a href="#Controller-注解有什么用？" class="headerlink" title="@Controller 注解有什么用？"></a>@Controller 注解有什么用？</h2><p><code>@Controller</code> 注解标记一个类为 Spring Web MVC 控制器。Spring MVC 会将扫描到该注解的类，然后扫描这个类下面带有 <code>@RequestMapping</code> 注解的方法，根据注解信息，为这个方法生成一个对应的处理器对象，在上面的 HandlerMapping 和 HandlerAdapter组件中讲到过。</p>
<p>当然，除了添加 <code>@Controller</code> 注解这种方式以外，你还可以实现 Spring MVC 提供的 <code>Controller</code> 或者 <code>HttpRequestHandler</code> 接口，对应的实现类也会被作为一个处理器对象</p>
<h2 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h2><p><code>@RequestMapping</code> 注解，用于配置处理器的 HTTP 请求方法，URI等信息，这样才能将请求和方法进行映射。这个注解可以作用于类上面，也可以作用于方法上面，在类上面一般是配置这个控制器的 URI 前缀。</p>
<h2 id="RestController-和-Controller-有什么区别？"><a href="#RestController-和-Controller-有什么区别？" class="headerlink" title="@RestController 和 @Controller 有什么区别？"></a>@RestController 和 @Controller 有什么区别？</h2><p><code>@RestController</code> 注解，在 <code>@Controller</code> 基础上，增加了 <code>@ResponseBody</code> 注解，更加适合目前前后端分离的架构下，提供 Restful API ，返回 JSON 数据格式。</p>
<h2 id="RequestMapping-和-GetMapping-注解有什么不同？"><a href="#RequestMapping-和-GetMapping-注解有什么不同？" class="headerlink" title="@RequestMapping 和 @GetMapping 注解有什么不同？"></a>@RequestMapping 和 @GetMapping 注解有什么不同？</h2><ol>
<li><code>@RequestMapping</code>：可注解在类和方法上；<code>@GetMapping</code> 仅可注册在方法上</li>
<li><code>@RequestMapping</code>：可进行 GET、POST、PUT、DELETE 等请求方法；<code>@GetMapping</code> 是 <code>@RequestMapping</code> 的 GET 请求方法的特例。</li>
</ol>
<h2 id="RequestParam-和-PathVariable-两个注解的区别"><a href="#RequestParam-和-PathVariable-两个注解的区别" class="headerlink" title="@RequestParam 和 @PathVariable 两个注解的区别"></a>@RequestParam 和 @PathVariable 两个注解的区别</h2><p>两个注解都用于方法参数，获取参数值的方式不同，<code>@RequestParam</code> 注解的参数从请求携带的参数中获取，而 <code>@PathVariable</code> 注解从请求的 URI 中获取</p>
<h2 id="RequestBody和-RequestParam的区别"><a href="#RequestBody和-RequestParam的区别" class="headerlink" title="@RequestBody和@RequestParam的区别"></a>@RequestBody和@RequestParam的区别</h2><p>@RequestBody一般处理的是在ajax请求中声明contentType: “application&#x2F;json; charset&#x3D;utf-8”时候。也就是json数据或者xml数据。</p>
<p>@RequestParam一般就是在ajax里面没有声明contentType的时候，为默认的<code>x-www-form-urlencoded</code>格式时。</p>
<h2 id="Spring-MVC的异常处理"><a href="#Spring-MVC的异常处理" class="headerlink" title="Spring MVC的异常处理"></a>Spring MVC的异常处理</h2><p>可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p>
<ul>
<li>使用系统定义好的异常处理器 SimpleMappingExceptionResolver</li>
<li>使用自定义异常处理器</li>
<li>使用异常处理注解</li>
</ul>
<h2 id="SpringMVC-用什么对象从后台向前台传递数据的？"><a href="#SpringMVC-用什么对象从后台向前台传递数据的？" class="headerlink" title="SpringMVC 用什么对象从后台向前台传递数据的？"></a>SpringMVC 用什么对象从后台向前台传递数据的？</h2><ol>
<li>将数据绑定到 request；</li>
<li>返回 ModelAndView；</li>
<li>通过ModelMap对象，可以在这个对象里面调用put方法，把对象加到里面，前端就可以通过el表达式拿到；</li>
<li>绑定数据到 Session中。</li>
</ol>
<h2 id="SpringMvc的Controller是不是单例模式？"><a href="#SpringMvc的Controller是不是单例模式？" class="headerlink" title="SpringMvc的Controller是不是单例模式？"></a>SpringMvc的Controller是不是单例模式？</h2><p>单例模式。在多线程访问的时候有线程安全问题，解决方案是在控制器里面不要写可变状态量，如果需要使用这些可变状态，可以使用ThreadLocal，为每个线程单独生成一份变量副本，独立操作，互不影响。</p>
<h2 id="介绍下-Spring-MVC-拦截器？"><a href="#介绍下-Spring-MVC-拦截器？" class="headerlink" title="介绍下 Spring MVC 拦截器？"></a>介绍下 Spring MVC 拦截器？</h2><p>Spring MVC 拦截器对应HandlerInterceor接口，该接口位于org.springframework.web.servlet的包中，定义了三个方法，若要实现该接口，就要实现其三个方法：</p>
<ol>
<li><strong>前置处理（preHandle()方法）</strong>：该方法在执行控制器方法之前执行。返回值为Boolean类型，如果返回false，表示拦截请求，不再向下执行，如果返回true，表示放行，程序继续向下执行（如果后面没有其他Interceptor，就会执行controller方法）。所以此方法可对请求进行判断，决定程序是否继续执行，或者进行一些初始化操作及对请求进行预处理。</li>
<li><strong>后置处理（postHandle()方法）</strong>：该方法在执行控制器方法调用之后，且在返回ModelAndView之前执行。由于该方法会在DispatcherServlet进行返回视图渲染之前被调用，所以此方法多被用于处理返回的视图，可通过此方法对请求域中的模型和视图做进一步的修改。</li>
<li><strong>已完成处理（afterCompletion()方法）</strong>：该方法在执行完控制器之后执行，由于是在Controller方法执行完毕后执行该方法，所以该方法适合进行一些资源清理，记录日志信息等处理操作。</li>
</ol>
<p>可以通过拦截器进行权限检验，参数校验，记录日志等操作</p>
<h2 id="SpringMvc怎么配置拦截器？"><a href="#SpringMvc怎么配置拦截器？" class="headerlink" title="SpringMvc怎么配置拦截器？"></a>SpringMvc怎么配置拦截器？</h2><p>有两种写法，一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在SpringMvc的配置文件中配置拦截器即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置SpringMvc的拦截器 --&gt;</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;myInterceptor&quot;</span> class=<span class="string">&quot;com.dabin.MyHandlerInterceptor&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- 只拦截部分请求 --&gt;</span><br><span class="line">    &lt;mvc:interceptor&gt;</span><br><span class="line">       &lt;mvc:mapping path=<span class="string">&quot;/xxx.do&quot;</span> /&gt;</span><br><span class="line">       &lt;bean class=<span class="string">&quot;com.dabin.MyHandlerInterceptorAdapter&quot;</span> /&gt;</span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-MVC-的拦截器和-Filter-过滤器有什么差别？"><a href="#Spring-MVC-的拦截器和-Filter-过滤器有什么差别？" class="headerlink" title="Spring MVC 的拦截器和 Filter 过滤器有什么差别？"></a>Spring MVC 的拦截器和 Filter 过滤器有什么差别？</h2><p>有以下几点：</p>
<ul>
<li><strong>功能相同</strong>：拦截器和 Filter 都能实现相应的功能</li>
<li><strong>容器不同</strong>：拦截器构建在 Spring MVC 体系中；Filter 构建在 Servlet 容器之上</li>
<li><strong>使用便利性不同</strong>：拦截器提供了三个方法，分别在不同的时机执行；过滤器仅提供一个方法</li>
</ul>
<h2 id="什么是REST"><a href="#什么是REST" class="headerlink" title="什么是REST?"></a>什么是REST?</h2><p>REST，英文全称，Resource Representational State Transfer，对资源的访问状态的变化通过url的变化表述出来。</p>
<p>Resource：<strong>资源</strong>。资源是REST架构或者说整个网络处理的核心。</p>
<p>Representational：<strong>某种表现形式</strong>，比如用JSON，XML，JPEG等。</p>
<p>State Transfer：<strong>状态变化</strong>。通过HTTP method实现。</p>
<p>REST描述的是在网络中client和server的一种交互形式。用大白话来说，就是<strong>通过URL就知道要什么资源，通过HTTP method就知道要干什么，通过HTTP status code就知道结果如何</strong>。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /tasks 获取所有任务</span><br><span class="line">POST /tasks 创建新任务</span><br><span class="line">GET /tasks/&#123;id&#125; 通过任务id获取任务</span><br><span class="line">PUT /tasks/&#123;id&#125; 更新任务</span><br><span class="line">DELETE /tasks/&#123;id&#125; 删除任务</span><br></pre></td></tr></table></figure>

<p>GET代表获取一个资源，POST代表添加一个资源，PUT代表修改一个资源，DELETE代表删除一个资源。</p>
<p>server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。用<code>HTTP Status Code</code>传递server的状态信息。比如最常用的 200 表示成功，500 表示Server内部错误等。</p>
<h2 id="使用REST有什么优势呢？"><a href="#使用REST有什么优势呢？" class="headerlink" title="使用REST有什么优势呢？"></a>使用REST有什么优势呢？</h2><p>第一，<strong>风格统一</strong>了，不会出现<code>delUser/deleteUser/removeUser</code>各种命名的代码了。</p>
<p>第二，<strong>面向资源</strong>，一目了然，具有自解释性。</p>
<p>第三，<strong>充分利用 HTTP 协议本身语义</strong></p>
<h1 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h1><h2 id="Mybatis是什么？"><a href="#Mybatis是什么？" class="headerlink" title="Mybatis是什么？"></a>Mybatis是什么？</h2><ul>
<li>MyBatis框架是一个开源的数据持久层框架。</li>
<li>它的内部封装了通过JDBC访问数据库的操作，支持普通的SQL查询、存储过程和高级映射，几乎消除了所有的JDBC代码和参数的手工设置以及结果集的检索。</li>
<li>MyBatis作为持久层框架，其主要思想是将程序中的大量SQL语句剥离出来，配置在配置文件当中，实现SQL的灵活配置。</li>
<li>这样做的好处是将SQL与程序代码分离，可以在不修改代码的情况下，直接在配置文件当中修改SQL。</li>
</ul>
<h2 id="ORM是什么"><a href="#ORM是什么" class="headerlink" title="ORM是什么"></a><strong>ORM是什么</strong></h2><p>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</p>
<h2 id="Mybatis和Hibernate的区别？"><a href="#Mybatis和Hibernate的区别？" class="headerlink" title="Mybatis和Hibernate的区别？"></a>Mybatis和Hibernate的区别？</h2><p>主要有以下几点区别：</p>
<ol>
<li>Hibernate的<strong>开发难度</strong>大于MyBatis，主要由于Hibernate比较复杂，庞大，学习周期比较长。</li>
<li>Hibernate属于<strong>全自动</strong>ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</li>
<li><strong>数据库扩展性</strong>的区别。Hibernate与数据库具体的关联在XML中，所以HQL对具体是用什么数据库并不是很关心。MyBatis由于所有sql都是依赖数据库书写的，所以扩展性、迁移性比较差。</li>
<li><strong>缓存机制</strong>的区别。Hibernate的二级缓存配置在SessionFactory生成配置文件中进行详细配置，然后再在具体的表对象映射中配置那种缓存。MyBatis的二级缓存配置都是在每个具体的表对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓冲机制，并且MyBatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</li>
<li><strong>日志系统完善性</strong>的区别。Hibernate日志系统非常健全，涉及广泛，而Mybatis则除了基本记录功能外，功能薄弱很多。</li>
<li><strong>sql的优化上，Mybatis要比Hibernate方便很多</strong>。由于Mybatis的sql都是写在xml里，因此优化sql比Hibernate方便很多。而Hibernate的sql很多都是自动生成的，无法直接维护sql；总之写sql的灵活度上Hibernate不及Mybatis。</li>
</ol>
<h2 id="MyBatis框架的优缺点及其适用的场合"><a href="#MyBatis框架的优缺点及其适用的场合" class="headerlink" title="MyBatis框架的优缺点及其适用的场合"></a>MyBatis框架的优缺点及其适用的场合</h2><p><strong>优点</strong></p>
<ol>
<li>与JDBC相比，减少了50%以上的代码量。</li>
<li>MyBatis是易学的持久层框架，小巧并且简单易学。</li>
<li>MyBatis相当灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL写在XML文件里，从程序代码中彻底分离，降低耦合度，便于统一的管理和优化，并可重用。</li>
<li>提供XML标签，支持编写动态的SQL，满足不同的业务需求。</li>
<li>提供映射标签，支持对象与数据库的ORM字段关系映射。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>SQL语句的编写工作量较大，对开发人员编写SQL的能力有一定的要求。</li>
<li>SQL语句依赖于数据库，导致数据库不具有好的移植性，不可以随便更换数据库。</li>
</ol>
<p><strong>适用场景</strong></p>
<p>MyBatis专注于SQL自身，是一个足够灵活的DAO层解决方案。对性能的要求很高，或者需求变化较多的项目，例如Web项目，那么MyBatis是不二的选择。</p>
<h2 id="Mybatis的工作原理"><a href="#Mybatis的工作原理" class="headerlink" title="Mybatis的工作原理"></a>Mybatis的工作原理</h2><ul>
<li>读取MyBatis配置文件：mybatis-config.xml为MyBatis的全局配置文件，配置了MyBatis的运行环境等信息，例如数据库连接信息。</li>
<li>加载映射文件。映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在MyBatis配置文件mybatis-config.xml中加载。mybatis-config.xml文件可以加载多个映射文件，每个文件对应数据库中的一张表。</li>
<li>构造会话工厂：通过MyBatis的环境等配置信息构建会话工厂SqlSessionFactory。</li>
<li>创建会话对象：由会话工厂创建SqlSession对象，该对象中包含了执行SQL语句的所有方法。</li>
<li>Executor执行器：MyBatis底层定义了一个Executor 接口来操作数据库，它将根据SqlSession传递的参数动态地生成需要执行的SQL语句，同时负责查询缓存的维护。</li>
<li>MappedStatement 对象：在Executor接口的执行方法中有一个MappedStatement类型的参数，该参数是对映射信息的封装，用于存储要映射的SQL语句的id、参数等信息。</li>
<li>输入参数映射：输入参数类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输入参数映射过程类似于 JDBC对preparedStatement对象设置参数的过程。</li>
<li>输出结果映射：输出结果类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输出结果映射过程类似于 JDBC对结果集的解析过程。</li>
</ul>
<h2 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h2><p>Mybatis有三种基本的Executor执行器，<code>SimpleExecutor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>。</p>
<p><code>SimpleExecutor</code>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p>
<p><code>ReuseExecutor</code>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</p>
<p><code>BatchExecutor</code>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p>
<p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p>
<h2 id="MyBatis中接口绑定有几种实现方式"><a href="#MyBatis中接口绑定有几种实现方式" class="headerlink" title="MyBatis中接口绑定有几种实现方式?"></a>MyBatis中接口绑定有几种实现方式?</h2><ol>
<li>通过注解绑定，在接口的方法上面加上 @Select@Update等注解里面包含Sql语句来绑定（SQL语句比较简单的时候，推荐注解绑定）</li>
<li>通过xml里面写SQL来绑定, 指定xml映射文件里面的namespace必须为接口的全路径名（SQL语句比较复杂的时候，推荐xml绑定）</li>
</ol>
<h2 id="Mybatis-是如何进行分页的？"><a href="#Mybatis-是如何进行分页的？" class="headerlink" title="Mybatis 是如何进行分页的？"></a>Mybatis 是如何进行分页的？</h2><p>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，先把数据都查出来，然后再做分页。</p>
<p>可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
<h2 id="分页插件的基本原理是什么？"><a href="#分页插件的基本原理是什么？" class="headerlink" title="分页插件的基本原理是什么？"></a>分页插件的基本原理是什么？</h2><p>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql（SQL 拼接 limit），根据 dialect 方言，添加对应的物理分页语句和物理分页参数，用到了技术 JDK 动态代理，用到了责任链设计模式。</p>
<h2 id="简述Mybatis的插件运行原理"><a href="#简述Mybatis的插件运行原理" class="headerlink" title="简述Mybatis的插件运行原理"></a>简述Mybatis的插件运行原理</h2><p>Mybatis仅可以编写针对 <code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code>、<code>Executor</code>这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是<code>InvocationHandler</code>的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<h2 id="如何编写一个插件？"><a href="#如何编写一个插件？" class="headerlink" title="如何编写一个插件？"></a>如何编写一个插件？</h2><p>编写插件：实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后再给插件编写注解，指定要拦截哪一个接口的哪些方法即可，最后在配置文件中配置你编写的插件。</p>
<h2 id="Mybatis-是否支持延迟加载？"><a href="#Mybatis-是否支持延迟加载？" class="headerlink" title="Mybatis 是否支持延迟加载？"></a>Mybatis 是否支持延迟加载？</h2><p>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载<code>lazyLoadingEnabled=true|false</code>。</p>
<h2 id="延迟加载的基本原理是什么？"><a href="#延迟加载的基本原理是什么？" class="headerlink" title="延迟加载的基本原理是什么？"></a>延迟加载的基本原理是什么？</h2><p>延迟加载的基本原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法。</p>
<p>比如调用<code>a.getB().getName()</code>，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用<code>a.setB(b)</code>，于是 a 的对象 b 属性就有值了，接着完成<code>a.getB().getName()</code>方法的调用。</p>
<p>当然了，不光是 Mybatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。</p>
<h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h2><p>#{ } 被解析成预编译语句，预编译之后可以直接执行，不需要重新编译sql。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//sqlMap 中如下的 sql 语句</span><br><span class="line">select * from user where name = #&#123;name&#125;;</span><br><span class="line">//解析成为预编译语句；编译好SQL语句再取值</span><br><span class="line">select * from user where name = ?;</span><br></pre></td></tr></table></figure>

<p>${ } 仅仅为一个字符串替换，每次执行sql之前需要进行编译，存在 sql 注入问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name = &#x27;$&#123;name&#125;&#x27;</span><br><span class="line">//传递的参数为 &quot;ruhua&quot; 时,解析为如下，然后发送数据库服务器进行编译。取值以后再去编译SQL语句。</span><br><span class="line">select * from user where name = &quot;ruhua&quot;;</span><br></pre></td></tr></table></figure>

<h2 id="Mybatis的预编译"><a href="#Mybatis的预编译" class="headerlink" title="Mybatis的预编译"></a>Mybatis的预编译</h2><p>数据库接受到sql语句之后，需要词法和语义解析，优化sql语句，制定执行计划。这需要花费一些时间。如果一条sql语句需要反复执行，每次都进行语法检查和优化，会浪费很多时间。预编译语句就是将sql语句中的<code>值用占位符替代</code>，即将<code>sql语句模板化</code>。一次编译、多次运行，省去了解析优化等过程。</p>
<p>mybatis是通过<code>PreparedStatement</code>和占位符来实现预编译的。</p>
<p>mybatis底层使用<code>PreparedStatement</code>，默认情况下，将对所有的 sql 进行预编译，将#{}替换为?，然后将带有占位符?的sql模板发送至mysql服务器，由服务器对此无参数的sql进行编译后，将编译结果缓存，然后直接执行带有真实参数的sql。</p>
<p>预编译的作用：</p>
<ol>
<li>预编译阶段可以优化 sql 的执行。预编译之后的 sql 多数情况下可以直接执行，数据库服务器不需要再次编译，可以提升性能。</li>
<li>预编译语句对象可以重复利用。把一个 sql 预编译后产生的 <code>PreparedStatement</code> 对象缓存下来，下次对于同一个sql，可以直接使用这个缓存的 PreparedState 对象。</li>
<li>防止SQL注入。使用预编译，而其后注入的参数将<code>不会再进行SQL编译</code>。也就是说其后注入进来的参数系统将不会认为它会是一条SQL语句，而默认其是一个参数。</li>
</ol>
<h2 id="一级缓存和二级缓存"><a href="#一级缓存和二级缓存" class="headerlink" title="一级缓存和二级缓存"></a>一级缓存和二级缓存</h2><p>缓存：合理使用缓存是优化中最常见的方法之一，将从数据库中查询出来的数据放入缓存中，下次使用时不必从数据库查询，而是直接从缓存中读取，避免频繁操作数据库，减轻数据库的压力，同时提高系统性能。</p>
<p>Mybatis里面设计了二级缓存来提升数据的检索效率，避免每次数据的访问都需要去查询数据库。</p>
<p><strong>一级缓存是SqlSession级别的缓存</strong>：Mybatis对缓存提供支持，默认情况下只开启一级缓存，一级缓存作用范围为同一个SqlSession。在SQL和参数相同的情况下，我们使用同一个SqlSession对象调用同一个Mapper方法，往往只会执行一次SQL。因为在使用SqlSession第一次查询后，Mybatis会将结果放到缓存中，以后再次查询时，如果没有声明需要刷新，并且缓存没超时的情况下，SqlSession只会取出当前缓存的数据，不会再次发送SQL到数据库。若使用不同的SqlSession，因为不同的SqlSession是相互隔离的，不会使用一级缓存。</p>
<p><strong>二级缓存是mapper级别的缓存</strong>：可以使缓存在各个SqlSession之间共享。当多个用户在查询数据的时候，只要有任何一个SqlSession拿到了数据就会放入到二级缓存里面，其他的SqlSession就可以从二级缓存加载数据。</p>
<p>二级缓存默认不开启，需要在mybatis-config.xml开启二级缓存：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通知 MyBatis 框架开启二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>并在相应的Mapper.xml文件添加cache标签，表示对哪个mapper 开启缓存：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>二级缓存要求返回的POJO必须是可序列化的，即要求实现Serializable接口。</p>
<p>当开启二级缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p>
<h1 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h1><h2 id="Springboot的优点"><a href="#Springboot的优点" class="headerlink" title="Springboot的优点"></a>Springboot的优点</h2><ul>
<li>内置servlet容器，不需要在服务器部署 tomcat。只需要将项目打成 jar 包，使用 java -jar xxx.jar一键式启动项目</li>
<li>SpringBoot提供了starter，把常用库聚合在一起，简化复杂的环境配置，快速搭建spring应用环境</li>
<li>可以快速创建独立运行的spring项目，集成主流框架</li>
<li>准生产环境的运行应用监控</li>
</ul>
<h2 id="Javaweb、spring、springmvc和springboot有什么区别，都是做什么用的？"><a href="#Javaweb、spring、springmvc和springboot有什么区别，都是做什么用的？" class="headerlink" title="Javaweb、spring、springmvc和springboot有什么区别，都是做什么用的？"></a>Javaweb、spring、springmvc和springboot有什么区别，都是做什么用的？</h2><p>JavaWeb是 Java 语言的 Web 开发技术，主要用于开发 Web 应用程序，包括基于浏览器的客户端和基于服务器的 Web 服务器。</p>
<p>Spring是一个轻量级的开源开发框架，主要用于管理 Java 应用程序中的组件和对象，并提供各种服务，如事务管理、安全控制、面向切面编程和远程访问等。它是一个综合性框架，可应用于所有类型的 Java 应用程序。</p>
<p>SpringMVC是 Spring 框架中的一个模块，用于开发 Web 应用程序并实现 MVC（模型-视图-控制器）设计模式，它将请求和响应分离，从而使得应用程序更加模块化、可扩展和易于维护。</p>
<p>Spring Boot是基于 Spring 框架开发的用于开发 Web 应用程序的框架，它帮助开发人员快速搭建和配置一个独立的、可执行的、基于 Spring 的应用程序，从而减少了繁琐和重复的配置工作。</p>
<p>综上所述，JavaWeb是基于 Java 语言的 Web 开发技术，而 Spring 是一个综合性的开发框架，SpringMVC用于开发 Web 应用程序实现 MVC 设计模式，而 Spring Boot 是基于 Spring 的 Web 应用程序开发框架。</p>
<h2 id="SpringBoot-中的-starter-到底是什么"><a href="#SpringBoot-中的-starter-到底是什么" class="headerlink" title="SpringBoot 中的 starter 到底是什么 ?"></a>SpringBoot 中的 starter 到底是什么 ?</h2><p>starter提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。</p>
<h2 id="运行-SpringBoot-有哪几种方式？"><a href="#运行-SpringBoot-有哪几种方式？" class="headerlink" title="运行 SpringBoot 有哪几种方式？"></a>运行 SpringBoot 有哪几种方式？</h2><ol>
<li>打包用命令或者者放到容器中运行</li>
<li>用 Maven&#x2F;Gradle 插件运行</li>
<li>直接执行 main 方法运行</li>
</ol>
<h2 id="SpringBoot-常用的-Starter-有哪些？"><a href="#SpringBoot-常用的-Starter-有哪些？" class="headerlink" title="SpringBoot 常用的 Starter 有哪些？"></a>SpringBoot 常用的 Starter 有哪些？</h2><ol>
<li>spring-boot-starter-web ：提供 Spring MVC + 内嵌的 Tomcat 。</li>
<li>spring-boot-starter-data-jpa ：提供 Spring JPA + Hibernate 。</li>
<li>spring-boot-starter-data-Redis ：提供 Redis 。</li>
<li>mybatis-spring-boot-starter ：提供 MyBatis 。</li>
</ol>
<h2 id="Spring-Boot-的核心注解是哪个？"><a href="#Spring-Boot-的核心注解是哪个？" class="headerlink" title="Spring Boot 的核心注解是哪个？"></a>Spring Boot 的核心注解是哪个？</h2><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p>
<ul>
<li>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</li>
<li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。</li>
<li>@ComponentScan：Spring组件扫描。</li>
</ul>
<h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h2><p>SpringBoot实现自动配置原理图解：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/SpringBoot%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86.jpg" alt="img"></p>
<p>在 application.properties 中设置属性 debug&#x3D;true，可以在控制台查看已启用和未启用的自动配置。</p>
<p>@SpringBootApplication是@Configuration、@EnableAutoConfiguration和@ComponentScan的组合。</p>
<p>@Configuration表示该类是Java配置类。</p>
<p>@ComponentScan开启自动扫描符合条件的bean（添加了@Controller、@Service等注解）。</p>
<p>@EnableAutoConfiguration会根据类路径中的jar依赖为项目进行自动配置，比如添加了<code>spring-boot-starter-web</code>依赖，会自动添加Tomcat和Spring MVC的依赖，然后Spring Boot会对Tomcat和Spring MVC进行自动配置（spring.factories EnableAutoConfiguration配置了<code>WebMvcAutoConfiguration</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(EnableAutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EnableAutoConfiguration主要由 @AutoConfigurationPackage，@Import(EnableAutoConfigurationImportSelector.class)这两个注解组成的。</p>
<p>@AutoConfigurationPackage用于将启动类所在的包里面的所有组件注册到spring容器。</p>
<p>@Import 将EnableAutoConfigurationImportSelector注入到spring容器中，EnableAutoConfigurationImportSelector通过SpringFactoriesLoader从类路径下去读取META-INF&#x2F;spring.factories文件信息，此文件中有一个key为org.springframework.boot.autoconfigure.EnableAutoConfiguration，定义了一组需要自动配置的bean。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span></span><br></pre></td></tr></table></figure>

<p>这些配置类不是都会被加载，会根据xxxAutoConfiguration上的@ConditionalOnClass等条件判断是否加载，符合条件才会将相应的组件被加载到spring容器。（比如mybatis-spring-boot-starter，会自动配置sqlSessionFactory、sqlSessionTemplate、dataSource等mybatis所需的组件）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; EnableAspectJAutoProxy.class, Aspect.class, Advice.class,</span></span><br><span class="line"><span class="meta">		AnnotatedElement.class &#125;)</span> <span class="comment">//类路径存在EnableAspectJAutoProxy等类文件，才会加载此配置类</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = false)</span></span><br><span class="line">	<span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;, matchIfMissing = false)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JdkDynamicAutoProxyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line">	<span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CglibAutoProxyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局配置文件中的属性如何生效，比如：server.port&#x3D;8081，是如何生效的？</p>
<p>@ConfigurationProperties的作用就是将配置文件的属性绑定到对应的bean上。全局配置的属性如：server.port等，通过@ConfigurationProperties注解，绑定到对应的XxxxProperties bean，通过这个 bean 获取相应的属性（serverProperties.getPort()）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server.port = 8080</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;server&quot;, ignoreUnknownFields = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerProperties</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Integer port;</span><br><span class="line">	<span class="keyword">private</span> InetAddress address;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@NestedConfigurationProperty</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ErrorProperties</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorProperties</span>();</span><br><span class="line">	<span class="keyword">private</span> Boolean useForwardHeaders;</span><br><span class="line">	<span class="keyword">private</span> String serverHeader;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现自动配置"><a href="#实现自动配置" class="headerlink" title="实现自动配置"></a>实现自动配置</h2><p>实现当某个类存在时，自动配置这个类的bean，并且可以在application.properties中配置bean的属性。</p>
<p>（1）新建Maven项目spring-boot-starter-hello，修改pom.xml如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.tyson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0.M1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）属性配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + msg;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MSG</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> MSG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）自动配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.tyson.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(HelloServiceProperties.class)</span> <span class="comment">//1</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(HelloService.class)</span> <span class="comment">//2</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix=&quot;hello&quot;, value = &quot;enabled&quot;, matchIfMissing = true)</span> <span class="comment">//3</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloServiceProperties helloServiceProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(HelloService.class)</span> <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">public</span> HelloService <span class="title function_">helloService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">helloService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloService</span>();</span><br><span class="line">        helloService.setMsg(helloServiceProperties.getMsg());</span><br><span class="line">        <span class="keyword">return</span> helloService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>@EnableConfigurationProperties 注解开启属性注入，将带有@ConfigurationProperties 注解的类注入为Spring 容器的 Bean。</li>
<li>当 HelloService 在类路径的条件下。</li>
<li>当设置 hello&#x3D;enabled 的情况下，如果没有设置则默认为 true，即条件符合。</li>
<li>当容器没有这个 Bean 的时候。</li>
</ol>
<p>（4）注册配置</p>
<p>想要自动配置生效，需要注册自动配置类。在 src&#x2F;main&#x2F;resources 下新建 META-INF&#x2F;spring.factories。添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.tyson.config.HelloServiceAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>“&quot;是为了换行后仍然能读到属性。若有多个自动配置，则用逗号隔开。</p>
<p>（5）使用starter</p>
<p>在 Spring Boot 项目的 pom.xml 中添加：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.tyson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.tyson.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.getMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在项目中没有配置 HelloService bean，但是我们可以注入这个bean，这是通过自动配置实现的。</p>
<p>在 application.properties 中添加 debug 属性，运行配置类，在控制台可以看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HelloServiceAutoConfiguration matched:</span><br><span class="line">   - <span class="meta">@ConditionalOnClass</span> found required class <span class="string">&#x27;com.tyson.service.HelloService&#x27;</span> (OnClassCondition)</span><br><span class="line">   - <span class="meta">@ConditionalOnProperty</span> (hello.enabled) matched (OnPropertyCondition)</span><br><span class="line"></span><br><span class="line">HelloServiceAutoConfiguration#helloService matched:</span><br><span class="line">   - <span class="meta">@ConditionalOnMissingBean</span> (types: com.tyson.service.HelloService; SearchStrategy: all) did not find any <span class="title function_">beans</span> <span class="params">(OnBeanCondition)</span></span><br></pre></td></tr></table></figure>

<p>可以在 application.properties 中配置 msg 的内容：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hello.msg</span>=<span class="string">大彬</span></span><br></pre></td></tr></table></figure>

<h2 id="Value注解的原理"><a href="#Value注解的原理" class="headerlink" title="@Value注解的原理"></a>@Value注解的原理</h2><p>@Value的解析就是在bean初始化阶段。BeanPostProcessor定义了bean初始化前后用户可以对bean进行操作的接口方法，它的一个重要实现类<code>AutowiredAnnotationBeanPostProcessor</code>为bean中的@Autowired和@Value注解的注入功能提供支持。</p>
<h2 id="Spring-Boot-需要独立的容器运行吗？"><a href="#Spring-Boot-需要独立的容器运行吗？" class="headerlink" title="Spring Boot 需要独立的容器运行吗？"></a>Spring Boot 需要独立的容器运行吗？</h2><p>不需要，内置了 Tomcat&#x2F; Jetty 等容器。</p>
<h2 id="Spring-Boot-支持哪些日志框架？"><a href="#Spring-Boot-支持哪些日志框架？" class="headerlink" title="Spring Boot 支持哪些日志框架？"></a>Spring Boot 支持哪些日志框架？</h2><p>Spring Boot 支持 Java Util Logging, Log4j2, Lockback 作为日志框架，如果你使用 Starters 启动器，Spring Boot 将使用 Logback 作为默认日志框架，但是不管是那种日志框架他都支持将配置文件输出到控制台或者文件中。</p>
<h2 id="YAML-配置的优势在哪里"><a href="#YAML-配置的优势在哪里" class="headerlink" title="YAML 配置的优势在哪里 ?"></a>YAML 配置的优势在哪里 ?</h2><p>YAML 配置和传统的 properties 配置相比之下，有这些优势：</p>
<ul>
<li>配置有序</li>
<li>简洁明了，支持数组，数组中的元素可以是基本数据类型也可以是对象</li>
</ul>
<p>缺点就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p>
<h2 id="什么是-Spring-Profiles？"><a href="#什么是-Spring-Profiles？" class="headerlink" title="什么是 Spring Profiles？"></a>什么是 Spring Profiles？</h2><p>在项目的开发中，有些配置文件在开发、测试或者生产等不同环境中可能是不同的，例如数据库连接、redis的配置等等。那我们如何在不同环境中自动实现配置的切换呢？Spring给我们提供了profiles机制给我们提供的就是来回切换配置文件的功能</p>
<p>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</p>
<h2 id="SpringBoot多数据源事务如何管理"><a href="#SpringBoot多数据源事务如何管理" class="headerlink" title="SpringBoot多数据源事务如何管理"></a>SpringBoot多数据源事务如何管理</h2><p>第一种方式是在service层的@TransactionManager中使用transactionManager指定DataSourceConfig中配置的事务。</p>
<p>第二种是使用jta-atomikos实现分布式事务管理。</p>
<h2 id="spring-boot-starter-parent-有什么用"><a href="#spring-boot-starter-parent-有什么用" class="headerlink" title="spring-boot-starter-parent 有什么用 ?"></a>spring-boot-starter-parent 有什么用 ?</h2><p>新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p>
<ol>
<li>定义了 Java 编译版本。</li>
<li>使用 UTF-8 格式编码。</li>
<li>执行打包操作的配置。</li>
<li>自动化的资源过滤。</li>
<li>自动化的插件配置。</li>
<li>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</li>
</ol>
<h2 id="Spring-Boot-打成的-jar-和普通的-jar-有什么区别"><a href="#Spring-Boot-打成的-jar-和普通的-jar-有什么区别" class="headerlink" title="Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?"></a>Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</h2><ul>
<li>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 <code>java -jar xxx.jar</code> 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</li>
<li>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 <code>\BOOT-INF\classes</code> 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</li>
</ul>
<h2 id="SpringBoot多数据源拆分的思路"><a href="#SpringBoot多数据源拆分的思路" class="headerlink" title="SpringBoot多数据源拆分的思路"></a>SpringBoot多数据源拆分的思路</h2><p>先在properties配置文件中配置两个数据源，创建分包mapper，使用@ConfigurationProperties读取properties中的配置，使用@MapperScan注册到对应的mapper包中 。</p>
<h1 id="springcloud"><a href="#springcloud" class="headerlink" title="springcloud"></a>springcloud</h1><h2 id="1、什么是Spring-Cloud-？"><a href="#1、什么是Spring-Cloud-？" class="headerlink" title="1、什么是Spring Cloud ？"></a>1、什么是Spring Cloud ？</h2><p>Spring cloud 流应用程序启动器是基于 Spring Boot 的 Spring 集成应用程序，提供与外部系统的集成。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序。</p>
<h2 id="2、什么是微服务？"><a href="#2、什么是微服务？" class="headerlink" title="2、什么是微服务？"></a>2、什么是微服务？</h2><p>微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分为一组小的服务，每个服务运行在其独立的自己的进程中，服务之间相互协调、互相配合，为用户提供最终价值。服务之间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）,每个服务都围绕着具体的业务进行构建，并且能够被独立的构建在生产环境、类生产环境等。另外，应避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。</p>
<p>通俗地来讲：</p>
<p>微服务就是一个独立的职责单一的服务应用程序。在 intellij idea 工具里面就是用maven开发的一个个独立的module，具体就是使用springboot 开发的一个小的模块，处理单一专业的业务逻辑，一个模块只做一个事情。</p>
<p>微服务强调的是服务大小，关注的是某一个点，具体解决某一个问题&#x2F;落地对应的一个服务应用，可以看做是idea 里面一个 module。</p>
<h2 id="3、Spring-Cloud有什么优势"><a href="#3、Spring-Cloud有什么优势" class="headerlink" title="3、Spring Cloud有什么优势"></a>3、Spring Cloud有什么优势</h2><p>使用 Spring Boot 开发分布式微服务时，我们面临以下问题</p>
<ul>
<li>与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。</li>
<li>服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。</li>
<li>冗余-分布式系统中的冗余问题。</li>
<li>负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。</li>
<li>性能-问题 由于各种运营开销导致的性能问题。</li>
<li>部署复杂性-Devops 技能的要求。</li>
</ul>
<h2 id="4、微服务之间如何独立通讯的"><a href="#4、微服务之间如何独立通讯的" class="headerlink" title="4、微服务之间如何独立通讯的?"></a>4、微服务之间如何独立通讯的?</h2><p>同步通信：dobbo通过 RPC 远程过程调用、springcloud通过 REST 接口json调用等。</p>
<p>异步：消息队列，如：<code>RabbitMq</code>、<code>ActiveM</code>、<code>Kafka</code>等消息队列。</p>
<h2 id="5、-什么是服务熔断？什么是服务降级？"><a href="#5、-什么是服务熔断？什么是服务降级？" class="headerlink" title="5、 什么是服务熔断？什么是服务降级？"></a>5、 <strong>什么是服务熔断？什么是服务降级？</strong></h2><p>熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在Spring Cloud框架里熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制。</p>
<p>服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，虽然水平下降，但好歹可用，比直接挂掉强。</p>
<p><code>Hystrix</code>相关注解<code>@EnableHystrix</code>：开启熔断 <code>@HystrixCommand(fallbackMethod=”XXX”)</code>，声明一个失败回滚处理函数<code>XXX</code>，当被注解的方法执行超时（默认是1000毫秒），就会执行<code>fallback</code>函数，返回错误提示。</p>
<h2 id="6、-请说说Eureka和zookeeper-的区别？"><a href="#6、-请说说Eureka和zookeeper-的区别？" class="headerlink" title="6、 请说说Eureka和zookeeper 的区别？"></a>6、 请说说Eureka和zookeeper 的区别？</h2><p>Zookeeper保证了CP，Eureka保证了AP。</p>
<blockquote>
<p>A：高可用</p>
<p>C：一致性</p>
<p>P：分区容错性</p>
</blockquote>
<p>1.当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的信息，但不能容忍直接down掉不可用。也就是说，服务注册功能对高可用性要求比较高，但zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新选leader。问题在于，选取leader时间过长，30 ~ 120s，且选取期间zk集群都不可用，这样就会导致选取期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够恢复，但是漫长的选取时间导致的注册长期不可用是不能容忍的。</p>
<p>2.Eureka保证了可用性，Eureka各个节点是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点仍然可以提供注册和查询服务。而Eureka的客户端向某个Eureka注册或发现时发生连接失败，则会自动切换到其他节点，只要有一台Eureka还在，就能保证注册服务可用，只是查到的信息可能不是最新的。除此之外，Eureka还有自我保护机制，如果在15分钟内超过85%的节点没有正常的心跳，那么Eureka就认为客户端与注册中心发生了网络故障，此时会出现以下几种情况：</p>
<p>①、Eureka不在从注册列表中移除因为长时间没有收到心跳而应该过期的服务。</p>
<p>②、Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点仍然可用）</p>
<p>③、当网络稳定时，当前实例新的注册信息会被同步到其他节点。</p>
<p>因此，Eureka可以很好地应对因网络故障导致部分节点失去联系的情况，而不会像Zookeeper那样使整个微服务瘫痪</p>
<h2 id="7、SpringBoot和SpringCloud的区别？"><a href="#7、SpringBoot和SpringCloud的区别？" class="headerlink" title="7、SpringBoot和SpringCloud的区别？"></a>7、SpringBoot和SpringCloud的区别？</h2><p>SpringBoot专注于快速方便得开发单个个体微服务。</p>
<p>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，</p>
<p>为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务</p>
<p>SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系.</p>
<p>SpringBoot专注于快速、方便得开发单个微服务个体，SpringCloud关注全局的服务治理框架。</p>
<h2 id="8、负载平衡的意义什么？"><a href="#8、负载平衡的意义什么？" class="headerlink" title="8、负载平衡的意义什么？"></a>8、负载平衡的意义什么？</h2><p>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源 的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</p>
<h2 id="9、什么是Hystrix？它如何实现容错？"><a href="#9、什么是Hystrix？它如何实现容错？" class="headerlink" title="9、什么是Hystrix？它如何实现容错？"></a>9、什么是Hystrix？它如何实现容错？</h2><p>Hystrix是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。</p>
<p>通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作。</p>
<p>思考一下微服务：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/springcloud-microservice.png" alt="img"></p>
<p>假设如果上图中的微服务9失败了，那么使用传统方法我们将传播一个异常。但这仍然会导致整个系统崩溃。</p>
<p>随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达1000.这是hystrix出现的地方 我们将使用Hystrix在这种情况下的Fallback方法功能。我们有两个服务employee-consumer使用由employee-consumer公开的服务。</p>
<p>简化图如下所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/springcloud2.png" alt="img"></p>
<p>现在假设由于某种原因，employee-producer公开的服务会抛出异常。我们在这种情况下使用Hystrix定义了一个回退方法。这种后备方法应该具有与公开服务相同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。</p>
<h2 id="10、什么是Hystrix断路器？我们需要它吗？"><a href="#10、什么是Hystrix断路器？我们需要它吗？" class="headerlink" title="10、什么是Hystrix断路器？我们需要它吗？"></a>10、什么是Hystrix断路器？我们需要它吗？</h2><p>由于某些原因，employee-consumer公开服务会引发异常。在这种情况下使用Hystrix我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法返回一些默认值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/springcloud3.png" alt="img"></p>
<p>如果firstPage method() 中的异常继续发生，则Hystrix电路将中断，并且员工使用者将一起跳过firtsPage方法，并直接调用回退方法。断路器的目的是给第一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可能发生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。</p>
<h2 id="11、说说-RPC-的实现原理"><a href="#11、说说-RPC-的实现原理" class="headerlink" title="11、说说 RPC 的实现原理"></a>11、说说 RPC 的实现原理</h2><p>首先需要有处理网络连接通讯的模块，负责连接建立、管理和消息的传输。其次需要有编 解码的模块，因为网络通讯都是传输的字节码，需要将我们使用的对象序列化和反序列化。剩下的就是客户端和服务器端的部分，服务器端暴露要开放的服务接口，客户调用服 务接口的一个代理实现，这个代理实现负责收集数据、编码并传输给服务器然后等待结果返回。</p>
<h2 id="12，eureka自我保护机制是什么"><a href="#12，eureka自我保护机制是什么" class="headerlink" title="12，eureka自我保护机制是什么?"></a>12，eureka自我保护机制是什么?</h2><p>当Eureka Server 节点在短时间内丢失了过多实例的连接时（比如网络故障或频繁启动关闭客户端）节点会进入自我保护模式，保护注册信息，不再删除注册数据，故障恢复时，自动退出自我保护模式。</p>
<h2 id="13，什么是Ribbon？"><a href="#13，什么是Ribbon？" class="headerlink" title="13，什么是Ribbon？"></a>13，什么是Ribbon？</h2><p>ribbon是一个负载均衡客户端，可以很好地控制htt和tcp的一些行为。<code>feign默认集成了ribbon</code>。</p>
<h2 id="14，什么是-Netflix-Feign？它的优点是什么？"><a href="#14，什么是-Netflix-Feign？它的优点是什么？" class="headerlink" title="14，什么是 Netflix Feign？它的优点是什么？"></a>14，什么是 Netflix Feign？它的优点是什么？</h2><p>Feign 是受到 Retrofit，JAXRS-2.0 和 WebSocket 启发的 java 客户端联编程序。</p>
<p>Feign 的第一个目标是将约束分母的复杂性统一到 http apis，而不考虑其稳定性。</p>
<p>特点：</p>
<ul>
<li>Feign 采用的是基于接口的注解</li>
<li>Feign 整合了ribbon，具有负载均衡的能力</li>
<li>整合了Hystrix，具有熔断的能力</li>
</ul>
<p>使用方式</p>
<ul>
<li>添加pom依赖。</li>
<li>启动类添加<code>@EnableFeignClients</code></li>
<li>定义一个接口<code>@FeignClient(name=“xxx”)</code>指定调用哪个服务</li>
</ul>
<h2 id="15，-Ribbon和Feign的区别？"><a href="#15，-Ribbon和Feign的区别？" class="headerlink" title="15， Ribbon和Feign的区别？"></a>15， Ribbon和Feign的区别？</h2><p>1.<strong>启动类注解不同</strong>，Ribbon是@RibbonClient feign的是@EnableFeignClients；2.<strong>服务指定的位置不同</strong>，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明；3.<strong>调用方式不同</strong>，Ribbon需要自己构建http请求，模拟http请求。</p>
<h2 id="16、Spring-Cloud-的核心组件有哪些？"><a href="#16、Spring-Cloud-的核心组件有哪些？" class="headerlink" title="16、Spring Cloud 的核心组件有哪些？"></a>16、Spring Cloud 的核心组件有哪些？</h2><ul>
<li>Eureka：服务注册于发现。</li>
<li>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。</li>
<li>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。</li>
<li>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</li>
<li>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</li>
</ul>
<h2 id="17、说说Spring-Boot和Spring-Cloud的关系"><a href="#17、说说Spring-Boot和Spring-Cloud的关系" class="headerlink" title="17、说说Spring Boot和Spring Cloud的关系"></a>17、说说Spring Boot和Spring Cloud的关系</h2><p>Spring Boot是Spring推出用于解决传统框架配置文件冗余,装配组件繁杂的基于Maven的解决方案,旨在快速搭建单个微服务而Spring Cloud专注于解决各个微服务之间的协调与配置,服务之间的通信,熔断,负载均衡等技术维度并相同,并且Spring Cloud是依赖于Spring Boot的,而Spring Boot并不是依赖与Spring Cloud,甚至还可以和Dubbo进行优秀的整合开发</p>
<p>总结</p>
<ul>
<li>SpringBoot专注于快速方便的开发单个个体的微服务</li>
<li>SpringCloud是关注全局的微服务协调整理治理框架,整合并管理各个微服务,为各个微服务之间提供,配置管理,服务发现,断路器,路由,事件总线等集成服务</li>
<li>Spring Boot不依赖于Spring Cloud，Spring Cloud依赖于Spring Boot,属于依赖关系</li>
<li>Spring Boot专注于快速,方便的开发单个的微服务个体,Spring Cloud关注全局的服务治理框架</li>
</ul>
<h2 id="18、说说微服务之间是如何独立通讯的？"><a href="#18、说说微服务之间是如何独立通讯的？" class="headerlink" title="18、说说微服务之间是如何独立通讯的？"></a>18、说说微服务之间是如何独立通讯的？</h2><p><strong>远程过程调用（Remote Procedure Invocation）</strong></p>
<p>也就是我们常说的服务的注册与发现，直接通过远程过程调用来访问别的service。</p>
<p><strong>优点</strong>：简单，常见,因为没有中间件代理，系统更简单</p>
<p><strong>缺点</strong>：只支持请求&#x2F;响应的模式，不支持别的，比如通知、请求&#x2F;异步响应、发布&#x2F;订阅、发布&#x2F;异步响应，降低了可用性，因为客户端和服务端在请求过程中必须都是可用的。</p>
<p><strong>消息</strong></p>
<p>使用异步消息来做服务间通信。服务间通过消息管道来交换消息，从而通信。</p>
<p><strong>优点</strong>：把客户端和服务端解耦，更松耦合，提高可用性，因为消息中间件缓存了消息，直到消费者可以消费， 支持很多通信机制比如通知、请求&#x2F;异步响应、发布&#x2F;订阅、发布&#x2F;异步响应。</p>
<p><strong>缺点</strong>：消息中间件有额外的复杂。</p>
<h2 id="19、Spring-Cloud如何实现服务的注册"><a href="#19、Spring-Cloud如何实现服务的注册" class="headerlink" title="19、Spring Cloud如何实现服务的注册?"></a>19、Spring Cloud如何实现服务的注册?</h2><p>服务发布时，指定对应的服务名，将服务注册到 注册中心(<code>Eureka 、Zookeeper)</code>。</p>
<p>注册中心加<code>@EnableEurekaServer</code>，服务用<code>@EnableDiscoveryClient</code>，然后用ribbon或feign进行服务直接的调用发现。</p>
<h2 id="20、什么是服务熔断？"><a href="#20、什么是服务熔断？" class="headerlink" title="20、什么是服务熔断？"></a>20、什么是服务熔断？</h2><p>在复杂的分布式系统中,微服务之间的相互调用,有可能出现各种各样的原因导致服务的阻塞,在高并发场景下,服务的阻塞意味着线程的阻塞,导致当前线程不可用,服务器的线程全部阻塞,导致服务器崩溃,由于服务之间的调用关系是同步的,会对整个微服务系统造成服务雪崩</p>
<p>为了解决某个微服务的调用响应时间过长或者不可用进而占用越来越多的系统资源引起雪崩效应就需要进行服务熔断和服务降级处理。</p>
<p>所谓的服务熔断指的是某个服务故障或异常一起类似显示世界中的“保险丝”当某个异常条件被触发就直接熔断整个服务，而不是一直等到此服务超时。</p>
<p>服务熔断就是相当于我们电闸的保险丝,一旦发生服务雪崩的,就会熔断整个服务,通过维护一个自己的线程池,当线程达到阈值的时候就启动服务降级,如果其他请求继续访问就直接返回fallback的默认值</p>
<h2 id="21、了解Eureka自我保护机制吗？"><a href="#21、了解Eureka自我保护机制吗？" class="headerlink" title="21、了解Eureka自我保护机制吗？"></a>21、了解Eureka自我保护机制吗？</h2><p>当Eureka Server 节点在短时间内丢失了过多实例的连接时（比如网络故障或频繁启动关闭客户端）节点会进入自我保护模式，保护注册信息，不再删除注册数据，故障恢复时，自动退出自我保护模式。</p>
<h2 id="22、熟悉-Spring-Cloud-Bus-吗"><a href="#22、熟悉-Spring-Cloud-Bus-吗" class="headerlink" title="22、熟悉 Spring Cloud Bus 吗?"></a>22、熟悉 Spring Cloud Bus 吗?</h2><p>spring cloud bus 将分布式的节点用轻量的消息代理连接起来，它可以用于广播配置文件的更改或者服务直接的通讯，也可用于监控。如果修改了配置文件，发送一次请求，所有的客户端便会重新读取配置文件。</p>
<h2 id="23、Spring-Cloud-断路器有什么作用"><a href="#23、Spring-Cloud-断路器有什么作用" class="headerlink" title="23、Spring Cloud 断路器有什么作用?"></a>23、Spring Cloud 断路器有什么作用?</h2><p>当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应，当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）。一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象，这时候断路器完全打开 那么下次请求就不会请求到该服务。</p>
<p>半开：短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭。关闭：当服务一直处于正常状态 能正常调用。</p>
<h2 id="24、了解Spring-Cloud-Config-吗"><a href="#24、了解Spring-Cloud-Config-吗" class="headerlink" title="24、了解Spring Cloud Config 吗?"></a>24、了解Spring Cloud Config 吗?</h2><p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件<code>Spring Cloud Config</code>，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。</p>
<p>在<code>Spring Cloud Config</code> 组件中，分两个角色，一是config server，二是config client。</p>
<p>使用方式：</p>
<ul>
<li>添加pom依赖</li>
<li>配置文件添加相关配置</li>
<li>启动类添加注解@EnableConfigServer</li>
</ul>
<h2 id="25、说说你对Spring-Cloud-Gateway的理解"><a href="#25、说说你对Spring-Cloud-Gateway的理解" class="headerlink" title="25、说说你对Spring Cloud Gateway的理解"></a>25、说说你对Spring Cloud Gateway的理解</h2><p>Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。</p>
<p>使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。</p>
<h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h2 id="什么是MySQL"><a href="#什么是MySQL" class="headerlink" title="什么是MySQL"></a>什么是MySQL</h2><p>MySQL是一个关系型数据库，它采用表的形式来存储数据。你可以理解成是Excel表格，既然是表的形式存储数据，就有表结构（行和列）。行代表每一行数据，列代表该行中的每个值。列上的值是有数据类型的，比如：整数、字符串、日期等等。</p>
<h2 id="事务的四大特性？"><a href="#事务的四大特性？" class="headerlink" title="事务的四大特性？"></a>事务的四大特性？</h2><p><strong>事务特性ACID</strong>：<strong>原子性</strong>（<code>Atomicity</code>）、<strong>一致性</strong>（<code>Consistency</code>）、<strong>隔离性</strong>（<code>Isolation</code>）、<strong>持久性</strong>（<code>Durability</code>）。</p>
<ul>
<li><strong>原子性</strong>是指事务包含的所有操作要么全部成功，要么全部失败回滚。</li>
<li><strong>一致性</strong>是指一个事务执行之前和执行之后都必须处于一致性状态。比如a与b账户共有1000块，两人之间转账之后无论成功还是失败，它们的账户总和还是1000。</li>
<li><strong>隔离性</strong>。跟隔离级别相关，如<code>read committed</code>，一个事务只能读到已经提交的修改。</li>
<li><strong>持久性</strong>是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>
</ul>
<h2 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h2><p><strong>第一范式1NF</strong></p>
<p>确保数据库表字段的原子性。</p>
<p>比如字段 <code>userInfo</code>: <code>广东省 10086&#39;</code> ，依照第一范式必须拆分成 <code>userInfo</code>: <code>广东省</code> <code>userTel</code>:<code> 10086</code>两个字段。</p>
<p><strong>第二范式2NF</strong></p>
<p>首先要满足第一范式，另外包含两部分内容，一是表必须有一个主键；二是非主键列必须完全依赖于主键，而不能只依赖于主键的一部分。</p>
<p>举个例子。假定选课关系表为<code>student_course</code>(student_no, student_name, age, course_name, grade, credit)，主键为(student_no, course_name)。其中学分完全依赖于课程名称，姓名年龄完全依赖学号，不符合第二范式，会导致数据冗余（学生选n门课，姓名年龄有n条记录）、插入异常（插入一门新课，因为没有学号，无法保存新课记录）等问题。</p>
<p>应该拆分成三个表：学生：<code>student</code>(stuent_no, student_name, 年龄)；课程：<code>course</code>(course_name, credit)；选课关系：<code>student_course_relation</code>(student_no, course_name, grade)。</p>
<p><strong>第三范式3NF</strong></p>
<p>首先要满足第二范式，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</p>
<p>假定学生关系表为Student(student_no, student_name, age, academy_id, academy_telephone)，主键为”学号”，其中学院id依赖于学号，而学院地点和学院电话依赖于学院id，存在传递依赖，不符合第三范式。</p>
<p>可以把学生关系表分为如下两个表：学生：(student_no, student_name, age, academy_id)；学院：(academy_id, academy_telephone)。</p>
<p><strong>2NF和3NF的区别？</strong></p>
<ul>
<li>2NF依据是非主键列是否完全依赖于主键，还是依赖于主键的一部分。</li>
<li>3NF依据是非主键列是直接依赖于主键，还是直接依赖于非主键。</li>
</ul>
<h2 id="事务隔离级别有哪些？"><a href="#事务隔离级别有哪些？" class="headerlink" title="事务隔离级别有哪些？"></a>事务隔离级别有哪些？</h2><p>先了解下几个概念：脏读、不可重复读、幻读。</p>
<ul>
<li><strong>脏读</strong>是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</li>
<li><strong>不可重复读</strong>是指在对于数据库中的某行记录，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，另一个事务修改了数据并提交了。</li>
<li><strong>幻读</strong>是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录。对幻读的正确理解是一个事务内的读取操作的结论不能支撑之后业务的执行。假设事务要新增一条记录，主键为id，在新增之前执行了select，没有发现id为xxx的记录，但插入时出现主键冲突，这就属于幻读，读取不到记录却发现主键冲突是因为记录实际上已经被其他的事务插入了，但当前事务不可见。</li>
</ul>
<p><strong>不可重复读和脏读的区别</strong>是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p>
<p>事务隔离就是为了解决上面提到的脏读、不可重复读、幻读这几个问题。</p>
<p>MySQL数据库为我们提供的四种隔离级别：</p>
<ul>
<li><strong>Serializable</strong> (串行化)：通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。</li>
<li><strong>Repeatable read</strong> (可重复读)：MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，解决了不可重复读的问题。</li>
<li><strong>Read committed</strong> (读已提交)：一个事务只能看见已经提交事务所做的改变。可避免脏读的发生。</li>
<li><strong>Read uncommitted</strong> (读未提交)：所有事务都可以看到其他未提交事务的执行结果。</li>
</ul>
<p>查看隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@transaction_isolation;</span><br></pre></td></tr></table></figure>

<p>设置隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure>

<h2 id="生产环境数据库一般用的什么隔离级别呢？"><a href="#生产环境数据库一般用的什么隔离级别呢？" class="headerlink" title="生产环境数据库一般用的什么隔离级别呢？"></a>生产环境数据库一般用的什么隔离级别呢？</h2><p><strong>生产环境大多使用RC</strong>。为什么不是RR呢？</p>
<blockquote>
<p>可重复读(Repeatable Read)，简称为RR 读已提交(Read Commited)，简称为RC</p>
</blockquote>
<p>缘由一：在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多！ 缘由二：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行!</p>
<p>也就是说，RC的并发性高于RR。</p>
<p>并且大部分场景下，不可重复读问题是可以接受的。毕竟数据都已经提交了，读出来本身就没有太大问题！</p>
<h2 id="编码和字符集的关系"><a href="#编码和字符集的关系" class="headerlink" title="编码和字符集的关系"></a>编码和字符集的关系</h2><p>我们平时可以在编辑器上输入各种中文英文字母，但这些都是给人读的，不是给计算机读的，其实计算机真正保存和传输数据都是以<strong>二进制</strong>0101的格式进行的。</p>
<p>那么就需要有一个规则，把中文和英文字母转化为二进制。其中d对应十六进制下的64，它可以转换为01二进制的格式。于是字母和数字就这样一一对应起来了，这就是<strong>ASCII编码</strong>格式。</p>
<p>它用<strong>一个字节</strong>，也就是<code>8位</code>来标识字符，基础符号有128个，扩展符号也是128个。也就只能表示下<strong>英文字母和数字</strong>。</p>
<p>这明显不够用。于是，为了标识<strong>中文</strong>，出现了<strong>GB2312</strong>的编码格式。为了标识<strong>希腊语</strong>，出现了<strong>greek</strong>编码格式，为了标识<strong>俄语</strong>，整了<strong>cp866</strong>编码格式。</p>
<p>为了统一它们，于是出现了<strong>Unicode编码格式</strong>，它用了2~4个字节来表示字符，这样理论上所有符号都能被收录进去，并且它还完全兼容ASCII的编码，也就是说，同样是字母d，在ASCII用64表示，在Unicode里还是用64来表示。</p>
<p>但<strong>不同的地方是ASCII编码用1个字节来表示，而Unicode用则两个字节来表示。</strong></p>
<p>同样都是字母d，unicode比ascii多使用了一个字节，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D   ASCII:           01100100</span><br><span class="line">D Unicode:  00000000 01100100</span><br></pre></td></tr></table></figure>

<p>可以看到，上面的unicode编码，前面的都是0，其实用不上，但还占了个字节，有点浪费。如果我们能做到该隐藏时隐藏，这样就能省下不少空间，按这个思路，就是就有了<strong>UTF-8编码</strong>。</p>
<p>总结一下，按照一定规则把符号和二进制码对应起来，这就是<strong>编码</strong>。而把n多这种已经编码的字符聚在一起，就是我们常说的<strong>字符集</strong>。</p>
<p>比如utf-8字符集就是所有utf-8编码格式的字符的合集。</p>
<p>想看下mysql支持哪些字符集。可以执行 <code>show charset;</code></p>
<h2 id="utf8和utf8mb4的区别"><a href="#utf8和utf8mb4的区别" class="headerlink" title="utf8和utf8mb4的区别"></a>utf8和utf8mb4的区别</h2><p>上面提到utf-8是在unicode的基础上做的优化，既然unicode有办法表示所有字符，那utf-8也一样可以表示所有字符，为了避免混淆，我在后面叫它<strong>大utf8</strong>。</p>
<p>mysql支持的字符集中有utf8和utf8mb4。</p>
<p>先说<strong>utf8mb4</strong>编码，mb4就是<strong>most bytes 4</strong>的意思，从上图最右边的<code>Maxlen</code>可以看到，它最大支持用<strong>4个字节</strong>来表示字符，它几乎可以用来表示目前已知的所有的字符。</p>
<p>再说mysql字符集里的<strong>utf8</strong>，它是数据库的<strong>默认字符集</strong>。但注意，<strong>此utf8非彼utf8</strong>，我们叫它<strong>小utf8</strong>字符集。为什么这么说，因为从Maxlen可以看出，它最多支持用3个字节去表示字符，按utf8mb4的命名方式，准确点应该叫它<strong>utf8mb3</strong>。</p>
<p>utf8 就像是阉割版的utf8mb4，只支持部分字符。比如<code>emoji</code>表情，它就不支持。</p>
<p>而mysql支持的字符集里，第三列，<strong>collation</strong>，它是指<strong>字符集的比较规则</strong>。</p>
<p>比如，”debug”和”Debug”是同一个单词，但它们大小写不同，该不该判为同一个单词呢。</p>
<p>这时候就需要用到collation了。</p>
<p>通过<code>SHOW COLLATION WHERE Charset = &#39;utf8mb4&#39;;</code>可以查看到<code>utf8mb4</code>下支持什么比较规则。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/20220527084528.png" alt="img"></p>
<p>如果<code>collation = utf8mb4_general_ci</code>，是指使用utf8mb4字符集的前提下，<strong>挨个字符进行比较</strong>（<code>general</code>），并且不区分大小写（<code>_ci，case insensitice</code>）。</p>
<p>这种情况下，”debug”和”Debug”是同一个单词。</p>
<p>如果改成<code>collation=utf8mb4_bin</code>，就是指<strong>挨个比较二进制位大小</strong>。</p>
<p>于是”debug”和”Debug”就不是同一个单词。</p>
<p><strong>那utf8mb4对比utf8有什么劣势吗？</strong></p>
<p>我们知道数据库表里，字段类型如果是<code>char(2)</code>的话，里面的<code>2</code>是指<strong>字符个数</strong>，也就是说<strong>不管这张表用的是什么编码的字符集</strong>，都能放上2个字符。</p>
<p>而char又是<strong>固定长度</strong>，为了能放下2个utf8mb4的字符，char会默认保留<code>2*4（maxlen=4）= 8</code>个字节的空间。</p>
<p>如果是utf8mb3，则会默认保留 <code>2 * 3 (maxlen=3) = 6</code>个字节的空间。也就是说，在这种情况下，<strong>utf8mb4会比utf8mb3多使用一些空间。</strong></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><p>索引是存储引擎用于提高数据库表的访问速度的一种<strong>数据结构</strong>。它可以比作一本字典的目录，可以帮你快速找到对应的记录。</p>
<p>索引一般存储在磁盘的文件中，它是占用物理空间的。</p>
<h3 id="索引的优缺点？"><a href="#索引的优缺点？" class="headerlink" title="索引的优缺点？"></a>索引的优缺点？</h3><p>优点：</p>
<ul>
<li><strong>加快数据查找的速度</strong></li>
<li>为用来排序或者是分组的字段添加索引，可以加快分组和排序的速度</li>
<li>加快表与表之间的连接</li>
</ul>
<p>缺点：</p>
<ul>
<li>建立索引需要<strong>占用物理空间</strong></li>
<li>会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行<strong>动态维护索引</strong>，导致增删改时间变长</li>
</ul>
<h3 id="索引的作用？"><a href="#索引的作用？" class="headerlink" title="索引的作用？"></a>索引的作用？</h3><p>数据是存储在磁盘上的，查询数据时，如果没有索引，会加载所有的数据到内存，依次进行检索，读取磁盘次数较多。有了索引，就不需要加载所有数据，因为B+树的高度一般在2-4层，最多只需要读取2-4次磁盘，查询速度大大提升。</p>
<h3 id="什么情况下需要建索引？"><a href="#什么情况下需要建索引？" class="headerlink" title="什么情况下需要建索引？"></a>什么情况下需要建索引？</h3><ol>
<li>经常用于查询的字段</li>
<li>经常用于连接的字段建立索引，可以加快连接的速度</li>
<li>经常需要排序的字段建立索引，因为索引已经排好序，可以加快排序查询速度</li>
</ol>
<h3 id="什么情况下不建索引？"><a href="#什么情况下不建索引？" class="headerlink" title="什么情况下不建索引？"></a>什么情况下不建索引？</h3><ol>
<li><code>where</code>条件中用不到的字段不适合建立索引</li>
<li>表记录较少。比如只有几百条数据，没必要加索引。</li>
<li>需要经常增删改。需要评估是否适合加索引</li>
<li><strong>参与列计算</strong>的列不适合建索引</li>
<li><strong>区分度不高</strong>的字段不适合建立索引，如性别，只有男&#x2F;女&#x2F;未知三个值。加了索引，查询效率也不会提高。</li>
</ol>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>索引的数据结构主要有B+树和哈希表，对应的索引分别为B+树索引和哈希索引。InnoDB引擎的索引类型有B+树索引和哈希索引，默认的索引类型为B+树索引。</p>
<p><strong>B+树索引</strong></p>
<p>B+ 树是基于B 树和叶子节点顺序访问指针进行实现，它具有B树的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>
<p>在 B+ 树中，节点中的 <code>key</code> 从左到右递增排列，如果某个指针的左右相邻 <code>key</code> 分别是 keyi 和 keyi+1，则该指针指向节点的所有 <code>key</code> 大于等于 keyi 且小于等于 keyi+1。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/B+%E6%A0%91%E7%B4%A2%E5%BC%950.png" alt="img"></p>
<p>进行查找操作时，首先在根节点进行二分查找，找到<code>key</code>所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出<code>key</code>所对应的数据项。</p>
<p>MySQL 数据库使用最多的索引类型是<code>BTREE</code>索引，底层基于B+树数据结构来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show index from blog\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: blog</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: blog_id</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 4</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null:</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">      Visible: YES</span><br><span class="line">   Expression: NULL</span><br></pre></td></tr></table></figure>

<p><strong>哈希索引</strong></p>
<p>哈希索引是基于哈希表实现的，对于每一行数据，存储引擎会对索引列进行哈希计算得到哈希码，并且哈希算法要尽量保证不同的列值计算出的哈希码值是不同的，将哈希码的值作为哈希表的key值，将指向数据行的指针作为哈希表的value值。这样查找一个数据的时间复杂度就是O(1)，一般多用于精确查找。</p>
<h3 id="Hash索引和B-树索引的区别？"><a href="#Hash索引和B-树索引的区别？" class="headerlink" title="Hash索引和B+树索引的区别？"></a>Hash索引和B+树索引的区别？</h3><ul>
<li>哈希索引<strong>不支持排序</strong>，因为哈希表是无序的。</li>
<li>哈希索引<strong>不支持范围查找</strong>。</li>
<li>哈希索引<strong>不支持模糊查询</strong>及多列索引的最左前缀匹配。</li>
<li>因为哈希表中会<strong>存在哈希冲突</strong>，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点。</li>
</ul>
<h3 id="为什么B-树比B树更适合实现数据库索引？"><a href="#为什么B-树比B树更适合实现数据库索引？" class="headerlink" title="为什么B+树比B树更适合实现数据库索引？"></a>为什么B+树比B树更适合实现数据库索引？</h3><ul>
<li>由于B+树的数据都存储在叶子结点中，叶子结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，而在数据库中基于范围的查询是非常频繁的，所以通常B+树用于数据库索引。</li>
<li>B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I&#x2F;O支出。</li>
<li>B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ul>
<h3 id="索引有什么分类？"><a href="#索引有什么分类？" class="headerlink" title="索引有什么分类？"></a>索引有什么分类？</h3><p>1、<strong>主键索引</strong>：名为primary的唯一非空索引，不允许有空值。</p>
<p>2、<strong>唯一索引</strong>：索引列中的值必须是唯一的，但是允许为空值。唯一索引和主键索引的区别是：唯一索引字段可以为null且可以存在多个null值，而主键索引字段不可以为null。唯一索引的用途：唯一标识数据库表中的每条记录，主要是用来防止数据重复插入。创建唯一索引的SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">ADD CONSTRAINT constraint_name UNIQUE KEY(column_1,column_2,...);</span><br></pre></td></tr></table></figure>

<p>3、<strong>组合索引</strong>：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时需遵循最左前缀原则。</p>
<p>4、<strong>全文索引</strong>：只能在<code>CHAR</code>、<code>VARCHAR</code>和<code>TEXT</code>类型字段上使用全文索引。</p>
<p>5、<strong>普通索引</strong>：普通索引是最基本的索引，它没有任何限制，值可以为空。</p>
<h3 id="什么是最左匹配原则？"><a href="#什么是最左匹配原则？" class="headerlink" title="什么是最左匹配原则？"></a>什么是最左匹配原则？</h3><p>如果 SQL 语句中用到了组合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个组合索引去进行匹配。当遇到范围查询(<code>&gt;</code>、<code>&lt;</code>、<code>between</code>、<code>like</code>)就会停止匹配，后面的字段不会用到索引。</p>
<p>对<code>(a,b,c)</code>建立索引，查询条件使用 a&#x2F;ab&#x2F;abc 会走索引，使用 bc 不会走索引。</p>
<p>对<code>(a,b,c,d)</code>建立索引，查询条件为<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，那么a、b和c三个字段能用到索引，而d无法使用索引。因为遇到了范围查询。</p>
<p>如下图，对(a, b) 建立索引，a 在索引树中是全局有序的，而 b 是全局无序，局部有序（当a相等时，会根据b进行排序）。直接执行<code>b = 2</code>这种查询条件无法使用索引。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80.png" alt="最左前缀"></p>
<p>当a的值确定的时候，b是有序的。例如<code>a = 1</code>时，b值为1，2是有序的状态。当<code>a = 2</code>时候，b的值为1，4也是有序状态。 当执行<code>a = 1 and b = 2</code>时a和b字段能用到索引。而执行<code>a &gt; 1 and b = 2</code>时，a字段能用到索引，b字段用不到索引。因为a的值此时是一个范围，不是固定的，在这个范围内b值不是有序的，因此b字段无法使用索引。</p>
<h3 id="什么是聚集索引？"><a href="#什么是聚集索引？" class="headerlink" title="什么是聚集索引？"></a>什么是聚集索引？</h3><p>InnoDB使用表的主键构造主键索引树，同时叶子节点中存放的即为整张表的记录数据。聚集索引叶子节点的存储是逻辑上连续的，使用双向链表连接，叶子节点按照主键的顺序排序，因此对于主键的排序查找和范围查找速度比较快。</p>
<p>聚集索引的叶子节点就是整张表的行记录。InnoDB 主键使用的是聚簇索引。聚集索引要比非聚集索引查询效率高很多。</p>
<p>对于<code>InnoDB</code>来说，聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为<code>NULL</code>的唯一索引。如果没有主键也没有合适的唯一索引，那么<code>InnoDB</code>内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键长度为6个字节，它的值会随着数据的插入自增。</p>
<h3 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h3><p><code>select</code>的数据列只用从索引中就能够取得，不需要<strong>回表</strong>进行二次查询，也就是说查询列要被所使用的索引覆盖。对于<code>innodb</code>表的二级索引，如果索引能覆盖到查询的列，那么就可以避免对主键索引的二次查询。</p>
<p>不是所有类型的索引都可以成为覆盖索引。覆盖索引要存储索引列的值，而哈希索引、全文索引不存储索引列的值，所以MySQL使用b+树索引做覆盖索引。</p>
<p>对于使用了覆盖索引的查询，在查询前面使用<code>explain</code>，输出的extra列会显示为<code>using index</code>。</p>
<p>比如<code>user_like</code> 用户点赞表，组合索引为<code>(user_id, blog_id)</code>，<code>user_id</code>和<code>blog_id</code>都不为<code>null</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select blog_id from user_like where user_id = 13;</span><br></pre></td></tr></table></figure>

<p><code>explain</code>结果的<code>Extra</code>列为<code>Using index</code>，查询的列被索引覆盖，并且where筛选条件符合最左前缀原则，通过<strong>索引查找</strong>就能直接找到符合条件的数据，不需要回表查询数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select user_id from user_like where blog_id = 1;</span><br></pre></td></tr></table></figure>

<p><code>explain</code>结果的<code>Extra</code>列为<code>Using where; Using index</code>， 查询的列被索引覆盖，where筛选条件不符合最左前缀原则，无法通过索引查找找到符合条件的数据，但可以通过<strong>索引扫描</strong>找到符合条件的数据，也不需要回表查询数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/cover-index.png" alt="img"></p>
<h3 id="索引的设计原则？"><a href="#索引的设计原则？" class="headerlink" title="索引的设计原则？"></a>索引的设计原则？</h3><ul>
<li>对于经常作为查询条件的字段，应该建立索引，以提高查询速度</li>
<li>为经常需要排序、分组和联合操作的字段建立索引</li>
<li>索引列的<strong>区分度越高</strong>，索引的效果越好。比如使用性别这种区分度很低的列作为索引，效果就会很差。</li>
<li>避免给”大字段”建立索引。尽量使用数据量小的字段作为索引。因为<code>MySQL</code>在维护索引的时候是会将字段值一起维护的，那这样必然会导致索引占用更多的空间，另外在排序的时候需要花费更多的时间去对比。</li>
<li>尽量使用<strong>短索引</strong>，对于较长的字符串进行索引时应该指定一个较短的前缀长度，因为较小的索引涉及到的磁盘I&#x2F;O较少，查询速度更快。</li>
<li>索引不是越多越好，每个索引都需要额外的物理空间，维护也需要花费时间。</li>
<li>频繁增删改的字段不要建立索引。假设某个字段频繁修改，那就意味着需要频繁的重建索引，这必然影响MySQL的性能</li>
<li>利用<strong>最左前缀原则</strong>。</li>
</ul>
<h3 id="索引什么时候会失效？"><a href="#索引什么时候会失效？" class="headerlink" title="索引什么时候会失效？"></a>索引什么时候会失效？</h3><p>导致索引失效的情况：</p>
<ul>
<li>对于组合索引，不是使用组合索引最左边的字段，则不会使用索引</li>
<li>以%开头的like查询如<code>%abc</code>，无法使用索引；非%开头的like查询如<code>abc%</code>，相当于范围查询，会使用索引</li>
<li>查询条件中列类型是字符串，没有使用引号，可能会因为类型不同发生隐式转换，使索引失效</li>
<li>判断索引列是否不等于某个值时</li>
<li>对索引列进行运算</li>
<li>查询条件使用<code>or</code>连接，也会导致索引失效</li>
</ul>
<h3 id="什么是前缀索引？"><a href="#什么是前缀索引？" class="headerlink" title="什么是前缀索引？"></a>什么是前缀索引？</h3><p>有时需要在很长的字符列上创建索引，这会造成索引特别大且慢。使用前缀索引可以避免这个问题。</p>
<p>前缀索引是指对文本或者字符串的前几个字符建立索引，这样索引的长度更短，查询速度更快。</p>
<p>创建前缀索引的关键在于选择足够长的前缀以<strong>保证较高的索引选择性</strong>。索引选择性越高查询效率就越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的数据行。</p>
<p>建立前缀索引的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// email列创建前缀索引</span><br><span class="line">ALTER TABLE table_name ADD KEY(column_name(prefix_length));</span><br></pre></td></tr></table></figure>

<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><h2 id="常见的存储引擎有哪些？"><a href="#常见的存储引擎有哪些？" class="headerlink" title="常见的存储引擎有哪些？"></a>常见的存储引擎有哪些？</h2><p>MySQL中常用的四种存储引擎分别是： <strong>MyISAM</strong>、<strong>InnoDB</strong>、<strong>MEMORY</strong>、<strong>ARCHIVE</strong>。MySQL 5.5版本后默认的存储引擎为<code>InnoDB</code>。</p>
<p><strong>InnoDB存储引擎</strong></p>
<p>InnoDB是MySQL<strong>默认的事务型存储引擎</strong>，使用最广泛，基于聚簇索引建立的。InnoDB内部做了很多优化，如能够自动在内存中创建自适应hash索引，以加速读操作。</p>
<p><strong>优点</strong>：支持事务和崩溃修复能力；引入了行级锁和外键约束。</p>
<p><strong>缺点</strong>：占用的数据空间相对较大。</p>
<p><strong>适用场景</strong>：需要事务支持，并且有较高的并发读写频率。</p>
<p><strong>MyISAM存储引擎</strong></p>
<p>数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，可以使用MyISAM引擎。MyISAM会将表存储在两个文件中，数据文件<code>.MYD</code>和索引文件<code>.MYI</code>。</p>
<p><strong>优点</strong>：访问速度快。</p>
<p><strong>缺点</strong>：MyISAM不支持事务和行级锁，不支持崩溃后的安全恢复，也不支持外键。</p>
<p><strong>适用场景</strong>：对事务完整性没有要求；表的数据都会只读的。</p>
<p><strong>MEMORY存储引擎</strong></p>
<p>MEMORY引擎将数据全部放在内存中，访问速度较快，但是一旦系统奔溃的话，数据都会丢失。</p>
<p>MEMORY引擎默认使用哈希索引，将键的哈希值和指向数据行的指针保存在哈希索引中。</p>
<p><strong>优点</strong>：访问速度较快。</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>哈希索引数据不是按照索引值顺序存储，无法用于排序。</li>
<li>不支持部分索引匹配查找，因为哈希索引是使用索引列的全部内容来计算哈希值的。</li>
<li>只支持等值比较，不支持范围查询。</li>
<li>当出现哈希冲突时，存储引擎需要遍历链表中所有的行指针，逐行进行比较，直到找到符合条件的行。</li>
</ol>
<p><strong>ARCHIVE存储引擎</strong></p>
<p>ARCHIVE存储引擎非常适合存储大量独立的、作为历史记录的数据。ARCHIVE提供了压缩功能，拥有高效的插入速度，但是这种引擎不支持索引，所以查询性能较差。</p>
<h2 id="MyISAM和InnoDB的区别？"><a href="#MyISAM和InnoDB的区别？" class="headerlink" title="MyISAM和InnoDB的区别？"></a>MyISAM和InnoDB的区别？</h2><ol>
<li><strong>存储结构的区别</strong>。每个MyISAM在磁盘上存储成三个文件。文件的名字以表的名字开始，扩展名指出文件类型。 .frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。InnoDB所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</li>
<li><strong>存储空间的区别</strong>。MyISAM支持支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。当表在创建之后并导入数据之后，不会再进行修改操作，可以使用压缩表，极大的减少磁盘的空间占用。InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</li>
<li><strong>可移植性、备份及恢复</strong>。MyISAM数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。对于InnoDB，可行的方案是拷贝数据文件、备份 binlog，或者用mysqldump，在数据量达到几十G的时候就相对麻烦了。</li>
<li><strong>是否支持行级锁</strong>。MyISAM 只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。而InnoDB 支持行级锁和表级锁，默认为行级锁。行锁大幅度提高了多用户并发操作的性能。</li>
<li><strong>是否支持事务和崩溃后的安全恢复</strong>。 MyISAM 不提供事务支持。而InnoDB 提供事务支持，具有事务、回滚和崩溃修复能力。</li>
<li><strong>是否支持外键</strong>。MyISAM不支持，而InnoDB支持。</li>
<li><strong>是否支持MVCC</strong>。MyISAM不支持，InnoDB支持。应对高并发事务，MVCC比单纯的加锁更高效。</li>
<li><strong>是否支持聚集索引</strong>。MyISAM不支持聚集索引，InnoDB支持聚集索引。</li>
<li><strong>全文索引</strong>。MyISAM支持 FULLTEXT类型的全文索引。InnoDB不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。</li>
<li><strong>表主键</strong>。MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址。对于InnoDB，如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)。</li>
<li><strong>表的行数</strong>。MyISAM保存有表的总行数，如果<code>select count(*) from table</code>;会直接取出该值。InnoDB没有保存表的总行数，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了where条件后，MyISAM和InnoDB处理的方式都一样。</li>
</ol>
<h2 id="MySQL有哪些锁？"><a href="#MySQL有哪些锁？" class="headerlink" title="MySQL有哪些锁？"></a>MySQL有哪些锁？</h2><p><strong>按锁粒度分类</strong>，有行级锁、表级锁和页级锁。</p>
<ol>
<li>行级锁是mysql中锁定粒度最细的一种锁。表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销也最大。行级锁的类型主要有三类： <ul>
<li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li>
<li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li>
<li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li>
</ul>
</li>
<li>表级锁是mysql中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分mysql引擎支持。最常使用的MyISAM与InnoDB都支持表级锁定。</li>
<li>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。因此，采取了折衷的页级锁，一次锁定相邻的一组记录。</li>
</ol>
<p><strong>按锁级别分类</strong>，有共享锁、排他锁和意向锁。</p>
<ol>
<li>共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。</li>
<li>排他锁又称写锁、独占锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。</li>
<li>意向锁是表级锁，其设计目的主要是为了在一个事务中揭示下一行将要被请求锁的类型。InnoDB 中的两个表锁：</li>
</ol>
<p>意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁；</p>
<p>意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。</p>
<p>意向锁是 InnoDB 自动加的，不需要用户干预。</p>
<p>对于INSERT、UPDATE和DELETE，InnoDB 会自动给涉及的数据加排他锁；对于一般的SELECT语句，InnoDB 不会加任何锁，事务可以通过以下语句显式加共享锁或排他锁。</p>
<p>共享锁：<code>SELECT … LOCK IN SHARE MODE;</code></p>
<p>排他锁：<code>SELECT … FOR UPDATE;</code></p>
<h2 id="MVCC-实现原理？"><a href="#MVCC-实现原理？" class="headerlink" title="MVCC 实现原理？"></a>MVCC 实现原理？</h2><p>MVCC(<code>Multiversion concurrency control</code>) 就是同一份数据保留多版本的一种方式，进而实现并发控制。在查询的时候，通过<code>read view</code>和版本链找到对应版本的数据。</p>
<p>作用：提升并发性能。对于高并发场景，MVCC比行级锁开销更小。</p>
<p><strong>MVCC 实现原理如下：</strong></p>
<p>MVCC 的实现依赖于版本链，版本链是通过表的三个隐藏字段实现。</p>
<ul>
<li><code>DB_TRX_ID</code>：当前事务id，通过事务id的大小判断事务的时间顺序。</li>
<li><code>DB_ROLL_PTR</code>：回滚指针，指向当前行记录的上一个版本，通过这个指针将数据的多个版本连接在一起构成<code>undo log</code>版本链。</li>
<li><code>DB_ROW_ID</code>：主键，如果数据表没有主键，InnoDB会自动生成主键。</li>
</ul>
<p>每条表记录大概是这样的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/mvcc9.png" alt="img"></p>
<p>使用事务更新行记录的时候，就会生成版本链，执行过程如下：</p>
<ol>
<li>用排他锁锁住该行；</li>
<li>将该行原本的值拷贝到<code>undo log</code>，作为旧版本用于回滚；</li>
<li>修改当前行的值，生成一个新版本，更新事务id，使回滚指针指向旧版本的记录，这样就形成一条版本链。</li>
</ol>
<p>下面举个例子方便大家理解。</p>
<p>1、初始数据如下，其中<code>DB_ROW_ID</code>和<code>DB_ROLL_PTR</code>为空。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/mvcc2.png" alt="img"></p>
<p>2、事务A对该行数据做了修改，将<code>age</code>修改为12，效果如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/mvcc7.png" alt="img"></p>
<p>3、之后事务B也对该行记录做了修改，将<code>age</code>修改为8，效果如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/mvcc11.png" alt="img"></p>
<p>4、此时undo log有两行记录，并且通过回滚指针连在一起。</p>
<p><strong>接下来了解下read view的概念。</strong></p>
<p><code>read view</code>可以理解成将数据在每个时刻的状态拍成“照片”记录下来。在获取某时刻t的数据时，到t时间点拍的“照片”上取数据。</p>
<p>在<code>read view</code>内部维护一个活跃事务链表，表示生成<code>read view</code>的时候还在活跃的事务。这个链表包含在创建<code>read view</code>之前还未提交的事务，不包含创建<code>read view</code>之后提交的事务。</p>
<p>不同隔离级别创建read view的时机不同。</p>
<ul>
<li>read committed：每次执行select都会创建新的read_view，保证能读取到其他事务已经提交的修改。</li>
<li>repeatable read：在一个事务范围内，第一次select时更新这个read_view，以后不会再更新，后续所有的select都是复用之前的read_view。这样可以保证事务范围内每次读取的内容都一样，即可重复读。</li>
</ul>
<p><strong>read view的记录筛选方式</strong></p>
<p><strong>前提</strong>：<code>DATA_TRX_ID</code> 表示每个数据行的最新的事务ID；<code>up_limit_id</code>表示当前快照中的最先开始的事务；<code>low_limit_id</code>表示当前快照中的最慢开始的事务，即最后一个事务。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/read_view10.png" alt="img"></p>
<ul>
<li><p>如果<code>DATA_TRX_ID</code> &lt; <code>up_limit_id</code>：说明在创建<code>read view</code>时，修改该数据行的事务已提交，该版本的记录可被当前事务读取到。</p>
</li>
<li><p>如果<code>DATA_TRX_ID</code> &gt;&#x3D; <code>low_limit_id</code>：说明当前版本的记录的事务是在创建<code>read view</code>之后生成的，该版本的数据行不可以被当前事务访问。此时需要通过版本链找到上一个版本，然后重新判断该版本的记录对当前事务的可见性。</p>
</li>
<li><p>如果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">up_limit_id</span><br></pre></td></tr></table></figure>

<p> &lt;&#x3D; </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATA_TRX_ID</span><br></pre></td></tr></table></figure>

<p> &lt; </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">low_limit_i</span><br></pre></td></tr></table></figure>

<p>： </p>
<ol>
<li>需要在活跃事务链表中查找是否存在ID为<code>DATA_TRX_ID</code>的值的事务。</li>
<li>如果存在，因为在活跃事务链表中的事务是未提交的，所以该记录是不可见的。此时需要通过版本链找到上一个版本，然后重新判断该版本的可见性。</li>
<li>如果不存在，说明事务trx_id 已经提交了，这行记录是可见的。</li>
</ol>
</li>
</ul>
<p><strong>总结</strong>：InnoDB 的<code>MVCC</code>是通过 <code>read view</code> 和版本链实现的，版本链保存有历史版本记录，通过<code>read view</code> 判断当前版本的数据是否可见，如果不可见，再从版本链中找到上一个版本，继续进行判断，直到找到一个可见的版本。</p>
<h2 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h2><p>表记录有两种读取方式。</p>
<ul>
<li>快照读：读取的是快照版本。普通的<code>SELECT</code>就是快照读。通过mvcc来进行并发控制的，不用加锁。</li>
<li>当前读：读取的是最新版本。<code>UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE</code>是当前读。</li>
</ul>
<p>快照读情况下，InnoDB通过<code>mvcc</code>机制避免了幻读现象。而<code>mvcc</code>机制无法避免当前读情况下出现的幻读现象。因为当前读每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。</p>
<p>下面举个例子说明下：</p>
<p>1、首先，user表只有两条记录，具体如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/image-20210922232259664.png" alt="img"></p>
<p>2、事务a和事务b同时开启事务<code>start transaction</code>；</p>
<p>3、事务a插入数据然后提交；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into user(user_name, user_password, user_mail, user_state) values(&#x27;tyson&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, 0);</span><br></pre></td></tr></table></figure>

<p>4、事务b执行全表的update；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set user_name = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>

<p>5、事务b然后执行查询，查到了事务a中插入的数据。（下图左边是事务b，右边是事务a。事务开始之前只有两条记录，事务a插入一条数据之后，事务b查询出来是三条数据）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E5%B9%BB%E8%AF%BB1.png" alt="img"></p>
<p>以上就是当前读出现的幻读现象。</p>
<p><strong>那么MySQL是如何避免幻读？</strong></p>
<ul>
<li>在快照读情况下，MySQL通过<code>mvcc</code>来避免幻读。</li>
<li>在当前读情况下，MySQL通过<code>next-key</code>来避免幻读（加行锁和间隙锁来实现的）。</li>
</ul>
<p>next-key包括两部分：行锁和间隙锁。行锁是加在索引上的锁，间隙锁是加在索引之间的。</p>
<p><code>Serializable</code>隔离级别也可以避免幻读，会锁住整张表，并发性极低，一般不会使用。</p>
<h2 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h2><p>SELECT 的读取锁定主要分为两种方式：共享锁和排他锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from table where id&lt;6 lock in share mode;--共享锁</span><br><span class="line">select * from table where id&lt;6 for update;--排他锁</span><br></pre></td></tr></table></figure>

<p>这两种方式主要的不同在于<code>LOCK IN SHARE MODE </code>多个事务同时更新同一个表单时很容易造成死锁。</p>
<p>申请排他锁的前提是，没有线程对该结果集的任何行数据使用排它锁或者共享锁，否则申请会受到阻塞。在进行事务操作时，MySQL会对查询结果集的每行数据添加排它锁，其他线程对这些数据的更改或删除操作会被阻塞（只能读操作），直到该语句的事务被<code>commit</code>语句或<code>rollback</code>语句结束为止。</p>
<p><code>SELECT... FOR UPDATE</code> 使用注意事项：</p>
<ol>
<li><code>for update</code> 仅适用于innodb，且必须在事务范围内才能生效。</li>
<li>根据主键进行查询，查询条件为<code>like</code>或者不等于，主键字段产生<strong>表锁</strong>。</li>
<li>根据非索引字段进行查询，会产生<strong>表锁</strong>。</li>
</ol>
<h2 id="bin-log-redo-log-undo-log"><a href="#bin-log-redo-log-undo-log" class="headerlink" title="bin log&#x2F;redo log&#x2F;undo log"></a>bin log&#x2F;redo log&#x2F;undo log</h2><p>MySQL日志主要包括查询日志、慢查询日志、事务日志、错误日志、二进制日志等。其中比较重要的是 <code>bin log</code>（二进制日志）和 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）。</p>
<p><strong>bin log</strong></p>
<p><code>bin log</code>是MySQL数据库级别的文件，记录对MySQL数据库执行修改的所有操作，不会记录select和show语句，主要用于恢复数据库和同步数据库。</p>
<p><strong>redo log</strong></p>
<p><code>redo log</code>是innodb引擎级别，用来记录innodb存储引擎的事务日志，不管事务是否提交都会记录下来，用于数据恢复。当数据库发生故障，innoDB存储引擎会使用<code>redo log</code>恢复到发生故障前的时刻，以此来保证数据的完整性。将参数<code>innodb_flush_log_at_tx_commit</code>设置为1，那么在执行commit时会将<code>redo log</code>同步写到磁盘。</p>
<p><strong>undo log</strong></p>
<p>除了记录<code>redo log</code>外，当进行数据修改时还会记录<code>undo log</code>，<code>undo log</code>用于数据的撤回操作，它保留了记录修改前的内容。通过<code>undo log</code>可以实现事务回滚，并且可以根据<code>undo log</code>回溯到某个特定的版本的数据，<strong>实现MVCC</strong>。</p>
<h2 id="bin-log和redo-log有什么区别？"><a href="#bin-log和redo-log有什么区别？" class="headerlink" title="bin log和redo log有什么区别？"></a>bin log和redo log有什么区别？</h2><ol>
<li><code>bin log</code>会记录所有日志记录，包括InnoDB、MyISAM等存储引擎的日志；<code>redo log</code>只记录innoDB自身的事务日志。</li>
<li><code>bin log</code>只在事务提交前写入到磁盘，一个事务只写一次；而在事务进行过程，会有<code>redo log</code>不断写入磁盘。</li>
<li><code>bin log</code>是逻辑日志，记录的是SQL语句的原始逻辑；<code>redo log</code>是物理日志，记录的是在某个数据页上做了什么修改。</li>
</ol>
<h2 id="讲一下MySQL架构？"><a href="#讲一下MySQL架构？" class="headerlink" title="讲一下MySQL架构？"></a>讲一下MySQL架构？</h2><p>MySQL主要分为 Server 层和存储引擎层：</p>
<ul>
<li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li>
<li><strong>存储引擎</strong>： 主要负责数据的存储和读取。server 层通过api与存储引擎进行通信。</li>
</ul>
<p><strong>Server 层基本组件</strong></p>
<ul>
<li><strong>连接器：</strong> 当客户端连接 MySQL 时，server层会对其进行身份认证和权限校验。</li>
<li><strong>查询缓存:</strong> 执行查询语句的时候，会先查询缓存，先校验这个 sql 是否执行过，如果有缓存这个 sql，就会直接返回给客户端，如果没有命中，就会执行后续的操作。</li>
<li><strong>分析器:</strong> 没有命中缓存的话，SQL 语句就会经过分析器，主要分为两步，词法分析和语法分析，先看 SQL 语句要做什么，再检查 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong> 优化器对查询进行优化，包括重写查询、决定表的读写顺序以及选择合适的索引等，生成执行计划。</li>
<li><strong>执行器：</strong> 首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会根据执行计划去调用引擎的接口，返回结果。</li>
</ul>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>当单表的数据量达到1000W或100G以后，优化索引、添加从库等可能对数据库性能提升效果不明显，此时就要考虑对其进行切分了。切分的目的就在于减少数据库的负担，缩短查询的时间。</p>
<p>数据切分可以分为两种方式：垂直划分和水平划分。</p>
<p><strong>垂直划分</strong></p>
<p>垂直划分数据库是根据业务进行划分，例如购物场景，可以将库中涉及商品、订单、用户的表分别划分出成一个库，通过降低单库的大小来提高性能。同样的，分表的情况就是将一个大表根据业务功能拆分成一个个子表，例如商品基本信息和商品描述，商品基本信息一般会展示在商品列表，商品描述在商品详情页，可以将商品基本信息和商品描述拆分成两张表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E5%9E%82%E7%9B%B4%E5%88%92%E5%88%86.png" alt="img"></p>
<p><strong>优点</strong>：行记录变小，数据页可以存放更多记录，在查询时减少I&#x2F;O次数。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>主键出现冗余，需要管理冗余列；</li>
<li>会引起表连接JOIN操作，可以通过在业务服务器上进行join来减少数据库压力；</li>
<li>依然存在单表数据量过大的问题。</li>
</ul>
<p><strong>水平划分</strong></p>
<p>水平划分是根据一定规则，例如时间或id序列值等进行数据的拆分。比如根据年份来拆分不同的数据库。每个数据库结构一致，但是数据得以拆分，从而提升性能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E6%B0%B4%E5%B9%B3%E5%88%92%E5%88%86.png" alt="img"></p>
<p><strong>优点</strong>：单库（表）的数据量得以减少，提高性能；切分出的表结构相同，程序改动较少。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>分片事务一致性难以解决</li>
<li>跨节点<code>join</code>性能差，逻辑复杂</li>
<li>数据分片在扩容时需要迁移</li>
</ul>
<h2 id="什么是分区表？"><a href="#什么是分区表？" class="headerlink" title="什么是分区表？"></a>什么是分区表？</h2><p>分区是把一张表的数据分成N多个区块。分区表是一个独立的逻辑表，但是底层由多个物理子表组成。</p>
<p>当查询条件的数据分布在某一个分区的时候，查询引擎只会去某一个分区查询，而不是遍历整个表。在管理层面，如果需要删除某一个分区的数据，只需要删除对应的分区即可。</p>
<p>分区一般都是放在单机里的，用的比较多的是时间范围分区，方便归档。只不过分库分表需要代码实现，分区则是mysql内部实现。分库分表和分区并不冲突，可以结合使用。</p>
<h2 id="分区表类型"><a href="#分区表类型" class="headerlink" title="分区表类型"></a>分区表类型</h2><p><strong>range分区</strong>，按照范围分区。比如按照时间范围分区</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="title function_">test_range_partition</span><span class="params">(</span></span><br><span class="line"><span class="params">       id INT auto_increment,</span></span><br><span class="line"><span class="params">       createdate DATETIME,</span></span><br><span class="line"><span class="params">       primary key (id,createdate)</span></span><br><span class="line">   ) </span><br><span class="line">   PARTITION BY <span class="title function_">RANGE</span> <span class="params">(TO_DAYS(createdate)</span> ) (</span><br><span class="line">      PARTITION p201801 VALUES LESS <span class="title function_">THAN</span> <span class="params">( TO_DAYS(<span class="string">&#x27;20180201&#x27;</span>)</span> ),</span><br><span class="line">      PARTITION p201802 VALUES LESS <span class="title function_">THAN</span> <span class="params">( TO_DAYS(<span class="string">&#x27;20180301&#x27;</span>)</span> ),</span><br><span class="line">      PARTITION p201803 VALUES LESS <span class="title function_">THAN</span> <span class="params">( TO_DAYS(<span class="string">&#x27;20180401&#x27;</span>)</span> ),</span><br><span class="line">      PARTITION p201804 VALUES LESS <span class="title function_">THAN</span> <span class="params">( TO_DAYS(<span class="string">&#x27;20180501&#x27;</span>)</span> ),</span><br><span class="line">      PARTITION p201805 VALUES LESS <span class="title function_">THAN</span> <span class="params">( TO_DAYS(<span class="string">&#x27;20180601&#x27;</span>)</span> ),</span><br><span class="line">      PARTITION p201806 VALUES LESS <span class="title function_">THAN</span> <span class="params">( TO_DAYS(<span class="string">&#x27;20180701&#x27;</span>)</span> ),</span><br><span class="line">      PARTITION p201807 VALUES LESS <span class="title function_">THAN</span> <span class="params">( TO_DAYS(<span class="string">&#x27;20180801&#x27;</span>)</span> ),</span><br><span class="line">      PARTITION p201808 VALUES LESS <span class="title function_">THAN</span> <span class="params">( TO_DAYS(<span class="string">&#x27;20180901&#x27;</span>)</span> ),</span><br><span class="line">      PARTITION p201809 VALUES LESS <span class="title function_">THAN</span> <span class="params">( TO_DAYS(<span class="string">&#x27;20181001&#x27;</span>)</span> ),</span><br><span class="line">      PARTITION p201810 VALUES LESS <span class="title function_">THAN</span> <span class="params">( TO_DAYS(<span class="string">&#x27;20181101&#x27;</span>)</span> ),</span><br><span class="line">      PARTITION p201811 VALUES LESS <span class="title function_">THAN</span> <span class="params">( TO_DAYS(<span class="string">&#x27;20181201&#x27;</span>)</span> ),</span><br><span class="line">      PARTITION p201812 VALUES LESS <span class="title function_">THAN</span> <span class="params">( TO_DAYS(<span class="string">&#x27;20190101&#x27;</span>)</span> )</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>

<p>在<code>/var/lib/mysql/data/</code>可以找到对应的数据文件，每个分区表都有一个使用#分隔命名的表文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   -rw-r----- <span class="number">1</span> MySQL MySQL    <span class="number">65</span> Mar <span class="number">14</span> <span class="number">21</span>:<span class="number">47</span> db.opt</span><br><span class="line">   -rw-r----- <span class="number">1</span> MySQL MySQL  <span class="number">8598</span> Mar <span class="number">14</span> <span class="number">21</span>:<span class="number">50</span> test_range_partition.frm</span><br><span class="line">   -rw-r----- <span class="number">1</span> MySQL MySQL <span class="number">98304</span> Mar <span class="number">14</span> <span class="number">21</span>:<span class="number">50</span> test_range_partition#P#p201801.ibd</span><br><span class="line">   -rw-r----- <span class="number">1</span> MySQL MySQL <span class="number">98304</span> Mar <span class="number">14</span> <span class="number">21</span>:<span class="number">50</span> test_range_partition#P#p201802.ibd</span><br><span class="line">   -rw-r----- <span class="number">1</span> MySQL MySQL <span class="number">98304</span> Mar <span class="number">14</span> <span class="number">21</span>:<span class="number">50</span> test_range_partition#P#p201803.ibd</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>list分区</strong></p>
<p>list分区和range分区相似，主要区别在于list是枚举值列表的集合，range是连续的区间值的集合。对于list分区，分区字段必须是已知的，如果插入的字段不在分区时的枚举值中，将无法插入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table <span class="title function_">test_list_partiotion</span></span><br><span class="line">   <span class="params">(</span></span><br><span class="line"><span class="params">       id <span class="type">int</span> auto_increment,</span></span><br><span class="line"><span class="params">       data_type tinyint,</span></span><br><span class="line"><span class="params">       primary key(id,data_type)</span></span><br><span class="line">   )partition by <span class="title function_">list</span><span class="params">(data_type)</span></span><br><span class="line">   (</span><br><span class="line">       partition p0 values <span class="title function_">in</span> <span class="params">(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span>,</span><br><span class="line">       partition p1 values <span class="title function_">in</span> <span class="params">(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>)</span>,</span><br><span class="line">       partition p2 values <span class="title function_">in</span> <span class="params">(<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>)</span></span><br><span class="line">   );</span><br></pre></td></tr></table></figure>

<p><strong>hash分区</strong></p>
<p>可以将数据均匀地分布到预先定义的分区中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table <span class="title function_">test_hash_partiotion</span></span><br><span class="line">   <span class="params">(</span></span><br><span class="line"><span class="params">       id <span class="type">int</span> auto_increment,</span></span><br><span class="line"><span class="params">       create_date datetime,</span></span><br><span class="line"><span class="params">       primary key(id,create_date)</span></span><br><span class="line">   )partition by <span class="title function_">hash</span><span class="params">(year(create_date)</span>) partitions <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="分区的问题？"><a href="#分区的问题？" class="headerlink" title="分区的问题？"></a>分区的问题？</h2><ol>
<li>打开和锁住所有底层表的成本可能很高。当查询访问分区表时，MySQL 需要打开并锁住所有的底层表，这个操作在分区过滤之前发生，所以无法通过分区过滤来降低此开销，会影响到查询速度。可以通过批量操作来降低此类开销，比如批量插入、<code>LOAD DATA INFILE</code>和一次删除多行数据。</li>
<li>维护分区的成本可能很高。例如重组分区，会先创建一个临时分区，然后将数据复制到其中，最后再删除原分区。</li>
<li>所有分区必须使用相同的存储引擎。</li>
</ol>
<h2 id="查询语句执行流程？"><a href="#查询语句执行流程？" class="headerlink" title="查询语句执行流程？"></a>查询语句执行流程？</h2><p>查询语句的执行流程如下：权限校验、查询缓存、分析器、优化器、权限校验、执行器、引擎。</p>
<p>举个例子，查询语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id &gt; 1 and name = &#x27;茶白&#x27;;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先检查权限，没有权限则返回错误；</li>
<li>MySQL8.0以前会查询缓存，缓存命中则直接返回，没有则执行下一步；</li>
<li>词法分析和语法分析。提取表名、查询条件，检查语法是否有错误；</li>
<li>两种执行方案，先查 <code>id &gt; 1</code> 还是 <code>name = &#39;茶白&#39;</code>，优化器根据自己的优化算法选择执行效率最好的方案；</li>
<li>校验权限，有权限就调用数据库引擎接口，返回引擎的执行结果。</li>
</ol>
<h2 id="更新语句执行过程？"><a href="#更新语句执行过程？" class="headerlink" title="更新语句执行过程？"></a>更新语句执行过程？</h2><p>更新语句执行流程如下：分析器、权限校验、执行器、引擎、<code>redo log</code>（<code>prepare</code>状态）、<code>binlog</code>、<code>redo log</code>（<code>commit</code>状态）</p>
<p>举个例子，更新语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set name = &#x27;茶白&#x27; where id = 1;</span><br></pre></td></tr></table></figure>

<ol>
<li>先查询到 id 为1的记录，有缓存会使用缓存。</li>
<li>拿到查询结果，将 name 更新为茶白，然后调用引擎接口，写入更新数据，innodb 引擎将数据保存在内存中，同时记录<code>redo log</code>，此时<code>redo log</code>进入 <code>prepare</code>状态。</li>
<li>执行器收到通知后记录<code>binlog</code>，然后调用引擎接口，提交<code>redo log</code>为<code>commit</code>状态。</li>
<li>更新完成。</li>
</ol>
<p>为什么记录完<code>redo log</code>，不直接提交，而是先进入<code>prepare</code>状态？</p>
<p>假设先写<code>redo log</code>直接提交，然后写<code>binlog</code>，写完<code>redo log</code>后，机器挂了，<code>binlog</code>日志没有被写入，那么机器重启后，这台机器会通过<code>redo log</code>恢复数据，但是这个时候<code>binlog</code>并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</p>
<h2 id="exist和in的区别？"><a href="#exist和in的区别？" class="headerlink" title="exist和in的区别？"></a>exist和in的区别？</h2><p><code>exists</code>用于对外表记录做筛选。<code>exists</code>会遍历外表，将外查询表的每一行，代入内查询进行判断。当<code>exists</code>里的条件语句能够返回记录行时，条件就为真，返回外表当前记录。反之如果<code>exists</code>里的条件语句不能返回记录行，条件为假，则外表当前记录被丢弃。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a.* from A awhere exists(select 1 from B b where a.id=b.id)</span><br></pre></td></tr></table></figure>

<p><code>in</code>是先把后边的语句查出来放到临时表中，然后遍历临时表，将临时表的每一行，代入外查询去查找。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from Awhere id in(select id from B)</span><br></pre></td></tr></table></figure>

<p><strong>子查询的表比较大的时候</strong>，使用<code>exists</code>可以有效减少总的循环次数来提升速度；<strong>当外查询的表比较大的时候</strong>，使用<code>in</code>可以有效减少对外查询表循环遍历来提升速度。</p>
<h2 id="MySQL中int-10-和char-10-的区别？"><a href="#MySQL中int-10-和char-10-的区别？" class="headerlink" title="MySQL中int(10)和char(10)的区别？"></a>MySQL中int(10)和char(10)的区别？</h2><p>int(10)中的10表示的是显示数据的长度，而char(10)表示的是存储数据的长度。</p>
<h2 id="truncate、delete与drop区别？"><a href="#truncate、delete与drop区别？" class="headerlink" title="truncate、delete与drop区别？"></a>truncate、delete与drop区别？</h2><p><strong>相同点：</strong></p>
<ol>
<li><code>truncate</code>和不带<code>where</code>子句的<code>delete</code>、以及<code>drop</code>都会删除表内的数据。</li>
<li><code>drop</code>、<code>truncate</code>都是<code>DDL</code>语句（数据定义语言），执行后会自动提交。</li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li>truncate 和 delete 只删除数据不删除表的结构；drop 语句将删除表的结构被依赖的约束、触发器、索引；</li>
<li>一般来说，执行速度: drop &gt; truncate &gt; delete。</li>
</ol>
<h2 id="having和where区别？"><a href="#having和where区别？" class="headerlink" title="having和where区别？"></a>having和where区别？</h2><ul>
<li>二者作用的对象不同，<code>where</code>子句作用于表和视图，<code>having</code>作用于组。</li>
<li><code>where</code>在数据分组前进行过滤，<code>having</code>在数据分组后进行过滤。</li>
</ul>
<h2 id="什么是MySQL主从同步？"><a href="#什么是MySQL主从同步？" class="headerlink" title="什么是MySQL主从同步？"></a>什么是MySQL主从同步？</h2><p>主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（<code>master</code>），其余的服务器充当从服务器（<code>slave</code>）。</p>
<p>因为复制是异步进行的，所以从服务器不需要一直连接着主服务器，从服务器甚至可以通过拨号断断续续地连接主服务器。通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的某个表。</p>
<h2 id="为什么要做主从同步？"><a href="#为什么要做主从同步？" class="headerlink" title="为什么要做主从同步？"></a>为什么要做主从同步？</h2><ol>
<li>读写分离，使数据库能支撑更大的并发。</li>
<li>在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能。</li>
<li>数据备份，保证数据的安全。</li>
</ol>
<h2 id="乐观锁和悲观锁是什么？"><a href="#乐观锁和悲观锁是什么？" class="headerlink" title="乐观锁和悲观锁是什么？"></a>乐观锁和悲观锁是什么？</h2><p>数据库中的并发控制是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观锁和悲观锁是并发控制主要采用的技术手段。</p>
<ul>
<li>悲观锁：假定会发生并发冲突，会对操作的数据进行加锁，直到提交事务，才会释放锁，其他事务才能进行修改。实现方式：使用数据库中的锁机制。</li>
<li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否数据是否被修改过。给表增加<code>version</code>字段，在修改提交之前检查<code>version</code>与原来取到的<code>version</code>值是否相等，若相等，表示数据没有被修改，可以更新，否则，数据为脏数据，不能更新。实现方式：乐观锁一般使用版本号机制或<code>CAS</code>算法实现。</li>
</ul>
<h2 id="用过processlist吗？"><a href="#用过processlist吗？" class="headerlink" title="用过processlist吗？"></a>用过processlist吗？</h2><p><code>show processlist</code> 或 <code>show full processlist</code> 可以查看当前 MySQL 是否有压力，正在运行的<code>SQL</code>，有没有慢<code>SQL</code>正在执行。返回参数如下：</p>
<ol>
<li><p><strong>id</strong>：线程ID，可以用<code>kill id</code>杀死某个线程</p>
</li>
<li><p><strong>db</strong>：数据库名称</p>
</li>
<li><p><strong>user</strong>：数据库用户</p>
</li>
<li><p><strong>host</strong>：数据库实例的IP</p>
</li>
<li><p><strong>command</strong>：当前执行的命令，比如<code>Sleep</code>，<code>Query</code>，<code>Connect </code>等</p>
</li>
<li><p><strong>time</strong>：消耗时间，单位秒</p>
</li>
<li><p>state</p>
<p>：执行状态，主要有以下状态： </p>
<ul>
<li>Sleep，线程正在等待客户端发送新的请求</li>
<li>Locked，线程正在等待锁</li>
<li>Sending data，正在处理<code>SELECT</code>查询的记录，同时把结果发送给客户端</li>
<li>Kill，正在执行<code>kill</code>语句，杀死指定线程</li>
<li>Connect，一个从节点连上了主节点</li>
<li>Quit，线程正在退出</li>
<li>Sorting for group，正在为<code>GROUP BY</code>做排序</li>
<li>Sorting for order，正在为<code>ORDER BY</code>做排序</li>
</ul>
</li>
<li><p><strong>info</strong>：正在执行的<code>SQL</code>语句</p>
</li>
</ol>
<h2 id="MySQL查询-limit-1000-10-和limit-10-速度一样快吗？"><a href="#MySQL查询-limit-1000-10-和limit-10-速度一样快吗？" class="headerlink" title="MySQL查询 limit 1000,10 和limit 10 速度一样快吗？"></a>MySQL查询 limit 1000,10 和limit 10 速度一样快吗？</h2><p>两种查询方式。对应 <code>limit offset, size</code> 和 <code>limit size</code> 两种方式。</p>
<p>而其实 <code>limit size</code> ，相当于 <code>limit 0, size</code>。也就是从0开始取size条数据。</p>
<p>也就是说，两种方式的<strong>区别在于offset是否为0。</strong></p>
<p>先来看下limit sql的内部执行逻辑。</p>
<p>MySQL内部分为<strong>server层</strong>和<strong>存储引擎层</strong>。一般情况下存储引擎都用innodb。</p>
<p>server层有很多模块，其中需要关注的是<strong>执行器</strong>是用于跟存储引擎打交道的组件。</p>
<p>执行器可以通过调用存储引擎提供的接口，将一行行数据取出，当这些数据完全符合要求（比如满足其他where条件），则会放到<strong>结果集</strong>中，最后返回给调用mysql的<strong>客户端</strong>。</p>
<p>以主键索引的limit执行过程为例：</p>
<p>执行<code>select * from xxx order by id limit 0, 10;</code>，select后面带的是<strong>星号</strong>，也就是要求获得行数据的<strong>所有字段信息。</strong></p>
<p>server层会调用innodb的接口，在innodb里的主键索引中获取到第0到10条<strong>完整行数据</strong>，依次返回给server层，并放到server层的结果集中，返回给客户端。</p>
<p>把offset搞大点，比如执行的是：<code>select * from xxx order by id limit 500000, 10;</code></p>
<p>server层会调用innodb的接口，由于这次的offset&#x3D;500000，会在innodb里的主键索引中获取到第0到（500000 + 10）条<strong>完整行数据</strong>，<strong>返回给server层之后根据offset的值挨个抛弃，最后只留下最后面的size条</strong>，也就是10条数据，放到server层的结果集中，返回给客户端。</p>
<p>可以看出，当offset非0时，server层会从引擎层获取到<strong>很多无用的数据</strong>，而获取的这些无用数据都是要耗时的。</p>
<p>因此，mysql查询中 limit 1000,10 会比 limit 10 更慢。原因是 limit 1000,10 会取出1000+10条数据，并抛弃前1000条，这部分耗时更大。</p>
<h2 id="深分页怎么优化？"><a href="#深分页怎么优化？" class="headerlink" title="深分页怎么优化？"></a>深分页怎么优化？</h2><p>还是以上面的SQL为空：<code>select * from xxx order by id limit 500000, 10;</code></p>
<p><strong>方法一</strong>：</p>
<p>从上面的分析可以看出，当offset非常大时，server层会从引擎层获取到很多无用的数据，而当select后面是*号时，就需要拷贝完整的行信息，<strong>拷贝完整数据</strong>相比<strong>只拷贝行数据里的其中一两个列字段</strong>更耗费时间。</p>
<p>因为前面的offset条数据最后都是不要的，没有必要拷贝完整字段，所以可以将sql语句修改成：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from xxx  where id &gt;=(select id from xxx order by id limit 500000, 1) order by id limit 10;</span><br></pre></td></tr></table></figure>

<p>先执行子查询 <code>select id from xxx by id limit 500000, 1</code>, 这个操作，其实也是将在innodb中的主键索引中获取到<code>500000+1</code>条数据，然后server层会抛弃前500000条，只保留最后一条数据的id。</p>
<p>但不同的地方在于，在返回server层的过程中，只会拷贝数据行内的id这一列，而不会拷贝数据行的所有列，当数据量较大时，这部分的耗时还是比较明显的。</p>
<p>在拿到了上面的id之后，假设这个id正好等于500000，那sql就变成了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from xxx  where id &gt;=500000 order by id limit 10;</span><br></pre></td></tr></table></figure>

<p>这样innodb再走一次<strong>主键索引</strong>，通过B+树快速定位到id&#x3D;500000的行数据，时间复杂度是lg(n)，然后向后取10条数据。</p>
<p><strong>方法二：</strong></p>
<p>将所有的数据<strong>根据id主键进行排序</strong>，然后分批次取，将当前批次的最大id作为下次筛选的条件进行查询。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from xxx where id &gt; start_id order by id limit 10;</span><br></pre></td></tr></table></figure>

<p>通过主键索引，每次定位到start_id的位置，然后往后遍历10个数据，这样不管数据多大，查询性能都较为稳定。</p>
<h2 id="高度为3的B-树，可以存放多少数据？"><a href="#高度为3的B-树，可以存放多少数据？" class="headerlink" title="高度为3的B+树，可以存放多少数据？"></a>高度为3的B+树，可以存放多少数据？</h2><p>InnoDB存储引擎有自己的最小储存单元——页（Page）。</p>
<p>查询InnoDB页大小的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &#x27;innodb_page_size&#x27;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Innodb_page_size | 16384 |</span><br><span class="line">+------------------+-------+</span><br></pre></td></tr></table></figure>

<p>可以看出 innodb 默认的一页大小为 16384B &#x3D; 16384&#x2F;1024 &#x3D; 16kb。</p>
<p>在MySQL中，B+树一个节点的大小设为一页或页的倍数最为合适。因为如果一个节点的大小 &lt; 1页，那么读取这个节点的时候其实读取的还是一页，这样就造成了资源的浪费。</p>
<p>B+树中<strong>非叶子节点存的是key + 指针</strong>；<strong>叶子节点存的是数据行</strong>。</p>
<p>对于叶子节点，如果一行数据大小为1k，那么一页就能存16条数据。</p>
<p>对于非叶子节点，如果key使用的是bigint，则为8字节，指针在MySQL中为6字节，一共是14字节，则16k能存放 16 * 1024 &#x2F; 14 &#x3D; 1170 个索引指针。</p>
<p>于是可以算出，对于一颗高度为2的B+树，根节点存储索引指针节点，那么它有1170个叶子节点存储数据，每个叶子节点可以存储16条数据，一共 1170 x 16 &#x3D; 18720 条数据。而对于高度为3的B+树，就可以存放 1170 x 1170 x 16 &#x3D; 21902400 条数据（<strong>两千多万条数据</strong>），也就是对于两千多万条的数据，我们只需要<strong>高度为3</strong>的B+树就可以完成，通过主键查询只需要3次IO操作就能查到对应数据。</p>
<p>所以在 InnoDB 中B+树高度一般为3层时，就能满足千万级的数据存储。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/leefreeman/p/8315844.html">https://www.cnblogs.com/leefreeman/p/8315844.htmlopen in new window</a></p>
<h2 id="MySQL单表多大进行分库分表？"><a href="#MySQL单表多大进行分库分表？" class="headerlink" title="MySQL单表多大进行分库分表？"></a>MySQL单表多大进行分库分表？</h2><p>目前主流的有两种说法：</p>
<ol>
<li>MySQL 单表数据量大于 2000 万行，性能会明显下降，考虑进行分库分表。</li>
<li>阿里巴巴《Java 开发手册》提出单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</li>
</ol>
<p>事实上，这个数值和实际记录的条数无关，而与 MySQL 的配置以及机器的硬件有关。因为MySQL为了提高性能，会将表的索引装载到内存中。在InnoDB buffer size 足够的情况下，其能完成全加载进内存，查询不会有问题。但是，当单表数据库到达某个量级的上限时，导致内存无法存储其索引，使得之后的 SQL 查询会产生磁盘 IO，从而导致性能下降。当然，这个还有具体的表结构的设计有关，最终导致的问题都是内存限制。</p>
<p>因此，对于分库分表，需要结合实际需求，不宜过度设计，在项目一开始不采用分库与分表设计，而是随着业务的增长，在无法继续优化的情况下，再考虑分库与分表提高系统的性能。对此，阿里巴巴《Java 开发手册》补充到：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p>
<p>至于MySQL单表多大进行分库分表，应当根据机器资源进行评估。</p>
<h2 id="大表查询慢怎么优化？"><a href="#大表查询慢怎么优化？" class="headerlink" title="大表查询慢怎么优化？"></a>大表查询慢怎么优化？</h2><p>某个表有近千万数据，查询比较慢，如何优化？</p>
<p>当MySQL单表记录数过大时，数据库的性能会明显下降，一些常见的优化措施如下：</p>
<ul>
<li>合理建立索引。在合适的字段上建立索引，例如在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描</li>
<li>索引优化，SQL优化。索引要符合最左匹配原则等，参考：<a target="_blank" rel="noopener" href="https://topjavaer.cn/database/mysql.html#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95">https://topjavaer.cn/database/mysql.html#什么是覆盖索引open in new window</a></li>
<li>建立分区。对关键字段建立水平分区，比如时间字段，若查询条件往往通过时间范围来进行查询，能提升不少性能</li>
<li>利用缓存。利用Redis等缓存热点数据，提高查询效率</li>
<li>限定数据的范围。比如：用户在查询历史信息的时候，可以控制在一个月的时间范围内</li>
<li>读写分离。经典的数据库拆分方案，主库负责写，从库负责读</li>
<li>通过分库分表的方式进行优化，主要有垂直拆分和水平拆分</li>
<li>数据异构到es</li>
<li>冷热数据分离。几个月之前不常用的数据放到冷库中，最新的数据比较新的数据放到热库中</li>
<li>升级数据库类型，换一种能兼容MySQL的数据库（OceanBase、TiDB等）</li>
</ul>
<h2 id="说说count-1-、count-和count-字段名-的区别"><a href="#说说count-1-、count-和count-字段名-的区别" class="headerlink" title="说说count(1)、count(*)和count(字段名)的区别"></a>说说count(1)、count(*)和count(字段名)的区别</h2><p>嗯，先说说count(1) and count(字段名)的区别。</p>
<p>两者的主要区别是</p>
<ol>
<li>count(1) 会统计表中的所有的记录数，包含字段为null 的记录。</li>
<li>count(字段名) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。</li>
</ol>
<p>接下来看看三者之间的区别。</p>
<p>执行效果上：</p>
<ul>
<li>count(<em>)包括了所有的列，相当于行数，在统计结果的时候，*<em>不会忽略列值为NULL</em></em></li>
<li>count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，<strong>不会忽略列值为NULL</strong></li>
<li>count(字段名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，<strong>即某个字段值为NULL时，不统计</strong>。</li>
</ul>
<p>执行效率上：</p>
<ul>
<li>列名为主键，count(字段名)会比count(1)快</li>
<li>列名不为主键，count(1)会比count(列名)快</li>
<li>如果表多个列并且没有主键，则 count(1) 的执行效率优于 count(*)</li>
<li>如果有主键，则 select count(主键)的执行效率是最优的</li>
<li>如果表只有一个字段，则 select count(*)最优。</li>
</ul>
<h2 id="MySQL中DATETIME-和-TIMESTAMP有什么区别？"><a href="#MySQL中DATETIME-和-TIMESTAMP有什么区别？" class="headerlink" title="MySQL中DATETIME 和 TIMESTAMP有什么区别？"></a>MySQL中DATETIME 和 TIMESTAMP有什么区别？</h2><p>嗯，<code>TIMESTAMP</code>和<code>DATETIME</code>都可以用来存储时间，它们主要有以下区别：</p>
<p>1.表示范围</p>
<ul>
<li>DATETIME：1000-01-01 00:00:00.000000 到 9999-12-31 23:59:59.999999</li>
<li>TIMESTAMP：’1970-01-01 00:00:01.000000’ UTC 到 ‘2038-01-09 03:14:07.999999’ UTC</li>
</ul>
<p><code>TIMESTAMP</code>支持的时间范围比<code>DATATIME</code>要小，容易出现超出的情况。</p>
<p>2.空间占用</p>
<ul>
<li>TIMESTAMP ：占 4 个字节</li>
<li>DATETIME：在 MySQL 5.6.4 之前，占 8 个字节 ，之后版本，占 5 个字节</li>
</ul>
<p>3.存入时间是否会自动转换</p>
<p><code>TIMESTAMP</code>类型在默认情况下，insert、update 数据时，<code>TIMESTAMP</code>列会自动以当前时间（<code>CURRENT_TIMESTAMP</code>）填充&#x2F;更新。<code>DATETIME</code>则不会做任何转换，也不会检测时区，你给什么数据，它存什么数据。</p>
<p>4.<code>TIMESTAMP</code>比较受时区timezone的影响以及MYSQL版本和服务器的SQL MODE的影响。因为<code>TIMESTAMP</code>存的是时间戳，在不同的时区得出的时间不一致。</p>
<p>5.如果存进NULL，两者实际存储的值不同。</p>
<ul>
<li>TIMESTAMP：会自动存储当前时间 now() 。</li>
<li>DATETIME：不会自动存储当前时间，会直接存入 NULL 值。</li>
</ul>
<h2 id="说说为什么不建议用外键？"><a href="#说说为什么不建议用外键？" class="headerlink" title="说说为什么不建议用外键？"></a>说说为什么不建议用外键？</h2><p>外键是一种约束，这个约束的存在，会保证表间数据的关系始终完整。外键的存在，并非全然没有优点。</p>
<p>外键可以保证数据的完整性和一致性，级联操作方便。而且使用外键可以将数据完整性判断托付给了数据库完成，减少了程序的代码量。</p>
<p>虽然外键能够保证数据的完整性，但是会给系统带来很多缺陷。</p>
<p>1、并发问题。在使用外键的情况下，每次修改数据都需要去另外一个表检查数据，需要获取额外的锁。若是在高并发大流量事务场景，使用外键更容易造成死锁。</p>
<p>2、扩展性问题。比如从<code>MySQL</code>迁移到<code>Oracle</code>，外键依赖于数据库本身的特性，做迁移可能不方便。</p>
<p>3、不利于分库分表。在水平拆分和分库的情况下，外键是无法生效的。将数据间关系的维护，放入应用程序中，为将来的分库分表省去很多的麻烦。</p>
<h2 id="使用自增主键有什么好处？"><a href="#使用自增主键有什么好处？" class="headerlink" title="使用自增主键有什么好处？"></a>使用自增主键有什么好处？</h2><p>自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑，在查询的时候，效率也就更高。</p>
<h2 id="自增主键保存在什么地方？"><a href="#自增主键保存在什么地方？" class="headerlink" title="自增主键保存在什么地方？"></a>自增主键保存在什么地方？</h2><p>不同的引擎对于自增值的保存策略不同：</p>
<ul>
<li>MyISAM引擎的自增值保存在数据文件中。</li>
<li>在MySQL8.0以前，InnoDB引擎的自增值是存在内存中。MySQL重启之后内存中的这个值就丢失了，每次重启后第一次打开表的时候，会找自增值的最大值max(id)，然后将最大值加1作为这个表的自增值；MySQL8.0版本会将自增值的变更记录在redo log中，重启时依靠redo log恢复。</li>
</ul>
<h2 id="自增主键一定是连续的吗？"><a href="#自增主键一定是连续的吗？" class="headerlink" title="自增主键一定是连续的吗？"></a>自增主键一定是连续的吗？</h2><p>不一定，有几种情况会导致自增主键不连续。</p>
<p>1、唯一键冲突导致自增主键不连续。当我们向一个自增主键的InnoDB表中插入数据的时候，如果违反表中定义的唯一索引的唯一约束，会导致插入数据失败。此时表的自增主键的键值是会向后加1滚动的。下次再次插入数据的时候，就不能再使用上次因插入数据失败而滚动生成的键值了，必须使用新滚动生成的键值。</p>
<p>2、事务回滚导致自增主键不连续。当我们向一个自增主键的InnoDB表中插入数据的时候，如果显式开启了事务，然后因为某种原因最后回滚了事务，此时表的自增值也会发生滚动，而接下里新插入的数据，也将不能使用滚动过的自增值，而是需要重新申请一个新的自增值。</p>
<p>3、批量插入导致自增值不连续。MySQL有一个批量申请自增id的策略：</p>
<ul>
<li>语句执行过程中，第一次申请自增id，分配1个自增id</li>
<li>1个用完以后，第二次申请，会分配2个自增id</li>
<li>2个用完以后，第三次申请，会分配4个自增id</li>
<li>依次类推，每次申请都是上一次的两倍（最后一次申请不一定全部使用）</li>
</ul>
<p>如果下一个事务再次插入数据的时候，则会基于上一个事务申请后的自增值基础上再申请。此时就出现自增值不连续的情况出现。</p>
<p>4、自增步长不是1，也会导致自增主键不连续。</p>
<h2 id="InnoDB的自增值为什么不能回收利用？"><a href="#InnoDB的自增值为什么不能回收利用？" class="headerlink" title="InnoDB的自增值为什么不能回收利用？"></a>InnoDB的自增值为什么不能回收利用？</h2><p>主要为了提升插入数据的效率和并行度。</p>
<p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请。</p>
<p>假设事务 A 申请到了 id&#x3D;2， 事务 B 申请到 id&#x3D;3，那么这时候表 t 的自增值是 4，之后继续执行。</p>
<p>事务 B 正确提交了，但事务 A 出现了唯一键冲突。</p>
<p>如果允许事务 A 把自增 id 回退，也就是把表 t 的当前自增值改回 2，那么就会出现这样的情况：表里面已经有 id&#x3D;3 的行，而当前的自增 id 值是 2。</p>
<p>接下来，继续执行的其他事务就会申请到 id&#x3D;2，然后再申请到 id&#x3D;3。这时，就会出现插入语句报错“主键冲突”。</p>
<p>而为了解决这个主键冲突，有两种方法：</p>
<ul>
<li>每次申请 id 之前，先判断表里面是否已经存在这个 id。如果存在，就跳过这个 id。但是，这个方法的成本很高。因为，本来申请 id 是一个很快的操作，现在还要再去主键索引树上判断 id 是否存在。</li>
<li>把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</li>
</ul>
<p>可见，这两个方法都会导致性能问题。</p>
<p>因此，InnoDB 放弃了“允许自增 id 回退”这个设计，语句执行失败也不回退自增 id。</p>
<h2 id="MySQL数据如何同步到Redis缓存？"><a href="#MySQL数据如何同步到Redis缓存？" class="headerlink" title="MySQL数据如何同步到Redis缓存？"></a>MySQL数据如何同步到Redis缓存？</h2><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1805755">https://cloud.tencent.com/developer/article/1805755open in new window</a></p>
</blockquote>
<p>有两种方案：</p>
<p>1、通过MySQL自动同步刷新Redis，<strong>MySQL触发器+UDF函数</strong>实现。</p>
<p>过程大致如下：</p>
<ol>
<li>在MySQL中对要操作的数据设置触发器Trigger，监听操作</li>
<li>客户端向MySQL中写入数据时，触发器会被触发，触发之后调用MySQL的UDF函数</li>
<li>UDF函数可以把数据写入到Redis中，从而达到同步的效果</li>
</ol>
<p>2、<strong>解析MySQL的binlog</strong>，实现将数据库中的数据同步到Redis。可以通过canal实现。canal是阿里巴巴旗下的一款开源项目，基于数据库增量日志解析，提供增量数据订阅&amp;消费。</p>
<p>canal的原理如下：</p>
<ol>
<li>canal模拟mysql slave的交互协议，伪装自己为mysql slave，向mysql master发送dump协议</li>
<li>mysql master收到dump请求，开始推送binary log给canal</li>
<li>canal解析binary log对象（原始为byte流），将数据同步写入Redis。</li>
</ol>
<h2 id="为什么阿里Java手册禁止使用存储过程？"><a href="#为什么阿里Java手册禁止使用存储过程？" class="headerlink" title="为什么阿里Java手册禁止使用存储过程？"></a>为什么阿里Java手册禁止使用存储过程？</h2><p>先看看什么是存储过程。</p>
<p>存储过程是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。</p>
<p>存储过程主要有以下几个缺点。</p>
<ol>
<li><strong>存储过程难以调试</strong>。存储过程的开发一直缺少有效的 IDE 环境。SQL 本身经常很长，调试式要把句子拆开分别独立执行，非常麻烦。</li>
<li><strong>移植性差</strong>。存储过程的移植困难，一般业务系统总会不可避免地用到数据库独有的特性和语法，更换数据库时这部分代码就需要重写，成本较高。</li>
<li><strong>管理困难</strong>。存储过程的目录是扁平的，而不是文件系统那样的树形结构，脚本少的时候还好办，一旦多起来，目录就会陷入混乱。</li>
<li>存储过程是<strong>只优化一次</strong>，有的时候随着数据量的增加或者数据结构的变化，原来存储过程选择的执行计划也许并不是最优的了，所以这个时候需要手动干预或者重新编译了。</li>
</ol>
<h2 id="MySQL-update-是锁行还是锁表？"><a href="#MySQL-update-是锁行还是锁表？" class="headerlink" title="MySQL update 是锁行还是锁表？"></a>MySQL update 是锁行还是锁表？</h2><p>首先，InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。</p>
<ol>
<li>当执行update语句时，where中的过滤条件列，如果用到索引，就是锁行；如果无法用索引，就是锁表。</li>
<li>如果两个update语句同时执行，第一个先执行触发行锁，但是第二个没有索引触发表锁，因为有个行锁住了，所以还是会等待行锁释放，才能锁表。</li>
<li>当执行insert或者delete语句时，锁行。</li>
</ol>
<h2 id="select…for-update会锁表还是锁行？"><a href="#select…for-update会锁表还是锁行？" class="headerlink" title="select…for update会锁表还是锁行？"></a>select…for update会锁表还是锁行？</h2><p>如果查询条件用了索引&#x2F;主键，那么<code>select ... for update</code>就会加行锁。</p>
<p>如果是普通字段(没有索引&#x2F;主键)，那么<code>select ..... for update</code>就会加表锁。</p>
<h2 id="MySQL的binlog有几种格式？分别有什么区别？"><a href="#MySQL的binlog有几种格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有几种格式？分别有什么区别？"></a>MySQL的binlog有几种格式？分别有什么区别？</h2><p>有三种格式，statement，row和mixed。</p>
<ul>
<li>statement：每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>
<li>row：不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li>
<li>mixed：一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li>
</ul>
<h2 id="阿里手册为什么禁止使用-count-列名-或-count-常量-来替代-count"><a href="#阿里手册为什么禁止使用-count-列名-或-count-常量-来替代-count" class="headerlink" title="阿里手册为什么禁止使用 count(列名)或 count(常量)来替代 count(*)"></a>阿里手册为什么禁止使用 count(列名)或 count(常量)来替代 count(*)</h2><p>先看下这几种方式的区别。</p>
<p>count(主键id)：InnoDB引擎会遍历整张表，把每一行id值都取出来，返给server层。server层拿到id后，判断是不可能为空的，就按行累加，不再对每个值进行NULL判断。</p>
<p>count(常量)：InnoDB引擎会遍历整张表，但不取值。server层对于返回的每一行，放一个常量进去，判断是不可能为空的，按行累加，不再对每个值进行NULL判断。count(常量)比count(主键id)执行的要快，因为从引擎放回id会涉及解析数据行，以及拷贝字段值的操作。</p>
<p>count(字段)：全表扫描，分情况讨论。</p>
<p>1、如果参数字段定义NOT NULL，判断是不可能为空的，按行累加，不再对每个值进行NULL判断。 2、如果参数字段定义允许为NULL，那么执行的时候，判断可能是NULL，还要把值取出来再判断一下，不是NULL才累加。</p>
<p>count(*)：统计所有的列，相当于行数，统计结果中会包含字段值为null的列；</p>
<p>COUNT(<code>*</code>)是SQL92定义的标准统计行数的语法，效率高，MySQL对它进行了很多优化，MyISAM中会直接把表的总行数单独记录下来供COUNT(*)查询，而InnoDB则会在扫表的时候选择最小的索引来降低成本。</p>
<p>所以，建议使用COUNT(*)查询表的行数！</p>
<h2 id="存储MD5值应该用VARCHAR还是用CHAR？"><a href="#存储MD5值应该用VARCHAR还是用CHAR？" class="headerlink" title="存储MD5值应该用VARCHAR还是用CHAR？"></a>存储MD5值应该用VARCHAR还是用CHAR？</h2><p>首先说说CHAR和VARCHAR的区别：</p>
<p>1、存储长度：</p>
<p>CHAR类型的长度是固定的</p>
<p>当我们当定义CHAR(10)，输入的值是”abc”，但是它占用的空间一样是10个字节，会包含7个空字节。当输入的字符长度超过指定的数时，CHAR会截取超出的字符。而且，当存储为CHAR的时候，MySQL会自动删除输入字符串末尾的空格。</p>
<p>VARCHAR的长度是可变的</p>
<p>比如VARCHAR(10)，然后输入abc三个字符，那么实际存储大小为3个字节。</p>
<p>除此之外，VARCHAR还会保留1个或2个额外的字节来记录字符串的实际长度。如果定义的最大长度小于等于255个字节，那么，就会预留1个字节；如果定义的最大长度大于255个字节，那么就会预留2个字节。</p>
<p>2、存储效率</p>
<p>CHAR类型每次修改后的数据长度不变，效率更高。</p>
<p>VARCHAR每次修改的数据要更新数据长度，效率更低。</p>
<p>3、存储空间</p>
<p>CHAR存储空间是初始的预计长度字符串再加上一个记录字符串长度的字节，可能会存在多余的空间。</p>
<p>VARCHAR存储空间的时候是实际字符串再加上一个记录字符串长度的字节，占用空间较小。</p>
<p>根据以上的分析，由于MD5是一个定长的值，所以MD5值适合使用CHAR存储。对于固定长度的非常短的列，CHAR比VARCHAR效率也更高。</p>
<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h2><p>Redis（<code>Remote Dictionary Server</code>）是一个使用 C 语言编写的，高性能非关系型的键值对数据库。与传统数据库不同的是，Redis 的数据是存在内存中的，所以读写速度非常快，被广泛应用于缓存方向。Redis可以将数据写入磁盘中，保证了数据的安全不丢失，而且Redis的操作是原子性的。</p>
<h2 id="Redis优缺点？"><a href="#Redis优缺点？" class="headerlink" title="Redis优缺点？"></a>Redis优缺点？</h2><p><strong>优点</strong>：</p>
<ol>
<li><strong>基于内存操作</strong>，内存读写速度快。</li>
<li><strong>支持多种数据类型</strong>，包括String、Hash、List、Set、ZSet等。</li>
<li><strong>支持持久化</strong>。Redis支持RDB和AOF两种持久化机制，持久化功能可以有效地避免数据丢失问题。</li>
<li><strong>支持事务</strong>。Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li>
<li><strong>支持主从复制</strong>。主节点会自动将数据同步到从节点，可以进行读写分离。</li>
<li>Redis命令的处理是<strong>单线程</strong>的。Redis6.0引入了多线程，需要注意的是，<strong>多线程用于处理网络数据的读写和协议解析</strong>，Redis命令执行还是单线程的。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>对结构化查询的支持比较差。</li>
<li>数据库容量受到物理内存的限制，不适合用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的操作。</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li>
</ol>
<h2 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h2><ul>
<li><strong>基于内存</strong>：Redis是使用内存存储，没有磁盘IO上的开销。数据存在内存中，读写速度快。</li>
<li><strong>IO多路复用模型</strong>：Redis 采用 IO 多路复用技术。Redis 使用单线程来轮询描述符，将数据库的操作都转换成了事件，不在网络I&#x2F;O上浪费过多的时间。</li>
<li><strong>高效的数据结构</strong>：Redis 每种数据类型底层都做了优化，目的就是为了追求更快的速度。</li>
</ul>
<h2 id="既然Redis那么快，为什么不用它做主数据库，只用它做缓存？"><a href="#既然Redis那么快，为什么不用它做主数据库，只用它做缓存？" class="headerlink" title="既然Redis那么快，为什么不用它做主数据库，只用它做缓存？"></a>既然Redis那么快，为什么不用它做主数据库，只用它做缓存？</h2><p>虽然Redis非常快，但它也有一些局限性，不能完全替代主数据库。有以下原因：</p>
<p><strong>事务处理：</strong>Redis只支持简单的事务处理，对于复杂的事务无能为力，比如跨多个键的事务处理。</p>
<p><strong>数据持久化：</strong>Redis是内存数据库，数据存储在内存中，如果服务器崩溃或断电，数据可能丢失。虽然Redis提供了数据持久化机制，但有一些限制。</p>
<p><strong>数据处理：</strong>Redis只支持一些简单的数据结构，比如字符串、列表、哈希表等。如果需要处理复杂的数据结构，比如关系型数据库中的表，那么Redis可能不是一个好的选择。</p>
<p><strong>数据安全：</strong>Redis没有提供像主数据库那样的安全机制，比如用户认证、访问控制等等。</p>
<p>因此，虽然Redis非常快，但它还有一些限制，不能完全替代主数据库。所以，使用Redis作为缓存是一种很好的方式，可以提高应用程序的性能，并减少数据库的负载。</p>
<h2 id="讲讲Redis的线程模型？"><a href="#讲讲Redis的线程模型？" class="headerlink" title="讲讲Redis的线程模型？"></a>讲讲Redis的线程模型？</h2><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</p>
<ul>
<li>文件事件处理器使用I&#x2F;O多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接accept、read、write、close等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行， 但通过使用 I&#x2F;O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。</p>
<h2 id="Redis应用场景有哪些？"><a href="#Redis应用场景有哪些？" class="headerlink" title="Redis应用场景有哪些？"></a>Redis应用场景有哪些？</h2><ol>
<li><strong>缓存热点数据</strong>，缓解数据库的压力。</li>
<li>利用 Redis 原子性的自增操作，可以实现<strong>计数器</strong>的功能，比如统计用户点赞数、用户访问数等。</li>
<li><strong>分布式锁</strong>。在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</li>
<li><strong>简单的消息队列</strong>，可以使用Redis自身的发布&#x2F;订阅模式或者List来实现简单的消息队列，实现异步操作。</li>
<li><strong>限速器</strong>，可用于限制某个用户访问某个接口的频率，比如秒杀场景用于防止用户快速点击带来不必要的压力。</li>
<li><strong>好友关系</strong>，利用集合的一些命令，比如交集、并集、差集等，实现共同好友、共同爱好之类的功能。</li>
</ol>
<h2 id="Memcached和Redis的区别？"><a href="#Memcached和Redis的区别？" class="headerlink" title="Memcached和Redis的区别？"></a>Memcached和Redis的区别？</h2><ol>
<li>MemCached 数据结构单一，仅用来缓存数据，而 <strong>Redis 支持多种数据类型</strong>。</li>
<li>MemCached 不支持数据持久化，重启后数据会消失。<strong>Redis 支持数据持久化</strong>。</li>
<li><strong>Redis 提供主从同步机制和 cluster 集群部署能力</strong>，能够提供高可用服务。Memcached 没有提供原生的集群模式，需要依靠客户端实现往集群中分片写入数据。</li>
<li>Redis 的速度比 Memcached 快很多。</li>
<li>Redis 使用<strong>单线程的多路 IO 复用模型</strong>，Memcached使用多线程的非阻塞 IO 模型。（Redis6.0引入了多线程IO，<strong>用来处理网络数据的读写和协议解析</strong>，但是命令的执行仍然是单线程）</li>
<li>value 值大小不同：Redis 最大可以达到 512M；memcache 只有 1mb。</li>
</ol>
<h2 id="为什么要用-Redis-而不用-map-guava-做缓存"><a href="#为什么要用-Redis-而不用-map-guava-做缓存" class="headerlink" title="为什么要用 Redis 而不用 map&#x2F;guava 做缓存?"></a>为什么要用 Redis 而不用 map&#x2F;guava 做缓存?</h2><p>使用自带的 map 或者 guava 实现的是<strong>本地缓存</strong>，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p>使用 redis 或 memcached 之类的称为<strong>分布式缓存</strong>，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。</p>
<h2 id="Redis-数据类型有哪些？"><a href="#Redis-数据类型有哪些？" class="headerlink" title="Redis 数据类型有哪些？"></a>Redis 数据类型有哪些？</h2><p><strong>基本数据类型</strong>：</p>
<p>1、<strong>String</strong>：最常用的一种数据类型，String类型的值可以是字符串、数字或者二进制，但值最大不能超过512MB。</p>
<p>2、<strong>Hash</strong>：Hash 是一个键值对集合。</p>
<p>3、<strong>Set</strong>：无序去重的集合。Set 提供了交集、并集等方法，对于实现共同好友、共同关注等功能特别方便。</p>
<p>4、<strong>List</strong>：有序可重复的集合，底层是依赖双向链表实现的。</p>
<p>5、<strong>SortedSet</strong>：有序Set。内部维护了一个<code>score</code>的参数来实现。适用于排行榜和带权重的消息队列等场景。</p>
<p><strong>特殊的数据类型</strong>：</p>
<p>1、<strong>Bitmap</strong>：位图，可以认为是一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在 Bitmap 中叫做偏移量。Bitmap的长度与集合中元素个数无关，而是与基数的上限有关。</p>
<p>2、<strong>Hyperloglog</strong>。HyperLogLog 是用来做基数统计的算法，其优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。典型的使用场景是统计独立访客。</p>
<p>3、<strong>Geospatial</strong> ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如定位、附近的人等。</p>
<h2 id="SortedSet和List异同点？"><a href="#SortedSet和List异同点？" class="headerlink" title="SortedSet和List异同点？"></a>SortedSet和List异同点？</h2><p><strong>相同点</strong>：</p>
<ol>
<li>都是有序的；</li>
<li>都可以获得某个范围内的元素。</li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li>列表基于链表实现，获取两端元素速度快，访问中间元素速度慢；</li>
<li>有序集合基于散列表和跳跃表实现，访问中间元素时间复杂度是OlogN；</li>
<li>列表不能简单的调整某个元素的位置，有序列表可以（更改元素的分数）；</li>
<li>有序集合更耗内存。</li>
</ol>
<h2 id="Redis的内存用完了会怎样？"><a href="#Redis的内存用完了会怎样？" class="headerlink" title="Redis的内存用完了会怎样？"></a>Redis的内存用完了会怎样？</h2><p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回）。</p>
<p>也可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
<h2 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h2><p>可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面。</p>
<h2 id="keys命令存在的问题？"><a href="#keys命令存在的问题？" class="headerlink" title="keys命令存在的问题？"></a>keys命令存在的问题？</h2><p>redis的单线程的。keys指令会导致线程阻塞一段时间，直到执行完毕，服务才能恢复。scan采用渐进式遍历的方式来解决keys命令可能带来的阻塞问题，每次scan命令的时间复杂度是<code>O(1)</code>，但是要真正实现keys的功能，需要执行多次scan。</p>
<p>scan的缺点：在scan的过程中如果有键的变化（增加、删除、修改），遍历过程可能会有以下问题：新增的键可能没有遍历到，遍历出了重复的键等情况，也就是说scan并不能保证完整的遍历出来所有的键。</p>
<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>事务的原理是将一个事务范围内的若干命令发送给Redis，然后再让Redis依次执行这些命令。</p>
<p>事务的生命周期：</p>
<ol>
<li>使用MULTI开启一个事务</li>
<li>在开启事务的时候，每次操作的命令将会被插入到一个队列中，同时这个命令并不会被真的执行</li>
<li>EXEC命令进行提交事务</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/redis-multi.jpg" alt="img"></p>
<p>一个事务范围内某个命令出错不会影响其他命令的执行，不保证原子性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set a <span class="number">1</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set b <span class="number">1</span> <span class="number">2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set c <span class="number">3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exec</span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) (error) ERR syntax error</span><br><span class="line"><span class="number">3</span>) OK</span><br></pre></td></tr></table></figure>

<p><strong>WATCH命令</strong></p>
<p><code>WATCH</code>命令可以监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行（类似于乐观锁）。执行<code>EXEC</code>命令之后，就会自动取消监控。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; watch name</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name <span class="number">1</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name <span class="number">2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set gender <span class="number">1</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exec</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get <span class="title function_">gender</span></span><br><span class="line"><span class="params">(nil)</span></span><br></pre></td></tr></table></figure>

<p>比如上面的代码中：</p>
<ol>
<li><code>watch name</code>开启了对<code>name</code>这个<code>key</code>的监控</li>
<li>修改<code>name</code>的值</li>
<li>开启事务a</li>
<li>在事务a中设置了<code>name</code>和<code>gender</code>的值</li>
<li>使用<code>EXEC</code>命令进提交事务</li>
<li>使用命令<code>get gender</code>发现不存在，即事务a没有执行</li>
</ol>
<p>使用<code>UNWATCH</code>可以取消<code>WATCH</code>命令对<code>key</code>的监控，所有监控锁将会被取消。</p>
<h2 id="Redis事务支持隔离性吗？"><a href="#Redis事务支持隔离性吗？" class="headerlink" title="Redis事务支持隔离性吗？"></a>Redis事务支持隔离性吗？</h2><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p>
<h2 id="Redis事务保证原子性吗，支持回滚吗？"><a href="#Redis事务保证原子性吗，支持回滚吗？" class="headerlink" title="Redis事务保证原子性吗，支持回滚吗？"></a>Redis事务保证原子性吗，支持回滚吗？</h2><p>Redis单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><p>持久化就是把<strong>内存的数据写到磁盘中</strong>，防止服务宕机导致内存数据丢失。</p>
<p>Redis支持两种方式的持久化，一种是<code>RDB</code>的方式，一种是<code>AOF</code>的方式。<strong>前者会根据指定的规则定时将内存中的数据存储在硬盘上</strong>，而<strong>后者在每次执行完命令后将命令记录下来</strong>。一般将两者结合使用。</p>
<p><strong>RDB方式</strong></p>
<p><code>RDB</code>是 Redis 默认的持久化方案。RDB持久化时会将内存中的数据写入到磁盘中，在指定目录下生成一个<code>dump.rdb</code>文件。Redis 重启会加载<code>dump.rdb</code>文件恢复数据。</p>
<p><code>bgsave</code>是主流的触发 RDB 持久化的方式，执行过程如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/rdb%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="img"></p>
<ul>
<li>执行<code>BGSAVE</code>命令</li>
<li>Redis 父进程判断当前<strong>是否存在正在执行的子进程</strong>，如果存在，<code>BGSAVE</code>命令直接返回。</li>
<li>父进程执行<code>fork</code>操作<strong>创建子进程</strong>，fork操作过程中父进程会阻塞。</li>
<li>父进程<code>fork</code>完成后，<strong>父进程继续接收并处理客户端的请求</strong>，而<strong>子进程开始将内存中的数据写进硬盘的临时文件</strong>；</li>
<li>当子进程写完所有数据后会<strong>用该临时文件替换旧的 RDB 文件</strong>。</li>
</ul>
<p>Redis启动时会读取RDB快照文件，将数据从硬盘载入内存。通过 RDB 方式的持久化，一旦Redis异常退出，就会丢失最近一次持久化以后更改的数据。</p>
<p>触发 RDB 持久化的方式：</p>
<ol>
<li><strong>手动触发</strong>：用户执行<code>SAVE</code>或<code>BGSAVE</code>命令。<code>SAVE</code>命令执行快照的过程会阻塞所有客户端的请求，应避免在生产环境使用此命令。<code>BGSAVE</code>命令可以在后台异步进行快照操作，快照的同时服务器还可以继续响应客户端的请求，因此需要手动执行快照时推荐使用<code>BGSAVE</code>命令。</li>
<li><strong>被动触发</strong>：<ul>
<li>根据配置规则进行自动快照，如<code>SAVE 100 10</code>，100秒内至少有10个键被修改则进行快照。</li>
<li>如果从节点执行全量复制操作，主节点会自动执行<code>BGSAVE</code>生成 RDB 文件并发送给从节点。</li>
<li>默认情况下执行<code>shutdown</code>命令时，如果没有开启 AOF 持久化功能则自动执行·BGSAVE·。</li>
</ul>
</li>
</ol>
<p><strong>优点</strong>：</p>
<ol>
<li><strong>Redis 加载 RDB 恢复数据远远快于 AOF 的方式</strong>。</li>
<li>使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，<strong>保证了 Redis 的高性能</strong>。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><strong>RDB方式数据无法做到实时持久化</strong>。因为<code>BGSAVE</code>每次运行都要执行<code>fork</code>操作创建子进程，属于重量级操作，频繁执行成本比较高。</li>
<li>RDB 文件使用特定二进制格式保存，Redis 版本升级过程中有多个格式的 RDB 版本，<strong>存在老版本 Redis 无法兼容新版 RDB 格式的问题</strong>。</li>
</ol>
<p><strong>AOF方式</strong></p>
<p>AOF（append only file）持久化：以独立日志的方式记录每次写命令，Redis重启时会重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是<strong>解决了数据持久化的实时性</strong>，AOF 是Redis持久化的主流方式。</p>
<p>默认情况下Redis没有开启AOF方式的持久化，可以通过<code>appendonly</code>参数启用：<code>appendonly yes</code>。开启AOF方式持久化后每执行一条写命令，Redis就会将该命令写进<code>aof_buf</code>缓冲区，AOF缓冲区根据对应的策略向硬盘做同步操作。</p>
<p>默认情况下系统<strong>每30秒</strong>会执行一次同步操作。为了防止缓冲区数据丢失，可以在Redis写入AOF文件后主动要求系统将缓冲区数据同步到硬盘上。可以通过<code>appendfsync</code>参数设置同步的时机。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always //每次写入aof文件都会执行同步，最安全最慢，不建议配置</span><br><span class="line">appendfsync everysec  //既保证性能也保证安全，建议配置</span><br><span class="line">appendfsync no //由操作系统决定何时进行同步操作</span><br></pre></td></tr></table></figure>

<p>接下来看一下 AOF 持久化执行流程：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/aof%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B0.png" alt="img"></p>
<ol>
<li>所有的写入命令会追加到 AOP 缓冲区中。</li>
<li>AOF 缓冲区根据对应的策略向硬盘同步。</li>
<li>随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩文件体积的目的。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。</li>
<li>当 Redis 服务器重启时，可以加载 AOF 文件进行数据恢复。</li>
</ol>
<p><strong>优点</strong>：</p>
<ol>
<li>AOF可以更好的保护数据不丢失，可以配置 AOF 每秒执行一次<code>fsync</code>操作，如果Redis进程挂掉，最多丢失1秒的数据。</li>
<li>AOF以<code>append-only</code>的模式写入，所以没有磁盘寻址的开销，写入性能非常高。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>对于同一份文件AOF文件比RDB数据快照要大。</li>
<li>数据恢复比较慢。</li>
</ol>
<h2 id="RDB和AOF如何选择？"><a href="#RDB和AOF如何选择？" class="headerlink" title="RDB和AOF如何选择？"></a>RDB和AOF如何选择？</h2><p>通常来说，应该同时使用两种持久化方案，以保证数据安全。</p>
<ul>
<li>如果数据不敏感，且可以从其他地方重新生成，可以关闭持久化。</li>
<li>如果数据比较重要，且能够承受几分钟的数据丢失，比如缓存等，只需要使用RDB即可。</li>
<li>如果是用做内存数据，要使用Redis的持久化，建议是RDB和AOF都开启。</li>
<li>如果只用AOF，优先使用everysec的配置选择，因为它在可靠性和性能之间取了一个平衡。</li>
</ul>
<p>当RDB与AOF两种方式都开启时，Redis会优先使用AOF恢复数据，因为AOF保存的文件比RDB文件更完整。</p>
<h2 id="Redis有哪些部署方案？"><a href="#Redis有哪些部署方案？" class="headerlink" title="Redis有哪些部署方案？"></a>Redis有哪些部署方案？</h2><p><strong>单机版</strong>：单机部署，单机redis能够承载的 QPS 大概就在上万到几万不等。这种部署方式很少使用。存在的问题：1、内存容量有限 2、处理能力有限 3、无法高可用。</p>
<p><strong>主从模式</strong>：一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。master 节点挂掉后，需要手动指定新的 master，可用性不高，基本不用。</p>
<p><strong>哨兵模式</strong>：主从复制存在不能自动故障转移、达不到高可用的问题。哨兵模式解决了这些问题。通过哨兵机制可以自动切换主从节点。master 节点挂掉后，哨兵进程会主动选举新的 master，可用性高，但是每个节点存储的数据是一样的，浪费内存空间。数据量不是很多，集群规模不是很大，需要自动容错容灾的时候使用。</p>
<p><strong>Redis cluster</strong>：服务端分片技术，3.0版本开始正式提供。Redis Cluster并没有使用一致性hash，而是采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。主要是针对海量数据+高并发+高可用的场景，如果是海量数据，如果你的数据量很大，那么建议就用Redis cluster，所有主节点的容量总和就是Redis cluster可缓存的数据容量。</p>
<h2 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h2><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。</p>
<p>Redis的复制功能是支持多个数据库之间的数据同步。主数据库可以进行读写操作，当主数据库的数据发生变化时会自动将数据同步到从数据库。从数据库一般是只读的，它会接收主数据库同步过来的数据。一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</p>
<p><strong>主从复制的原理？</strong></p>
<ol>
<li>当启动一个从节点时，它会发送一个 <code>PSYNC</code> 命令给主节点；</li>
<li>如果是从节点初次连接到主节点，那么会触发一次全量复制。此时主节点会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件；</li>
<li>同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， 主节点会将<code>RDB</code>文件发送给从节点，从节点会先将<code>RDB</code>文件<strong>写入本地磁盘，然后再从本地磁盘加载到内存中</strong>；</li>
<li>接着主节点会将内存中缓存的写命令发送到从节点，从节点同步这些数据；</li>
<li>如果从节点跟主节点之间网络出现故障，连接断开了，会自动重连，连接之后主节点仅会将部分缺失的数据同步给从节点。</li>
</ol>
<h2 id="哨兵Sentinel"><a href="#哨兵Sentinel" class="headerlink" title="哨兵Sentinel"></a>哨兵Sentinel</h2><p>主从复制存在不能自动故障转移、达不到高可用的问题。哨兵模式解决了这些问题。通过哨兵机制可以自动切换主从节点。</p>
<p>客户端连接Redis的时候，先连接哨兵，哨兵会告诉客户端Redis主节点的地址，然后客户端连接上Redis并进行后续的操作。当主节点宕机的时候，哨兵监测到主节点宕机，会重新推选出某个表现良好的从节点成为新的主节点，然后通过发布订阅模式通知其他的从服务器，让它们切换主机。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/sentinel.png" alt="img"></p>
<p><strong>工作原理</strong></p>
<ul>
<li>每个<code>Sentinel</code>以每秒钟一次的频率向它所知道的<code>Master</code>，<code>Slave</code>以及其他 <code>Sentinel </code>实例发送一个 <code>PING</code>命令。</li>
<li>如果一个实例距离最后一次有效回复 <code>PING</code> 命令的时间超过指定值， 则这个实例会被 <code>Sentine</code> 标记为主观下线。</li>
<li>如果一个<code>Master</code>被标记为主观下线，则正在监视这个<code>Master</code>的所有 <code>Sentinel </code>要以每秒一次的频率确认<code>Master</code>是否真正进入主观下线状态。</li>
<li>当有足够数量的 <code>Sentinel</code>（大于等于配置文件指定值）在指定的时间范围内确认<code>Master</code>的确进入了主观下线状态， 则<code>Master</code>会被标记为客观下线 。若没有足够数量的 <code>Sentinel </code>同意 <code>Master</code> 已经下线， <code>Master</code> 的客观下线状态就会被解除。 若 <code>Master</code>重新向 <code>Sentinel</code> 的 <code>PING</code> 命令返回有效回复， <code>Master</code> 的主观下线状态就会被移除。</li>
<li>哨兵节点会选举出哨兵 leader，负责故障转移的工作。</li>
<li>哨兵 leader 会推选出某个表现良好的从节点成为新的主节点，然后通知其他从节点更新主节点信息。</li>
</ul>
<h2 id="Redis-cluster"><a href="#Redis-cluster" class="headerlink" title="Redis cluster"></a>Redis cluster</h2><p>哨兵模式解决了主从复制不能自动故障转移、达不到高可用的问题，但还是存在主节点的写能力、容量受限于单机配置的问题。而cluster模式实现了Redis的分布式存储，每个节点存储不同的内容，解决主节点的写能力、容量受限于单机配置的问题。</p>
<p>Redis cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p>
<p>Redis cluster采用<strong>虚拟槽分区</strong>，所有的键根据哈希函数映射到0～16383个整数槽内，每个节点负责维护一部分槽以及槽所映射的键值数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/cluster_slots.png" alt="img"></p>
<p><strong>工作原理：</strong></p>
<ol>
<li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位</li>
<li>每份数据分片会存储在多个互为主从的多节点上</li>
<li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</li>
<li>同一分片多个节点间的数据不保持一致性</li>
<li>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点</li>
<li>扩容时时需要需要把旧节点的数据迁移一部分到新节点</li>
</ol>
<p>在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w 的端口号，比如 16379。</p>
<p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，<code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<p><strong>优点：</strong></p>
<ul>
<li>无中心架构，<strong>支持动态扩</strong>容；</li>
<li>数据按照<code>slot</code>存储分布在多个节点，节点间数据共享，<strong>可动态调整数据分布</strong>；</li>
<li><strong>高可用性</strong>。部分节点不可用时，集群仍可用。集群模式能够实现自动故障转移（failover），节点之间通过<code>gossip</code>协议交换状态信息，用投票机制完成<code>Slave</code>到<code>Master</code>的角色转换。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>不支持批量操作</strong>（pipeline）。</li>
<li>数据通过异步复制，<strong>不保证数据的强一致性</strong>。</li>
<li><strong>事务操作支持有限</strong>，只支持多<code>key</code>在同一节点上的事务操作，当多个<code>key</code>分布于不同的节点上时无法使用事务功能。</li>
<li><code>key</code>作为数据分区的最小粒度，不能将一个很大的键值对象如<code>hash</code>、<code>list</code>等映射到不同的节点。</li>
<li><strong>不支持多数据库空间</strong>，单机下的Redis可以支持到16个数据库，集群模式下只能使用1个数据库空间。</li>
<li>只能使用0号数据库。</li>
</ul>
<p><strong>哈希分区算法有哪些？</strong></p>
<p>节点取余分区。使用特定的数据，如Redis的键或用户ID，对节点数量N取余：hash（key）%N计算出哈希值，用来决定数据映射到哪一个节点上。 优点是简单性。扩容时通常采用翻倍扩容，避免数据映射全部被打乱导致全量迁移的情况。</p>
<p>一致性哈希分区。为系统中每个节点分配一个token，范围一般在0~232，这些token构成一个哈希环。数据读写执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一个大于等于该哈希值的token节点。 这种方式相比节点取余最大的好处在于加入和删除节点只影响哈希环中相邻的节点，对其他节点无影响。</p>
<p>虚拟槽分区，所有的键根据哈希函数映射到0~16383整数槽内，计算公式：slot&#x3D;CRC16（key）&amp;16383。每一个节点负责维护一部分槽以及槽所映射的键值数据。<strong>Redis Cluser采用虚拟槽分区算法。</strong></p>
<h2 id="过期键的删除策略？"><a href="#过期键的删除策略？" class="headerlink" title="过期键的删除策略？"></a>过期键的删除策略？</h2><p>1、<strong>被动删除</strong>。在访问key时，如果发现key已经过期，那么会将key删除。</p>
<p>2、<strong>主动删除</strong>。定时清理key，每次清理会依次遍历所有DB，从db随机取出20个key，如果过期就删除，如果其中有5个key过期，那么就继续对这个db进行清理，否则开始清理下一个db。</p>
<p>3、<strong>内存不够时清理</strong>。Redis有最大内存的限制，通过maxmemory参数可以设置最大内存，当使用的内存超过了设置的最大内存，就要进行内存释放， 在进行内存释放的时候，会按照配置的淘汰策略清理内存。</p>
<h2 id="内存淘汰策略有哪些？"><a href="#内存淘汰策略有哪些？" class="headerlink" title="内存淘汰策略有哪些？"></a>内存淘汰策略有哪些？</h2><p>当Redis的内存超过最大允许的内存之后，Redis 会触发内存淘汰策略，删除一些不常用的数据，以保证Redis服务器正常运行。</p>
<p><strong>Redisv4.0前提供 6 种数据淘汰策略</strong>：</p>
<ul>
<li><strong>volatile-lru</strong>：LRU（<code>Least Recently Used</code>），最近使用。利用LRU算法移除设置了过期时间的key</li>
<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，从数据集中移除最近最少使用的key</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集中任意选择数据淘汰</li>
<li><strong>allkeys-random</strong>：从数据集中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止删除数据，当内存不足以容纳新写入数据时，新写入操作会报错</li>
</ul>
<p><strong>Redisv4.0后增加以下两种</strong>：</p>
<ul>
<li><strong>volatile-lfu</strong>：LFU，Least Frequently Used，最少使用，从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。</li>
<li><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，从数据集中移除最不经常使用的key。</li>
</ul>
<p><strong>内存淘汰策略可以通过配置文件来修改</strong>，相应的配置项是<code>maxmemory-policy</code>，默认配置是<code>noeviction</code>。</p>
<h2 id="MySQL-与-Redis-如何保证数据一致性"><a href="#MySQL-与-Redis-如何保证数据一致性" class="headerlink" title="MySQL 与 Redis 如何保证数据一致性"></a>MySQL 与 Redis 如何保证数据一致性</h2><p><strong>缓存不一致是如何产生的</strong></p>
<p>如果数据一直没有变更，那么就不会出现缓存不一致的问题。</p>
<p>通常缓存不一致是发生在数据有变更的时候。 因为每次数据变更你需要同时操作数据库和缓存，而他们又属于不同的系统，无法做到同时操作成功或失败，总会有一个时间差。在并发读写的时候可能就会出现缓存不一致的问题（理论上通过分布式事务可以保证这一点，不过实际上基本上很少有人这么做）。</p>
<p>虽然没办法在数据有变更时，保证缓存和数据库强一致，但对缓存的更新还是有一定设计方法的，遵循这些设计方法，能够让这个不一致的影响时间和影响范围最小化。</p>
<p>缓存更新的设计方法大概有以下四种：</p>
<ul>
<li>先删除缓存，再更新数据库（这种方法在并发下最容易出现长时间的脏数据，不可取）</li>
<li>先更新数据库，删除缓存（Cache Aside Pattern）</li>
<li>只更新缓存，由缓存自己同步更新数据库（Read&#x2F;Write Through Pattern）</li>
<li>只更新缓存，由缓存自己异步更新数据库（Write Behind Cache Pattern）</li>
</ul>
<p><strong>先删除缓存，再更新数据库</strong></p>
<p>这种方法在并发读写的情况下容易出现缓存不一致的问题</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202304300910876.png" alt="img"></p>
<p>如上图所示，其可能的执行流程顺序为：</p>
<ul>
<li>客户端1 触发更新数据A的逻辑</li>
<li>客户端2 触发查询数据A的逻辑</li>
<li>客户端1 删除缓存中数据A</li>
<li>客户端2 查询缓存中数据A，未命中</li>
<li>客户端2 从数据库查询数据A，并更新到缓存中</li>
<li>客户端1 更新数据库中数据A</li>
</ul>
<p>可见，最后缓存中的数据A跟数据库中的数据A是不一致的，缓存中的数据A是旧的脏数据。</p>
<p>因此一般不建议使用这种方式。</p>
<p><strong>先更新数据库，再让缓存失效</strong></p>
<p>这种方法在并发读写的情况下，也可能会出现短暂缓存不一致的问题</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202304300912362.png" alt="img"></p>
<p>如上图所示，其可能执行的流程顺序为：</p>
<ul>
<li>客户端1 触发更新数据A的逻辑</li>
<li>客户端2 触发查询数据A的逻辑</li>
<li>客户端3 触发查询数据A的逻辑</li>
<li>客户端1 更新数据库中数据A</li>
<li>客户端2 查询缓存中数据A，命中返回（旧数据）</li>
<li>客户端1 让缓存中数据A失效</li>
<li>客户端3 查询缓存中数据A，未命中</li>
<li>客户端3 查询数据库中数据A，并更新到缓存中</li>
</ul>
<p>可见，最后缓存中的数据A和数据库中的数据A是一致的，理论上可能会出现一小段时间数据不一致，不过这种概率也比较低，大部分的业务也不会有太大的问题。</p>
<p><strong>只更新缓存，由缓存自己同步更新数据库（Read&#x2F;Write Through Pattern）</strong></p>
<p>这种方法相当于是业务只更新缓存，再由缓存去同步更新数据库。 一个Write Through的 例子如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202304300913692.png" alt="img"></p>
<p>如上图所示，其可能执行的流程顺序为：</p>
<ul>
<li>客户端1 触发更新数据A的逻辑</li>
<li>客户端2 触发查询数据A的逻辑</li>
<li>客户端1 更新缓存中数据A，缓存同步更新数据库中数据A，再返回结果</li>
<li>客户端2 查询缓存中数据A，命中返回</li>
</ul>
<p>Read Through 和 WriteThrough 的流程类似，只是在客户端查询数据A时，如果缓存中数据A失效了（过期或被驱逐淘汰），则缓存会同步去数据库中查询数据A，并缓存起来，再返回给客户端</p>
<p>这种方式缓存不一致的概率极低，只不过需要对缓存进行专门的改造。</p>
<p><strong>只更新缓存，由缓存自己异步更新数据库（Write Behind Cache Pattern）</strong></p>
<p>这种方式性详单于是业务只操作更新缓存，再由缓存异步去更新数据库，例如：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/202304300913082.png" alt="img"></p>
<p>如上图所示，其可能的执行流程顺序为：</p>
<ul>
<li>客户端1 触发更新数据A的逻辑</li>
<li>客户端2 触发查询数据A的逻辑</li>
<li>客户端1 更新缓存中的数据A，返回</li>
<li>客户端2 查询缓存中的数据A，命中返回</li>
<li>缓存异步更新数据A到数据库中</li>
</ul>
<p>这种方式的优势是读写的性能都非常好，基本上只要操作完内存后就返回给客户端了，但是其是非强一致性，存在丢失数据的情况。</p>
<p>如果在缓存异步将数据更新到数据库中时，缓存服务挂了，此时未更新到数据库中的数据就丢失了。</p>
<h2 id="缓存常见问题"><a href="#缓存常见问题" class="headerlink" title="缓存常见问题"></a>缓存常见问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指查询一个<strong>不存在的数据</strong>，由于缓存是不命中时被动写的，如果从DB查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到DB去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了。</p>
<p>怎么解决？</p>
<ol>
<li><strong>缓存空值</strong>，不会查数据库。</li>
<li>采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的<code>bitmap</code>中，查询不存在的数据会被这个<code>bitmap</code>拦截掉，从而避免了对<code>DB</code>的查询压力。</li>
</ol>
<p>布隆过滤器的原理：当一个元素被加入集合时，通过K个哈希函数将这个元素映射成一个位数组中的K个点，把它们置为1。查询时，将元素通过哈希函数映射之后会得到k个点，如果这些点有任何一个0，则被检元素一定不在，直接返回；如果都是1，则查询元素很可能存在，就会去查询Redis和数据库。</p>
<p>布隆过滤器一般用于在大数据量的集合中判定某元素是否存在。</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，<strong>导致缓存在某一时刻同时失效</strong>，请求全部转发到DB，DB瞬时压力过重挂掉。</p>
<p>解决方法：</p>
<ol>
<li>在原有的失效时间基础上<strong>增加一个随机值</strong>，使得过期时间分散一些。这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li>
<li><strong>加锁排队可以起到缓冲的作用</strong>，防止大量的请求同时操作数据库，但它的缺点是<strong>增加了系统的响应时间</strong>，<strong>降低了系统的吞吐量</strong>，牺牲了一部分用户体验。当缓存未查询到时，对要请求的 key 进行加锁，只允许一个线程去数据库中查，其他线程等候排队。</li>
<li>设置二级缓存。二级缓存指的是除了 Redis 本身的缓存，<strong>再设置一层缓存</strong>，当 Redis 失效之后，先去查询二级缓存。例如可以设置一个本地缓存，在 Redis 缓存失效的时候先去查询本地缓存而非查询数据库。</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿：大量的请求同时查询一个 key 时，此时这个 key 正好失效了，就会导致大量的请求都落到数据库。<strong>缓存击穿是查询缓存中失效的 key，而缓存穿透是查询不存在的 key。</strong></p>
<p>解决方法：</p>
<p>1、<strong>加互斥锁</strong>。在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，直接走缓存。可以使用Redis分布式锁实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123; <span class="comment">//缓存值过期</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">unique_key</span> <span class="operator">=</span> systemId + <span class="string">&quot;:&quot;</span> + key;</span><br><span class="line">        <span class="comment">//设置30s的超时</span></span><br><span class="line">        <span class="keyword">if</span> (redis.set(unique_key, <span class="number">1</span>, <span class="string">&#x27;NX&#x27;</span>, <span class="string">&#x27;PX&#x27;</span>, <span class="number">30000</span>) == <span class="number">1</span>) &#123;  <span class="comment">//设置成功</span></span><br><span class="line">            value = db.get(key);</span><br><span class="line">            redis.set(key, value, expire_secs);</span><br><span class="line">            redis.del(unique_key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//其他线程已经到数据库取值并回写到缓存了，可以重试获取缓存值</span></span><br><span class="line">            sleep(<span class="number">50</span>);</span><br><span class="line">            get(key);  <span class="comment">//重试</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<strong>热点数据不过期</strong>。直接将缓存设置为不过期，然后由定时任务去异步加载数据，更新缓存。这种方式适用于比较极端的场景，例如流量特别特别大的场景，使用时需要考虑业务能接受数据不一致的时间，还有就是异常情况的处理，保证缓存可以定时刷新。</p>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决方案：</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作一下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h3 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ol>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ol>
<p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<h2 id="Redis-怎么实现消息队列？"><a href="#Redis-怎么实现消息队列？" class="headerlink" title="Redis 怎么实现消息队列？"></a>Redis 怎么实现消息队列？</h2><p>使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BLPOP queue <span class="number">0</span>  <span class="comment">//0表示不限制等待时间</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>BLPOP和LPOP命令相似，唯一的区别就是当列表没有元素时BLPOP命令会一直阻塞连接，直到有新元素加入。</p>
</blockquote>
<p>redis可以通过pub&#x2F;sub<strong>主题订阅模式</strong>实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH channel1 hi</span><br><span class="line">SUBSCRIBE channel1</span><br><span class="line">UNSUBSCRIBE channel1 <span class="comment">//退订通过SUBSCRIBE命令订阅的频道。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>PSUBSCRIBE channel?*</code> 按照规则订阅。 <code>PUNSUBSCRIBE channel?*</code> 退订通过PSUBSCRIBE命令按照某种规则订阅的频道。其中订阅规则要进行严格的字符串匹配，<code>PUNSUBSCRIBE *</code>无法退订<code>channel?*</code>规则。</p>
</blockquote>
<h2 id="Redis-怎么实现延时队列"><a href="#Redis-怎么实现延时队列" class="headerlink" title="Redis 怎么实现延时队列"></a>Redis 怎么实现延时队列</h2><p>使用sortedset，拿时间戳作为score，消息内容作为key，调用zadd来生产消息，消费者用<code>zrangebyscore</code>指令获取N秒之前的数据轮询进行处理。</p>
<h2 id="pipeline的作用？"><a href="#pipeline的作用？" class="headerlink" title="pipeline的作用？"></a>pipeline的作用？</h2><p>redis客户端执行一条命令分4个过程： 发送命令、命令排队、命令执行、返回结果。使用<code>pipeline</code>可以批量请求，批量返回结果，执行速度比逐条执行要快。</p>
<p>使用<code>pipeline</code>组装的命令个数不能太多，不然数据量过大，增加客户端的等待时间，还可能造成网络阻塞，可以将大量命令的拆分多个小的<code>pipeline</code>命令完成。</p>
<p>原生批命令（mset和mget）与<code>pipeline</code>对比：</p>
<ol>
<li>原生批命令是原子性，<code>pipeline</code>是<strong>非原子性</strong>。pipeline命令中途异常退出，之前执行成功的命令<strong>不会回滚</strong>。</li>
<li>原生批命令只有一个命令，但<code>pipeline</code><strong>支持多命令</strong>。</li>
</ol>
<h2 id="LUA脚本"><a href="#LUA脚本" class="headerlink" title="LUA脚本"></a>LUA脚本</h2><p>Redis 通过 LUA 脚本创建具有原子性的命令： 当lua脚本命令正在运行的时候，不会有其他脚本或 Redis 命令被执行，实现组合命令的原子操作。</p>
<p>在Redis中执行Lua脚本有两种方法：<code>eval</code>和<code>evalsha</code>。<code>eval</code>命令使用内置的 Lua 解释器，对 Lua 脚本进行求值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数是lua脚本，第二个参数是键名参数个数，剩下的是键名参数和附加参数</span></span><br><span class="line">&gt; eval <span class="string">&quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot;</span> <span class="number">2</span> key1 key2 first second</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;key1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;key2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;first&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;second&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>lua脚本作用</strong></p>
<p>1、Lua脚本在Redis中是原子执行的，执行过程中间不会插入其他命令。</p>
<p>2、Lua脚本可以将多条命令一次性打包，有效地减少网络开销。</p>
<p><strong>应用场景</strong></p>
<p>举例：限制接口访问频率。</p>
<p>在Redis维护一个接口访问次数的键值对，<code>key</code>是接口名称，<code>value</code>是访问次数。每次访问接口时，会执行以下操作：</p>
<ul>
<li>通过<code>aop</code>拦截接口的请求，对接口请求进行计数，每次进来一个请求，相应的接口访问次数<code>count</code>加1，存入redis。</li>
<li>如果是第一次请求，则会设置<code>count=1</code>，并设置过期时间。因为这里<code>set()</code>和<code>expire()</code>组合操作不是原子操作，所以引入<code>lua</code>脚本，实现原子操作，避免并发访问问题。</li>
<li>如果给定时间范围内超过最大访问次数，则会抛出异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">buildLuaScript</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;local c&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\nc = redis.call(&#x27;get&#x27;,KEYS[1])&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\nif c and tonumber(c) &gt; tonumber(ARGV[1]) then&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\nreturn c;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\nend&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\nc = redis.call(&#x27;incr&#x27;,KEYS[1])&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\nif tonumber(c) == 1 then&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\nredis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2])&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\nend&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\nreturn c;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">luaScript</span> <span class="operator">=</span> buildLuaScript();</span><br><span class="line">RedisScript&lt;Number&gt; redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(luaScript, Number.class);</span><br><span class="line"><span class="type">Number</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.execute(redisScript, keys, limit.count(), limit.period());</span><br></pre></td></tr></table></figure>

<p>PS：这种接口限流的实现方式比较简单，问题也比较多，一般不会使用，接口限流用的比较多的是令牌桶算法和漏桶算法。</p>
<h2 id="什么是RedLock？"><a href="#什么是RedLock？" class="headerlink" title="什么是RedLock？"></a>什么是RedLock？</h2><p>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 <em>Redlock</em>，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p>
<ol>
<li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li>
<li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client 挂掉了</li>
<li>容错性：只要大部分 Redis 节点存活就可以正常提供服务</li>
</ol>
<h2 id="Redis大key怎么处理？"><a href="#Redis大key怎么处理？" class="headerlink" title="Redis大key怎么处理？"></a>Redis大key怎么处理？</h2><p>通常我们会将含有较大数据或含有大量成员、列表数的Key称之为大Key。</p>
<p>以下是对各个数据类型大key的描述：</p>
<ul>
<li>value是STRING类型，它的值超过5MB</li>
<li>value是ZSET、Hash、List、Set等集合类型时，它的成员数量超过1w个</li>
</ul>
<p>上述的定义并不绝对，主要是根据value的成员数量和大小来确定，根据业务场景确定标准。</p>
<p>怎么处理：</p>
<ol>
<li>当vaule是string时，可以使用序列化、压缩算法将key的大小控制在合理范围内，但是序列化和反序列化都会带来更多时间上的消耗。或者将key进行拆分，一个大key分为不同的部分，记录每个部分的key，使用multiget等操作实现事务读取。</li>
<li>当value是list&#x2F;set等集合类型时，根据预估的数据规模来进行分片，不同的元素计算后分到不同的片。</li>
</ol>
<h2 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h2><ol>
<li>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库</li>
<li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li>
<li>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。</li>
</ol>
<h2 id="说说为什么Redis过期了为什么内存没释放？"><a href="#说说为什么Redis过期了为什么内存没释放？" class="headerlink" title="说说为什么Redis过期了为什么内存没释放？"></a>说说为什么Redis过期了为什么内存没释放？</h2><p>第一种情况，可能是覆盖之前的key，导致key过期时间发生了改变。</p>
<p>当一个key在Redis中已经存在了，但是由于一些误操作使得key过期时间发生了改变，从而导致这个key在应该过期的时间内并没有过期，从而造成内存的占用。</p>
<p>第二种情况是，Redis过期key的处理策略导致内存没释放。</p>
<p>一般Redis对过期key的处理策略有两种：惰性删除和定时删除。</p>
<p>先说惰性删除的情况</p>
<p>当一个key已经确定设置了xx秒过期同时中间也没有修改它，xx秒之后它确实已经过期了，但是惰性删除的策略它并不会马上删除这个key，而是当再次读写这个key时它才会去检查是否过期，如果过期了就会删除这个key。也就是说，惰性删除策略下，就算key过期了，也不会立刻释放内容，要等到下一次读写这个key才会删除key。</p>
<p>而定时删除会在一定时间内主动淘汰一部分已经过期的数据，默认的时间是每100ms过期一次。因为定时删除策略每次只会淘汰一部分过期key，而不是所有的过期key，如果redis中数据比较多的话要是一次性全量删除对服务器的压力比较大，每一次只挑一批进行删除，所以很可能出现部分已经过期的key并没有及时的被清理掉，从而导致内存没有即时被释放。</p>
<h2 id="Redis突然变慢，有哪些原因？"><a href="#Redis突然变慢，有哪些原因？" class="headerlink" title="Redis突然变慢，有哪些原因？"></a>Redis突然变慢，有哪些原因？</h2><ol>
<li><p><strong>存在bigkey</strong>。如果Redis实例中存储了 bigkey，那么在淘汰删除 bigkey 释放内存时，也会耗时比较久。应该避免存储 bigkey，降低释放内存的耗时。</p>
</li>
<li><p>如果Redis 实例<strong>设置了内存上限 maxmemory</strong>，有可能导致 Redis 变慢。当 Redis 内存达到 maxmemory 后，每次写入新的数据之前，Redis 必须先从实例中踢出一部分数据，让整个实例的内存维持在 maxmemory 之下，然后才能把新数据写进来。</p>
</li>
<li><p><strong>开启了内存大页</strong>。当 Redis 在执行后台 RDB 和 AOF rewrite 时，采用 fork 子进程的方式来处理。但主进程 fork 子进程后，此时的主进程依旧是可以接收写请求的，而进来的写请求，会采用 Copy On Write（写时复制）的方式操作内存数据。</p>
<p>什么是写时复制？</p>
<p>这样做的好处是，父进程有任何写操作，并不会影响子进程的数据持久化。</p>
<p>不过，主进程在拷贝内存数据时，会涉及到新内存的申请，如果此时操作系统开启了内存大页，那么在此期间，客户端即便只修改 10B 的数据，Redis 在申请内存时也会以 2MB 为单位向操作系统申请，申请内存的耗时变长，进而导致每个写请求的延迟增加，影响到 Redis 性能。</p>
<p>解决方案就是关闭内存大页机制。</p>
</li>
<li><p><strong>使用了Swap</strong>。操作系统为了缓解内存不足对应用程序的影响，允许把一部分内存中的数据换到磁盘上，以达到应用程序对内存使用的缓冲，这些内存数据被换到磁盘上的区域，就是 Swap。当内存中的数据被换到磁盘上后，Redis 再访问这些数据时，就需要从磁盘上读取，访问磁盘的速度要比访问内存慢几百倍。尤其是针对 Redis 这种对性能要求极高、性能极其敏感的数据库来说，这个操作延时是无法接受的。解决方案就是增加机器的内存，让 Redis 有足够的内存可以使用。或者整理内存空间，释放出足够的内存供 Redis 使用</p>
</li>
<li><p><strong>网络带宽过载</strong>。网络带宽过载的情况下，服务器在 TCP 层和网络层就会出现数据包发送延迟、丢包等情况。Redis 的高性能，除了操作内存之外，就在于网络 IO 了，如果网络 IO 存在瓶颈，那么也会严重影响 Redis 的性能。解决方案：1、及时确认占满网络带宽 Redis 实例，如果属于正常的业务访问，那就需要及时扩容或迁移实例了，避免因为这个实例流量过大，影响这个机器的其他实例。2、运维层面，需要对 Redis 机器的各项指标增加监控，包括网络流量，在网络流量达到一定阈值时提前报警，及时确认和扩容。</p>
</li>
<li><p><strong>频繁短连接</strong>。频繁的短连接会导致 Redis 大量时间耗费在连接的建立和释放上，TCP 的三次握手和四次挥手同样也会增加访问延迟。应用应该使用长连接操作 Redis，避免频繁的短连接。</p>
</li>
</ol>
<h2 id="为什么-Redis-集群的最大槽数是-16384-个？"><a href="#为什么-Redis-集群的最大槽数是-16384-个？" class="headerlink" title="为什么 Redis 集群的最大槽数是 16384 个？"></a>为什么 Redis 集群的最大槽数是 16384 个？</h2><p>Redis Cluster 采用数据分片机制，定义了 16384个 Slot槽位，集群中的每个Redis 实例负责维护一部分槽以及槽所映射的键值数据。</p>
<p>Redis每个节点之间会定期发送ping&#x2F;pong消息（心跳包包含了其他节点的数据），用于交换数据信息。</p>
<p>Redis集群的节点会按照以下规则发ping消息：</p>
<ul>
<li>(1)每秒会随机选取5个节点，找出最久没有通信的节点发送ping消息</li>
<li>(2)每100毫秒都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于cluster-node-timeout&#x2F;2 则立刻发送ping消息</li>
</ul>
<p>心跳包的消息头里面有个myslots的char数组，是一个bitmap，每一个位代表一个槽，如果该位为1，表示这个槽是属于这个节点的。</p>
<p>接下来，解答为什么 Redis 集群的最大槽数是 16384 个，而不是65536 个。</p>
<p>1、如果采用 16384 个插槽，那么心跳包的消息头占用空间 2KB （16384&#x2F;8）；如果采用 65536 个插槽，那么心跳包的消息头占用空间 8KB (65536&#x2F;8)。可见采用 65536 个插槽，<strong>发送心跳信息的消息头达8k，比较浪费带宽</strong>。</p>
<p>2、一般情况下一个Redis集群<strong>不会有超过1000个master节点</strong>，太多可能导致网络拥堵。</p>
<p>3、哈希槽是通过一张bitmap的形式来保存的，在传输过程中，会对bitmap进行压缩。bitmap的填充率越低，<strong>压缩率</strong>越高。其中bitmap 填充率 &#x3D; slots &#x2F; N (N表示节点数)。所以，插槽数越低， 填充率会降低，压缩率会提高。</p>
<h2 id="Redis存在线程安全的问题吗"><a href="#Redis存在线程安全的问题吗" class="headerlink" title="Redis存在线程安全的问题吗"></a>Redis存在线程安全的问题吗</h2><p>首先从Redis 服务端层面来看。</p>
<p>Redis Server本身是一个线程安全的K-V数据库，也就是说在Redis Server上执行的指令，不需要任何同步机制，不会存在线程安全问题。</p>
<p>虽然Redis 6.0里面，增加了多线程的模型，但是增加的多线程只是用来处理网络IO事件，对于指令的执行过程，仍然是由主线程来处理，所以不会存在多个线程通知执行操作指令的情况。</p>
<p>然后从Redis客户端层面来看。</p>
<p>虽然Redis Server中的指令执行是原子的，但是如果有多个Redis客户端同时执行多个指令的时候，就无法保证原子性。</p>
<p>假设两个redis client同时获取Redis Server上的key1， 同时进行修改和写入，因为多线程环境下的原子性无法被保障，以及多进程情况下的共享资源访问的竞争问题，使得数据的安全性无法得到保障。</p>
<p>对于客户端层面的线程安全性问题，解决方法有很多，比如尽可能的使用Redis里面的原子指令，或者对多个客户端的资源访问加锁，或者通过Lua脚本来实现多个指令的操作等等。</p>
<h2 id="Redis遇到哈希冲突怎么办？"><a href="#Redis遇到哈希冲突怎么办？" class="headerlink" title="Redis遇到哈希冲突怎么办？"></a>Redis遇到哈希冲突怎么办？</h2><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision）。</p>
<p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 <code>next</code> 指针， 多个哈希表节点可以用 <code>next</code> 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p>
<p>原理跟 Java 的 HashMap 类似，都是数组+链表的结构。当发生 hash 碰撞时将会把元素追加到链表上。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络分层结构"><a href="#网络分层结构" class="headerlink" title="网络分层结构"></a>网络分层结构</h2><p>计算机网络体系大致分为三种，OSI七层模型、TCP&#x2F;IP四层模型和五层模型。一般面试的时候考察比较多的是五层模型。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/tcp5layer2.png" alt="img"></p>
<p><strong>五层模型</strong>：应用层、传输层、网络层、数据链路层、物理层。</p>
<ul>
<li><strong>应用层</strong>：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统DNS、HTTP协议、SMTP协议等。</li>
<li><strong>传输层</strong>：负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。</li>
<li><strong>网络层</strong>：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。</li>
<li><strong>数据链路层</strong>：在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。</li>
<li><strong>物理层</strong>：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和物理设备的差异。</li>
</ul>
<p><strong>ISO七层模型</strong>是国际标准化组织（International Organization for Standardization）制定的一个用于计算机或通信系统间互联的标准体系。</p>
<ul>
<li>应用层：网络服务与最终用户的一个接口，常见的协议有：<strong>HTTP FTP SMTP SNMP DNS</strong>.</li>
<li>表示层：数据的表示、安全、压缩。，确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</li>
<li>会话层：建立、管理、终止会话,对应主机进程，指本地主机与远程主机正在进行的会话.</li>
<li>传输层：定义传输数据的协议端口号，以及流控和差错校验,协议有<strong>TCP UDP</strong>.</li>
<li>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择,协议有<strong>ICMP IGMP IP等</strong>.</li>
<li>数据链路层：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路。</li>
<li>物理层：建立、维护、断开物理连接。</li>
</ul>
<p><strong>TCP&#x2F;IP 四层模型</strong></p>
<ul>
<li>应用层：对应于OSI参考模型的（应用层、表示层、会话层）。</li>
<li>传输层: 对应OSI的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。</li>
<li>网际层：对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。</li>
<li>网络接口层：与OSI参考模型的数据链路层、物理层对应。</li>
</ul>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>假设发送端为客户端，接收端为服务端。开始时客户端和服务端的状态都是<code>CLOSED</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%BE%E8%A7%A3.png" alt="img"></p>
<ol>
<li>第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位<code>SYN=1</code>，序列号<code>seq=x</code>。第一次握手前客户端的状态为<code>CLOSE</code>，第一次握手后客户端的状态为<code>SYN-SENT</code>。此时服务端的状态为<code>LISTEN</code>。</li>
<li>第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位<code>SYN=1</code>，<code>ACK=1</code>，序列号<code>seq=y</code>，确认号<code>ack=x+1</code>。第二次握手前服务端的状态为<code>LISTEN</code>，第二次握手后服务端的状态为<code>SYN-RCVD</code>，此时客户端的状态为<code>SYN-SENT</code>。（其中<code>SYN=1</code>表示要和客户端建立一个连接，<code>ACK=1</code>表示确认序号有效）</li>
<li>第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位<code>ACK=1</code>，序列号<code>seq=x+1</code>，确认号<code>ack=y+1</code>。第三次握手前客户端的状态为<code>SYN-SENT</code>，第三次握手后客户端和服务端的状态都为<code>ESTABLISHED</code>。<strong>此时连接建立完成。</strong></li>
</ol>
<h2 id="两次握手可以吗？"><a href="#两次握手可以吗？" class="headerlink" title="两次握手可以吗？"></a>两次握手可以吗？</h2><p>之所以需要第三次握手，主要为了<strong>防止已失效的连接请求报文段</strong>突然又传输到了服务端，导致产生问题。</p>
<ul>
<li>比如客户端A发出连接请求，可能因为网络阻塞原因，A没有收到确认报文，于是A再重传一次连接请求。</li>
<li>然后连接成功，等待数据传输完毕后，就释放了连接。</li>
<li>然后A发出的第一个连接请求等到连接释放以后的某个时间才到达服务端B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段。</li>
<li>如果不采用三次握手，只要B发出确认，就建立新的连接了，<strong>此时A不会响应B的确认且不发送数据，则B一直等待A发送数据，浪费资源。</strong></li>
</ul>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B0.png" alt="img"></p>
<ol>
<li>A的应用进程先向其TCP发出连接释放报文段（<code>FIN=1，seq=u</code>），并停止再发送数据，主动关闭TCP连接，进入<code>FIN-WAIT-1</code>（终止等待1）状态，等待B的确认。</li>
<li>B收到连接释放报文段后即发出确认报文段（<code>ACK=1，ack=u+1，seq=v</code>），B进入<code>CLOSE-WAIT</code>（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。</li>
<li>A收到B的确认后，进入<code>FIN-WAIT-2</code>（终止等待2）状态，等待B发出的连接释放报文段。</li>
<li>B发送完数据，就会发出连接释放报文段（<code>FIN=1，ACK=1，seq=w，ack=u+1</code>），B进入<code>LAST-ACK</code>（最后确认）状态，等待A的确认。</li>
<li>A收到B的连接释放报文段后，对此发出确认报文段（<code>ACK=1，seq=u+1，ack=w+1</code>），A进入<code>TIME-WAIT</code>（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间<code>2MSL</code>（最大报文段生存时间）后，A才进入<code>CLOSED</code>状态。B收到A发出的确认报文段后关闭连接，若没收到A发出的确认报文段，B就会重传连接释放报文段。</li>
</ol>
<h2 id="第四次挥手为什么要等待2MSL？"><a href="#第四次挥手为什么要等待2MSL？" class="headerlink" title="第四次挥手为什么要等待2MSL？"></a>第四次挥手为什么要等待2MSL？</h2><ul>
<li><strong>保证A发送的最后一个ACK报文段能够到达B</strong>。这个<code>ACK</code>报文段有可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，然后A可以在<code>2MSL</code>时间内收到这个重传的连接释放报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到<code>CLOSED</code>状态，若A在<code>TIME-WAIT</code>状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的连接释放报文段，所以不会再发送一次确认报文段，B就无法正常进入到<code>CLOSED</code>状态。</li>
<li><strong>防止已失效的连接请求报文段出现在本连接中</strong>。A在发送完最后一个<code>ACK</code>报文段后，再经过2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。</li>
</ul>
<h2 id="为什么是四次挥手？"><a href="#为什么是四次挥手？" class="headerlink" title="为什么是四次挥手？"></a>为什么是四次挥手？</h2><p>因为当Server端收到Client端的<code>SYN</code>连接请求报文后，可以直接发送<code>SYN+ACK</code>报文。<strong>但是在关闭连接时，当Server端收到Client端发出的连接释放报文时，很可能并不会立即关闭SOCKET</strong>，所以Server端先回复一个<code>ACK</code>报文，告诉Client端我收到你的连接释放报文了。只有等到Server端所有的报文都发送完了，这时Server端才能发送连接释放报文，之后两边才会真正的断开连接。故需要四次挥手。</p>
<h2 id="说说TCP报文首部有哪些字段，其作用又分别是什么？"><a href="#说说TCP报文首部有哪些字段，其作用又分别是什么？" class="headerlink" title="说说TCP报文首部有哪些字段，其作用又分别是什么？"></a>说说TCP报文首部有哪些字段，其作用又分别是什么？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/tcp%E6%8A%A5%E6%96%87.png" alt="img"></p>
<ul>
<li><strong>16位端口号</strong>：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序</li>
<li><strong>32位序号</strong>：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。</li>
<li><strong>32位确认号</strong>：用作对另一方发送的tcp报文段的响应。其值是收到的TCP报文段的序号值加1。</li>
<li><strong>4位头部长度</strong>：表示tcp头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。</li>
<li><strong>6位标志位</strong>：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）</li>
<li><strong>16位窗口大小</strong>：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</li>
<li><strong>16位校验和</strong>：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。</li>
<li><strong>16位紧急指针</strong>：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。</li>
</ul>
<h2 id="TCP有哪些特点？"><a href="#TCP有哪些特点？" class="headerlink" title="TCP有哪些特点？"></a>TCP有哪些特点？</h2><ul>
<li>TCP是<strong>面向连接</strong>的运输层协议。</li>
<li><strong>点对点</strong>，每一条TCP连接只能有两个端点。</li>
<li>TCP提供<strong>可靠交付</strong>的服务。</li>
<li>TCP提供<strong>全双工通信</strong>。</li>
<li><strong>面向字节流</strong>。</li>
</ul>
<h2 id="TCP的粘包和拆包"><a href="#TCP的粘包和拆包" class="headerlink" title="TCP的粘包和拆包"></a>TCP的粘包和拆包</h2><p>TCP是面向流，没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一<strong>个完整的包可能会被TCP拆分成多个包进行发送</strong>，<strong>也有可能把多个小的包封装成一个大的数据包发送</strong>，这就是所谓的TCP粘包和拆包问题。</p>
<p><strong>为什么会产生粘包和拆包呢?</strong></p>
<ul>
<li>要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；</li>
<li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；</li>
<li>要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；</li>
<li>待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度&gt;MSS。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>发送端将每个数据包封装为固定长度</li>
<li>在数据尾部增加特殊字符进行分割</li>
<li>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。</li>
</ul>
<h2 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h2><ol>
<li>TCP<strong>面向连接</strong>；UDP是无连接的，即发送数据之前不需要建立连接。</li>
<li>TCP提供<strong>可靠的服务</strong>；UDP不保证可靠交付。</li>
<li>TCP<strong>面向字节流</strong>，把数据看成一连串无结构的字节流；UDP是面向报文的。</li>
<li>TCP有<strong>拥塞控制</strong>；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如实时视频会议等）。</li>
<li>每一条TCP连接只能是<strong>点到点</strong>的；UDP支持一对一、一对多、多对一和多对多的通信方式。</li>
<li>TCP首部开销20字节；UDP的首部开销小，只有8个字节。</li>
</ol>
<h2 id="TCP-和-UDP-分别对应的常见应用层协议有哪些？"><a href="#TCP-和-UDP-分别对应的常见应用层协议有哪些？" class="headerlink" title="TCP 和 UDP 分别对应的常见应用层协议有哪些？"></a>TCP 和 UDP 分别对应的常见应用层协议有哪些？</h2><p><strong>基于TCP的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH</strong></p>
<ul>
<li><strong>HTTP</strong>：HyperText Transfer Protocol（超文本传输协议），默认端口80</li>
<li><strong>FTP</strong>: File Transfer Protocol (文件传输协议), 默认端口(20用于传输数据，21用于传输控制信息)</li>
<li><strong>SMTP</strong>: Simple Mail Transfer Protocol (简单邮件传输协议) ,默认端口25</li>
<li><strong>TELNET</strong>: Teletype over the Network (网络电传), 默认端口23</li>
<li><strong>SSH</strong>：Secure Shell（安全外壳协议），默认端口 22</li>
</ul>
<p><strong>基于UDP的应用层协议：DNS、TFTP、SNMP</strong></p>
<ul>
<li><strong>DNS</strong> : Domain Name Service (域名服务),默认端口 53</li>
<li><strong>TFTP</strong>: Trivial File Transfer Protocol (简单文件传输协议)，默认端口69</li>
<li><strong>SNMP</strong>：Simple Network Management Protocol（简单网络管理协议），通过UDP端口161接收，只有Trap信息采用UDP端口162。</li>
</ul>
<h2 id="说说TCP是如何确保可靠性的呢？"><a href="#说说TCP是如何确保可靠性的呢？" class="headerlink" title="说说TCP是如何确保可靠性的呢？"></a>说说TCP是如何确保可靠性的呢？</h2><ul>
<li>首先，TCP的连接是基于<strong>三次握手</strong>，而断开则是基于<strong>四次挥手</strong>。确保连接和断开的可靠性。</li>
<li>其次，TCP的可靠性，还体现在<strong>有状态</strong>;TCP会记录哪些数据发送了，哪些数据被接收了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。</li>
<li>再次，TCP的可靠性，还体现在<strong>可控制</strong>。它有数据包校验、ACK应答、**超时重传(发送方)**、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。</li>
</ul>
<h2 id="说下TCP的滑动窗口机制"><a href="#说下TCP的滑动窗口机制" class="headerlink" title="说下TCP的滑动窗口机制"></a>说下TCP的滑动窗口机制</h2><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 TCP会话的双方都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制。发送窗口则取决于对端通告的接收窗口。接收方发送的确认报文中的window字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将接收方的确认报文window字段设置为 0，则发送方不能发送数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/image-20210921112213523.png" alt="img"></p>
<p>TCP头包含window字段，16bit位，它代表的是窗口的字节容量，最大为65535。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。接收窗口的大小是约等于发送窗口的大小。</p>
<h2 id="详细讲一下拥塞控制？"><a href="#详细讲一下拥塞控制？" class="headerlink" title="详细讲一下拥塞控制？"></a>详细讲一下拥塞控制？</h2><p>防止过多的数据注入到网络中。 几种拥塞控制方法：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg" alt="img"></p>
<p><strong>慢开始</strong></p>
<p>把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。</p>
<p>当 cwnd &lt; ssthresh 时，使用慢开始算法。</p>
<p>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p>
<p>当 cwnd &#x3D; ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p>
<p><strong>拥塞避免</strong></p>
<p>让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长。</p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<p><strong>快重传</strong></p>
<p>有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而降低了传输效率。</p>
<p>快重传算法可以避免这个问题。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，使发送方及早知道有报文段没有到达对方。</p>
<p>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p>
<p><strong>快恢复</strong></p>
<p>当发送方连续收到三个重复确认，就会把慢开始门限ssthresh减半，接着把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。</p>
<p>在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。 采用这样的拥塞控制方法使得TCP的性能有明显的改进。</p>
<h2 id="HTTP协议的特点？"><a href="#HTTP协议的特点？" class="headerlink" title="HTTP协议的特点？"></a>HTTP协议的特点？</h2><ol>
<li>HTTP允许传输<strong>任意类型</strong>的数据。传输的类型由Content-Type加以标记。</li>
<li><strong>无状态</strong>。对于客户端每次发送的请求，服务器都认为是一个新的请求，上一次会话和下一次会话之间没有联系。</li>
<li>支持<strong>客户端&#x2F;服务器模式</strong>。</li>
</ol>
<h2 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h2><p>HTTP请求由<strong>请求行、请求头部、空行和请求体</strong>四个部分组成。</p>
<ul>
<li><strong>请求行</strong>：包括请求方法，访问的资源URL，使用的HTTP版本。<code>GET</code>和<code>POST</code>是最常见的HTTP方法，除此以外还包括<code>DELETE、HEAD、OPTIONS、PUT、TRACE</code>。</li>
<li><strong>请求头</strong>：格式为“属性名:属性值”，服务端根据请求头获取客户端的信息，主要有<code>cookie、host、connection、accept-language、accept-encoding、user-agent</code>。</li>
<li><strong>请求体</strong>：用户的请求数据如用户名，密码等。</li>
</ul>
<p><strong>请求报文示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /xxx HTTP/<span class="number">1.1</span> 请求行</span><br><span class="line">Accept:image/gif.image/jpeg, 请求头部</span><br><span class="line">Accept-Language:zh-cn</span><br><span class="line">Connection:Keep-Alive</span><br><span class="line">Host:localhost</span><br><span class="line">User-Agent:Mozila/<span class="number">4.0</span>(compatible;MSIE5<span class="number">.01</span>;Window NT5<span class="number">.0</span>)</span><br><span class="line">Accept-Encoding:gzip,deflate</span><br><span class="line"></span><br><span class="line">username=dabin 请求体</span><br></pre></td></tr></table></figure>

<p>HTTP响应也由四个部分组成，分别是：<strong>状态行、响应头、空行和响应体</strong>。</p>
<ul>
<li><strong>状态行</strong>：协议版本，状态码及状态描述。</li>
<li><strong>响应头</strong>：响应头字段主要有<code>connection、content-type、content-encoding、content-length、set-cookie、Last-Modified，、Cache-Control、Expires</code>。</li>
<li><strong>响应体</strong>：服务器返回给客户端的内容。</li>
</ul>
<p><strong>响应报文示例</strong>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server:Apache Tomcat/5.0.12</span><br><span class="line">Date:Mon,6Oct2003 13:23:42 GMT</span><br><span class="line">Content-Length:112</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>响应体<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="HTTP状态码有哪些？"><a href="#HTTP状态码有哪些？" class="headerlink" title="HTTP状态码有哪些？"></a>HTTP状态码有哪些？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/http-status-code.png" alt="img"></p>
<p>HTTP 状态码是服务器端返回给客户端的响应状态码，根据状态码我们就能知道服务器端想要给客户端表达的具体含义，比如 200 就表示请求访问成功，500 就表示服务器端程序出错等。HTTP 状态码可分为 5 大类：</p>
<ol>
<li>1XX：消息状态码。</li>
<li>2XX：成功状态码。</li>
<li>3XX：重定向状态码。</li>
<li>4XX：客户端错误状态码。</li>
<li>5XX：服务端错误状态码。</li>
</ol>
<p>这 5 大类中又包含了很多具体的状态码。</p>
<p>1XX为<strong>消息状态码</strong>，其中：</p>
<ul>
<li>100：Continue 继续。客户端应继续其请求。</li>
<li>101：Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议。</li>
</ul>
<p>2XX为<strong>成功状态码</strong>，其中：</p>
<ul>
<li><strong>200：OK 请求成功。一般用于 GET 与 POST 请求。</strong></li>
<li>201：Created 已创建。成功请求并创建了新的资源。</li>
<li>202：Accepted 已接受。已经接受请求，但未处理完成。</li>
<li>203：Non-Authoritative Information 非授权信息。请求成功。但返回的 meta 信息不在原始的服务器，而是一个副本。</li>
<li>204：No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档。</li>
<li>205：Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域。</li>
<li>206：Partial Content 部分内容。服务器成功处理了部分 GET 请求。</li>
</ul>
<p>3XX为<strong>重定向状态码</strong>，其中：</p>
<ul>
<li>300：Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择。</li>
<li><strong>301：Moved Permanently 永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替。</strong></li>
<li><strong>302：Found 临时移动，与 301 类似。但资源只是临时被移动。客户端应继续使用原有URI。</strong></li>
<li>303：See Other 查看其它地址。与 301 类似。使用 GET 和 POST 请求查看。</li>
<li>304：Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。</li>
<li>305：Use Proxy 使用代理。所请求的资源必须通过代理访问。</li>
<li>306：Unused 已经被废弃的 HTTP 状态码。</li>
<li>307：Temporary Redirect 临时重定向。与 302 类似。使用 GET 请求重定向。</li>
</ul>
<p>4XX为客户端<strong>错误状态码</strong>，其中：</p>
<ul>
<li>400：Bad Request 客户端请求的语法错误，服务器无法理解。</li>
<li>401：Unauthorized 请求要求用户的身份认证。</li>
<li>402：Payment Required 保留，将来使用。</li>
<li>403：Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求。</li>
<li><strong>404：Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面。</strong></li>
<li><strong>405：Method Not Allowed 客户端请求中的方法被禁止。</strong></li>
<li>406：Not Acceptable 服务器无法根据客户端请求的内容特性完成请求。</li>
<li>407：Proxy Authentication Required 请求要求代理的身份认证，与 401 类似，但请求者应当使用代理进行授权。</li>
<li>408：Request Time-out 服务器等待客户端发送的请求时间过长，超时。</li>
<li>409：Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突。</li>
<li>410：Gone 客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置。</li>
<li>411：Length Required 服务器无法处理客户端发送的不带 Content-Length 的请求信息。</li>
<li>412：Precondition Failed 客户端请求信息的先决条件错误。</li>
<li>413：Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个 Retry-After 的响应信息。</li>
<li>414：Request-URI Too Large 请求的 URI 过长（URI通常为网址），服务器无法处理。</li>
<li>415：Unsupported Media Type 服务器无法处理请求附带的媒体格式。</li>
<li>416：Requested range not satisfiable 客户端请求的范围无效。</li>
<li>417：Expectation Failed 服务器无法满足 Expect 的请求头信息。</li>
</ul>
<p>5XX为<strong>服务端错误状态码</strong>，其中：</p>
<ul>
<li><strong>500：Internal Server Error 服务器内部错误，无法完成请求。</strong></li>
<li>501：Not Implemented 服务器不支持请求的功能，无法完成请求。</li>
<li>502：Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。</li>
<li>503：Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中。</li>
<li>504：Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求。</li>
<li>505：HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理。</li>
</ul>
<p><strong>总结一下</strong>：</p>
<p>HTTP 状态码分为 5 大类：1XX：表示消息状态码；2XX：表示成功状态码；3XX：表示重定向状态码；4XX：表示客户端错误状态码；5XX：表示服务端错误状态码。其中常见的具体状态码有：200：请求成功；301：永久重定向；302：临时重定向；404：无法找到此页面；405：请求的方法类型不支持；500：服务器内部出错。</p>
<h2 id="HTTP-协议包括哪些请求？"><a href="#HTTP-协议包括哪些请求？" class="headerlink" title="HTTP 协议包括哪些请求？"></a>HTTP 协议包括哪些请求？</h2><p>HTTP协议中共定义了八种方法来表示对Request-URI指定的资源的不同操作方式，具体如下：</p>
<ul>
<li>GET：向特定的资源发出请求。</li>
<li>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和&#x2F;或已有资源的修改。</li>
<li>OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</li>
<li>HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</li>
<li>PUT：向指定资源位置上传其最新内容。</li>
<li>DELETE：请求服务器删除Request-URI所标识的资源。</li>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li>
<li>CONNECT：HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。</li>
</ul>
<h2 id="HTTP状态码301和302的区别？"><a href="#HTTP状态码301和302的区别？" class="headerlink" title="HTTP状态码301和302的区别？"></a>HTTP状态码301和302的区别？</h2><ul>
<li>301：（永久性转移）请求的网页已被永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。</li>
<li>302：（暂时性转移）服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应GET和HEAD请求的301代码类似，会自动将请求者转到不同的位置。</li>
</ul>
<p><strong>举个形象的例子</strong>：当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，打个比方说，我有一套房子，但是最近走亲戚去亲戚家住了，过两天我还回来的。而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的，就比如你的那套房子其实是租的，现在租期到了，你又在另一个地方找到了房子，之前租的房子不住了。</p>
<h2 id="POST和GET的区别？"><a href="#POST和GET的区别？" class="headerlink" title="POST和GET的区别？"></a>POST和GET的区别？</h2><ul>
<li>GET 和 POST 最本质的区别是规范上的区别，在规范中，定义 GET 请求是用来获取资源的，也就是进行查询操作的，而 POST 请求是用来传输实体对象的，因此会使用 POST 来进行添加、修改和删除等操作。</li>
<li>GET请求参数通过URL传递，POST的参数放在请求体中。</li>
<li>GET 请求可以直接进行回退和刷新，不会对用户和程序产生任何影响；而 POST 请求如果直接回滚和刷新将会把数据再次提交。</li>
<li>GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把请求头和请求体一并发送出去；而对于POST，浏览器先发送请求头，服务器响应100 continue，浏览器再发送请求体。</li>
<li>GET 请求一般会被缓存，比如常见的 CSS、JS、HTML 请求等都会被缓存；而 POST 请求默认是不进行缓存的。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
</ul>
<h2 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h2><ul>
<li>URI，全称是Uniform Resource Identifier)，中文翻译是统一资源标志符，主要作用是唯一标识一个资源。</li>
<li>URL，全称是Uniform Resource Location)，中文翻译是统一资源定位符，主要作用是提供资源的路径。打个经典比喻吧，URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人。</li>
</ul>
<h2 id="如何理解HTTP协议是无状态的"><a href="#如何理解HTTP协议是无状态的" class="headerlink" title="如何理解HTTP协议是无状态的"></a>如何理解HTTP协议是无状态的</h2><p>当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。简言之，服务器不会去记住你是谁，所以是无状态协议。</p>
<h2 id="HTTP长连接和短连接？"><a href="#HTTP长连接和短连接？" class="headerlink" title="HTTP长连接和短连接？"></a>HTTP长连接和短连接？</h2><p>HTTP短连接：浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。<strong>HTTP1.0默认使用的是短连接</strong>。</p>
<p>HTTP长连接：指的是<strong>复用TCP连接</strong>。多个HTTP请求可以复用同一个TCP连接，这就节省了TCP连接建立和断开的消耗。</p>
<p><strong>HTTP&#x2F;1.1起，默认使用长连接</strong>。要使用长连接，客户端和服务器的HTTP首部的Connection都要设置为keep-alive，才能支持长连接。</p>
<h2 id="HTTP-如何实现长连接？"><a href="#HTTP-如何实现长连接？" class="headerlink" title="HTTP 如何实现长连接？"></a>HTTP 如何实现长连接？</h2><p>HTTP分为长连接和短连接，<strong>本质上说的是TCP的长短连接</strong>。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才具有真正的长连接和短连接这一说法哈。</p>
<p>TCP长连接可以复用一个TCP连接，来发起多次的HTTP请求，这样就可以减少资源消耗，比如一次请求HTML，如果是短连接的话，可能还需要请求后续的JS&#x2F;CSS。</p>
<p><strong>如何设置长连接？</strong></p>
<p>通过在头部（请求和响应头）设置<strong>Connection</strong>字段指定为<code>keep-alive</code>，HTTP&#x2F;1.0协议支持，但是是默认关闭的，从HTTP&#x2F;1.1以后，连接默认都是长连接。</p>
<h2 id="HTTP长连接在什么时候会超时？"><a href="#HTTP长连接在什么时候会超时？" class="headerlink" title="HTTP长连接在什么时候会超时？"></a>HTTP长连接在什么时候会超时？</h2><p>HTTP一般会有httpd守护进程，里面可以设置<strong>keep-alive timeout</strong>，当tcp连接闲置超过这个时间就会关闭，也可以在HTTP的header里面设置超时时间。</p>
<p>TCP 的<strong>keep-alive</strong>包含三个参数，支持在系统内核的net.ipv4里面设置；当 TCP 连接之后，闲置了<strong>tcp_keepalive_time</strong>，则会发生侦测包，如果没有收到对方的ACK，那么会每隔 tcp_keepalive_intvl再发一次，直到发送了<strong>tcp_keepalive_probes</strong>，就会丢弃该连接。</p>
<h2 id="HTTP1-1和-HTTP2-0的区别？"><a href="#HTTP1-1和-HTTP2-0的区别？" class="headerlink" title="HTTP1.1和 HTTP2.0的区别？"></a>HTTP1.1和 HTTP2.0的区别？</h2><p>HTTP2.0相比HTTP1.1支持的特性：</p>
<ul>
<li><strong>新的二进制格式</strong>：HTTP1.1 基于文本格式传输数据；HTTP2.0采用二进制格式传输数据，解析更高效。</li>
<li><strong>多路复用</strong>：在一个连接里，允许同时发送多个请求或响应，<strong>并且这些请求或响应能够并行的传输而不被阻塞</strong>，避免 HTTP1.1 出现的”队头堵塞”问题。</li>
<li><strong>头部压缩</strong>，HTTP1.1的header带有大量信息，而且每次都要重复发送；HTTP2.0 把header从数据中分离，并封装成头帧和数据帧，<strong>使用特定算法压缩头帧</strong>，有效减少头信息大小。并且HTTP2.0<strong>在客户端和服务器端记录了之前发送的键值对，对于相同的数据，不会重复发送。</strong>比如请求a发送了所有的头信息字段，请求b则<strong>只需要发送差异数据</strong>，这样可以减少冗余数据，降低开销。</li>
<li><strong>服务端推送</strong>：HTTP2.0允许服务器向客户端推送资源，无需客户端发送请求到服务器获取。</li>
</ul>
<h2 id="HTTPS与HTTP的区别？"><a href="#HTTPS与HTTP的区别？" class="headerlink" title="HTTPS与HTTP的区别？"></a>HTTPS与HTTP的区别？</h2><ol>
<li>HTTP是超文本传输协议，信息是<strong>明文传输</strong>；HTTPS则是具有<strong>安全性</strong>的ssl加密传输协议。</li>
<li>HTTP和HTTPS用的端口不一样，HTTP端口是80，HTTPS是443。</li>
<li>HTTPS协议<strong>需要到CA机构申请证书</strong>，一般需要一定的费用。</li>
<li>HTTP运行在TCP协议之上；HTTPS运行在SSL协议之上，SSL运行在TCP协议之上。</li>
</ol>
<h2 id="什么是数字证书？"><a href="#什么是数字证书？" class="headerlink" title="什么是数字证书？"></a>什么是数字证书？</h2><p>服务端可以向证书颁发机构CA申请证书，以避免中间人攻击（防止证书被篡改）。证书包含三部分内容：<strong>证书内容、证书签名算法和签名</strong>，签名是为了验证身份。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/image-20211004111441594.png" alt="img"></p>
<p>服务端把证书传输给浏览器，浏览器从证书里取公钥。证书可以证明该公钥对应本网站。</p>
<p><strong>数字签名的制作过程</strong>：</p>
<ol>
<li>CA使用证书签名算法对证书内容进行<strong>hash运算</strong>。</li>
<li>对hash后的值<strong>用CA的私钥加密</strong>，得到数字签名。</li>
</ol>
<p><strong>浏览器验证过程</strong>：</p>
<ol>
<li>获取证书，得到证书内容、证书签名算法和数字签名。</li>
<li>用CA机构的公钥<strong>对数字签名解密</strong>（由于是浏览器信任的机构，所以浏览器会保存它的公钥）。</li>
<li>用证书里的签名算法<strong>对证书内容进行hash运算</strong>。</li>
<li>比较解密后的数字签名和对证书内容做hash运算后得到的哈希值，相等则表明证书可信。</li>
</ol>
<h2 id="HTTPS原理"><a href="#HTTPS原理" class="headerlink" title="HTTPS原理"></a>HTTPS原理</h2><p>首先是TCP三次握手，然后客户端发起一个HTTPS连接建立请求，客户端先发一个<code>Client Hello</code>的包，然后服务端响应<code>Server Hello</code>，接着再给客户端发送它的证书，然后双方经过密钥交换，最后使用交换的密钥加解密数据。</p>
<ol>
<li><p><strong>协商加密算法</strong> 。在<code>Client Hello</code>里面客户端会告知服务端自己当前的一些信息，包括客户端要使用的TLS版本，支持的加密算法，要访问的域名，给服务端生成的一个随机数（Nonce）等。需要提前告知服务器想要访问的域名以便服务器发送相应的域名的证书过来。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/image-20210921104210833.png" alt="img"></p>
</li>
<li><p>服务端响应<code>Server Hello</code>，告诉客户端服务端<strong>选中的加密算法</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/image-20210921105450791.png" alt="img"></p>
</li>
<li><p>接着服务端给客户端发来了2个证书。第二个证书是第一个证书的签发机构（CA）的证书。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/image-20211004172007102.png" alt="img"></p>
</li>
<li><p>客户端使用证书的认证机构CA公开发布的RSA公钥<strong>对该证书进行验证</strong>，下图表明证书认证成功。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/image-20210921105929268.png" alt="img"></p>
</li>
<li><p>验证通过之后，浏览器和服务器通过<strong>密钥交换算法</strong>产生共享的<strong>对称密钥</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/image-20210921110025197.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/image-20210921110155075.png" alt="img"></p>
</li>
<li><p>开始传输数据，使用同一个对称密钥来加解密。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/image-20210921110315068.png" alt="img"></p>
</li>
</ol>
<h2 id="DNS-的解析过程？"><a href="#DNS-的解析过程？" class="headerlink" title="DNS 的解析过程？"></a>DNS 的解析过程？</h2><ol>
<li>浏览器搜索<strong>自己的DNS缓存</strong></li>
<li>若没有，则搜索<strong>操作系统中的DNS缓存和hosts文件</strong></li>
<li>若没有，则操作系统将域名发送至<strong>本地域名服务器</strong>，本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则依次向<strong>根域名服务器、顶级域名服务器、权限域名服务器</strong>发起查询请求，最终返回IP地址给本地域名服务器</li>
<li>本地域名服务器将得到的IP地址返回给<strong>操作系统</strong>，同时自己也<strong>将IP地址缓存起来</strong></li>
<li>操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来</li>
<li>浏览器得到域名对应的IP地址</li>
</ol>
<h2 id="浏览器中输入URL返回页面过程？"><a href="#浏览器中输入URL返回页面过程？" class="headerlink" title="浏览器中输入URL返回页面过程？"></a>浏览器中输入URL返回页面过程？</h2><ol>
<li><strong>解析域名</strong>，找到主机 IP。</li>
<li>浏览器利用 IP 直接与网站主机通信，<strong>三次握手</strong>，建立 TCP 连接。浏览器会以一个随机端口向服务端的 web 程序 80 端口发起 TCP 的连接。</li>
<li>建立 TCP 连接后，浏览器向主机发起一个HTTP请求。</li>
<li>参数从客户端传递到服务器端。</li>
<li>服务器端得到客户端参数之后，进行相应的业务处理，再将结果封装成 HTTP 包，返回给客户端。</li>
<li>服务器端和客户端的交互完成，断开 TCP 连接（4 次挥手）。</li>
<li>浏览器<strong>解析响应内容，进行渲染</strong>，呈现给用户。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E8%BE%93%E5%85%A5url%E8%BF%94%E5%9B%9E%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B1.png" alt="img"></p>
<h2 id="DNS-域名解析的过程"><a href="#DNS-域名解析的过程" class="headerlink" title="DNS 域名解析的过程"></a>DNS 域名解析的过程</h2><p>在网络中定位是依靠 IP 进行身份定位的，所以 URL 访问的第一步便是先要得到服务器端的 IP 地址。而得到服务器的 IP 地址需要使用 DNS（Domain Name System，域名系统）域名解析，DNS 域名解析就是通过 URL 找到与之相对应的 IP 地址。</p>
<p>DNS 域名解析的大致流程如下：</p>
<ol>
<li>先检<strong>查浏览器中的 DNS 缓存</strong>，如果浏览器中有对应的记录会直接使用，并完成解析；</li>
<li>如果浏览器没有缓存，那就去<strong>查询操作系统的缓存</strong>，如果查询到记录就可以直接返回 IP 地址，完成解析；</li>
<li>如果操作系统没有 DNS 缓存，就会去<strong>查看本地 host 文件</strong>，Windows 操作系统下，host 文件一般位于 “C:\Windows\System32\drivers\etc\hosts”，如果 host 文件有记录则直接使用；</li>
<li>如果本地 host 文件没有相应的记录，会<strong>请求本地 DNS 服务器</strong>，本地 DNS 服务器一般是由本地网络服务商如移动、联通等提供。通常情况下可通过 DHCP 自动分配，当然也可以自己手动配置。目前用的比较多的是谷歌提供的公用 DNS 是 8.8.8.8 和国内的公用 DNS 是 114.114.114.114。</li>
<li>如果本地 DNS 服务器没有相应的记录，就会<strong>去根域名服务器查询</strong>了。为了能更高效完成全球所有域名的解析请求，根域名服务器本身并不会直接去解析域名，而是会把不同的解析请求分配给下面的其他服务器去完成。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/image-20221123001836666.png" alt="img"></p>
<blockquote>
<p>图片来源于网络</p>
</blockquote>
<h2 id="什么是cookie和session？"><a href="#什么是cookie和session？" class="headerlink" title="什么是cookie和session？"></a>什么是cookie和session？</h2><p>由于HTTP协议是无状态的协议，需要用某种机制来识具体的用户身份，用来跟踪用户的整个会话。常用的会话跟踪技术是cookie与session。</p>
<p><strong>cookie</strong>就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。说得更具体一些：当用户使用浏览器访问一个支持cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体中的，而是存放于HTTP响应头；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置。 自此，客户端再向服务器发送请求的时候，都会把相应的cookie存放在HTTP请求头再次发回至服务器。服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。网站的登录界面中“请记住我”这样的选项，就是通过cookie实现的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/cookie.png" alt="img"></p>
<p><strong>cookie工作流程</strong>：</p>
<ol>
<li>servlet创建cookie，保存少量数据，发送给浏览器。</li>
<li>浏览器获得服务器发送的cookie数据，将自动的保存到浏览器端。</li>
<li>下次访问时，浏览器将自动携带cookie数据发送给服务器。</li>
</ol>
<p><strong>session原理</strong>：首先浏览器请求服务器访问web站点时，服务器首先会检查这个客户端请求是否已经包含了一个session标识、称为SESSIONID，如果已经包含了一个sessionid则说明以前已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用，如果客户端请求不包含session id，则服务器为此客户端创建一个session，并且生成一个与此session相关联的独一无二的sessionid存放到cookie中，这个sessionid将在本次响应中返回到客户端保存，这样在交互的过程中，浏览器端每次请求时，都会带着这个sessionid，服务器根据这个sessionid就可以找得到对应的session。以此来达到共享数据的目的。 这里需要注意的是，session不会随着浏览器的关闭而死亡，而是等待超时时间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/session.png" alt="img"></p>
<h2 id="cookie和session的区别？"><a href="#cookie和session的区别？" class="headerlink" title="cookie和session的区别？"></a>cookie和session的区别？</h2><ul>
<li><strong>作用范围不同</strong>，Cookie 保存在客户端，Session 保存在服务器端。</li>
<li><strong>有效期不同</strong>，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li><strong>隐私策略不同</strong>，Cookie 存储在客户端，容易被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li><strong>存储大小不同</strong>， 单个 Cookie 保存的数据不能超过 4K；对于 Session 来说存储没有上限，但出于对服务器的性能考虑，Session 内不要存放过多的数据，并且需要设置 Session 删除机制。</li>
</ul>
<h2 id="什么是对称加密和非对称加密？"><a href="#什么是对称加密和非对称加密？" class="headerlink" title="什么是对称加密和非对称加密？"></a>什么是对称加密和非对称加密？</h2><p><strong>对称加密</strong>：通信双方使用<strong>相同的密钥</strong>进行加密。特点是加密速度快，但是缺点是密钥泄露会导致密文数据被破解。常见的对称加密有<code>AES</code>和<code>DES</code>算法。</p>
<p><strong>非对称加密</strong>：它需要生成两个密钥，<strong>公钥和私钥</strong>。公钥是公开的，任何人都可以获得，而私钥是私人保管的。公钥负责加密，私钥负责解密；或者私钥负责加密，公钥负责解密。这种加密算法<strong>安全性更高</strong>，但是<strong>计算量相比对称加密大很多</strong>，加密和解密都很慢。常见的非对称算法有<code>RSA</code>和<code>DSA</code>。</p>
<h2 id="说说-WebSocket与socket的区别"><a href="#说说-WebSocket与socket的区别" class="headerlink" title="说说 WebSocket与socket的区别"></a>说说 WebSocket与socket的区别</h2><p>Socket是一套标准，它完成了对TCP&#x2F;IP的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。Socket其实就是等于<strong>IP地址 + 端口 + 协议</strong>。</p>
<p>WebSocket是一个持久化的协议，它是伴随H5而出的协议，用来解决<strong>http不支持持久化连接</strong>的问题。</p>
<p>Socket一个是<strong>网编编程的标准接口</strong>，而WebSocket则是应用层通信协议。</p>
<h2 id="ARP协议的工作过程？"><a href="#ARP协议的工作过程？" class="headerlink" title="ARP协议的工作过程？"></a>ARP协议的工作过程？</h2><p>ARP解决了同一个局域网上的主机和路由器IP和MAC地址的解析。</p>
<ul>
<li>每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。</li>
<li>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。</li>
<li>网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址。</li>
<li>源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。</li>
<li>如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li>
</ul>
<h2 id="ICMP协议的功能"><a href="#ICMP协议的功能" class="headerlink" title="ICMP协议的功能"></a>ICMP协议的功能</h2><p>ICMP,Internet Control Message Protocol ,Internet控制消息协议。</p>
<ul>
<li>ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。</li>
<li>它是一个非常重要的协议，它对于网络安全具有极其重要的意义。它属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括<strong>报告错误、交换受限控制和状态信息</strong>等。</li>
<li>当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。</li>
</ul>
<p>比如我们日常使用得比较多的<strong>ping</strong>，就是基于ICMP的。</p>
<h2 id="什么是DoS、DDoS、DRDoS攻击？"><a href="#什么是DoS、DDoS、DRDoS攻击？" class="headerlink" title="什么是DoS、DDoS、DRDoS攻击？"></a>什么是DoS、DDoS、DRDoS攻击？</h2><ul>
<li><strong>DOS</strong>: (Denial of Service),翻译过来就是拒绝服务,一切能引起DOS行为的攻击都被称为DOS攻击。最常见的DoS攻击就有<strong>计算机网络宽带攻击</strong>、<strong>连通性攻击</strong>。</li>
<li><strong>DDoS</strong>: (Distributed Denial of Service),翻译过来是分布式拒绝服务。是指处于不同位置的多个攻击者同时向一个或几个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。常见的DDos有<strong>SYN Flood、Ping of Death、ACK Flood、UDP Flood</strong>等。</li>
<li><strong>DRDoS</strong>: (Distributed Reflection Denial of Service)，中文是分布式反射拒绝服务，该方式靠的是发送大量带有被害者IP地址的数据包给攻击主机，然后攻击主机对IP地址源做出大量回应，从而形成拒绝服务攻击。</li>
</ul>
<h2 id="什么是CSRF攻击，如何避免"><a href="#什么是CSRF攻击，如何避免" class="headerlink" title="什么是CSRF攻击，如何避免"></a>什么是CSRF攻击，如何避免</h2><p>CSRF，跨站请求伪造（英文全称是Cross-site request forgery），是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</p>
<p><strong>怎么解决CSRF攻击呢？</strong></p>
<ul>
<li>检查Referer字段。</li>
<li>添加校验token。</li>
</ul>
<h2 id="什么是XSS攻击？"><a href="#什么是XSS攻击？" class="headerlink" title="什么是XSS攻击？"></a>什么是XSS攻击？</h2><p>XSS，跨站脚本攻击（Cross-Site Scripting）。它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的。XSS攻击一般分三种类型：<strong>存储型 、反射型 、DOM型XSS</strong></p>
<h2 id="如何解决XSS攻击问题？"><a href="#如何解决XSS攻击问题？" class="headerlink" title="如何解决XSS攻击问题？"></a>如何解决XSS攻击问题？</h2><ul>
<li>对输入进行过滤，过滤标签等，只允许合法值。</li>
<li>HTML转义</li>
<li>对于链接跳转，如<code>&lt;a href=&quot;xxx&quot;</code> 等，要校验内容，禁止以script开头的非法链接。</li>
<li>限制输入长度</li>
</ul>
<h2 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h2><p><strong>盗链</strong>是指服务提供商自己不提供服务的内容，通过技术手段（可以理解成爬虫）去获取其他网站的资源展示在自己的网站上。常见的盗链有以下几种：图片盗链、音频盗链、视频盗链等。</p>
<p>网站盗链会大量消耗被盗链网站的带宽，而真正的点击率也许会很小，严重损害了被盗链网站的利益。</p>
<p>被盗网站就自然会<strong>防盗链</strong>，可以通过经常更换图片名，也可以通过检测referer。因为正常用户访问一张图片一定是从自己的网站点击链接进去的，如果一个请求的referer是其他网站，就说明这是一个爬虫。</p>
<p><strong>什么是 Referer？</strong></p>
<p>这里的 Referer 指的是 HTTP 头部的一个字段，也称为 HTTP 来源地址（HTTP Referer），用来表示从哪儿链接到目前的网页，采用的格式是 URL。换句话说，借着 HTTP Referer 头部网页可以检查访客从哪里而来，这也常被用来对付伪造的跨网站请求。</p>
<p>盗链网站会针对性进行<strong>反盗链</strong>，可以通过在请求的headers中设置referer来绕过<strong>防盗链</strong>，我们现在使用爬虫抓取别人的网站也是这样。</p>
<p><strong>什么是空 Referer，什么时候会出现空 Referer？</strong></p>
<p>首先，我们对空 Referer 的定义为，Referer 头部的内容为空，或者，一个 HTTP 请求中根本不包含 Referer 头部。</p>
<p>那么什么时候 HTTP 请求会不包含 Referer 字段呢？根据 Referer 的定义，它的作用是指示一个请求是从哪里链接过来，那么当一个请求并不是由链接触发产生的，那么自然也就不需要指定这个请求的链接来源。</p>
<p>比如，直接在浏览器的地址栏中输入一个资源的 URL 地址，那么这种请求是不会包含 Referer 字段的，因为这是一个 “凭空产生” 的 HTTP 请求，并不是从一个地方链接过去的。</p>
<h2 id="说下ping的原理"><a href="#说下ping的原理" class="headerlink" title="说下ping的原理"></a>说下ping的原理</h2><p>ping，<strong>Packet Internet Groper</strong>，是一种因特网包探索器，用于测试网络连接量的程序。Ping是工作在TCP&#x2F;IP网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送ICMP（Internet Control Message Protocol 因特网报文控制协议） 请求报文，测试目的站是否可达及了解其有关状态。</p>
<p>一般来说，ping可以用来检测网络通不通。它是基于<code>ICMP</code>协议工作的。假设<strong>机器A</strong> ping<strong>机器B</strong>，工作过程如下：</p>
<ol>
<li>ping通知系统，新建一个固定格式的ICMP请求数据包</li>
<li>ICMP协议，将该数据包和目标机器B的IP地址打包，一起转交给IP协议层</li>
<li>IP层协议将本机IP地址为源地址，机器B的IP地址为目标地址，加上一些其他的控制信息，构建一个IP数据包</li>
<li>先获取目标机器B的MAC地址。</li>
<li>数据链路层构建一个数据帧，目的地址是IP层传过来的<strong>MAC地址</strong>，源地址是本机的<strong>MAC地址</strong></li>
<li>机器B收到后，对比目标地址，和自己本机的MAC地址是否一致，符合就处理返回，不符合就丢弃。</li>
<li>根据目的主机返回的ICMP回送回答报文中的时间戳，从而计算出往返时间</li>
<li>最终显示结果有这几项：发送到目的主机的IP地址、发送 &amp; 收到 &amp; 丢失的分组数、往返时间的最小、最大&amp; 平均值</li>
</ol>
<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h2><p><em>“较简单，不做过多赘述，后面会详细学到”</em></p>
<h3 id="第一节-计算机系统层次结构"><a href="#第一节-计算机系统层次结构" class="headerlink" title="第一节 计算机系统层次结构"></a>第一节 计算机系统层次结构</h3><p>1.计算机系统的基本组成：硬件+软件</p>
<p>2.计算机硬件的基本组成：运算器+存储器+控制器+输入设备+输出设备</p>
<p>3.系统软件和应用软件</p>
<table>
<thead>
<tr>
<th>系统软件</th>
<th>操作系统、数据库管理系统、语言处理程序、分布式软件系统、网络软件系统、标准库语言、服务性程序</th>
</tr>
</thead>
<tbody><tr>
<td>应用软件</td>
<td>科学计算类程序、工程设计类程序、数据统计与处理程序</td>
</tr>
</tbody></table>
<p>4.（易考）翻译程序：</p>
<table>
<thead>
<tr>
<th>汇编程序（汇编器）</th>
<th>将汇编语言程序翻译成机器语言程序</th>
</tr>
</thead>
<tbody><tr>
<td>解释程序（解释器）</td>
<td>将源程序翻译成机器指令并立即执行</td>
</tr>
<tr>
<td>编译程序（编译器）</td>
<td>将高级语言翻译城机器语言或汇编语言</td>
</tr>
</tbody></table>
<h3 id="第二节-计算机性能指标"><a href="#第二节-计算机性能指标" class="headerlink" title="第二节 计算机性能指标"></a>第二节 计算机性能指标</h3><ul>
<li><strong>吞吐量</strong>：表征一台计算机在某一时间间隔内能够处理信息量。</li>
<li><strong>响应时间</strong>：表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量的。</li>
<li><strong>利用率</strong>：在给定的时间间隔系统被实际使用的时间所占的比率，用百分比表示的。</li>
<li><strong>处理机字长</strong>：指处理机运算器中一次能够完成二进制数运算的位数，如 32 位、64 位。</li>
<li><strong>总线宽度</strong>：一般指 CPU 中运算器与存储器之间进行互连的内部总线二进制位数。</li>
<li><strong>存储器容量</strong>：存储器中所有存储单元的总数目，通常用 KB、MB、GB、TB 来表示。公式一般是：位数×个数</li>
</ul>
<p>（MAR×MDR）</p>
<ul>
<li><strong>存储器带宽</strong>：单位时间内从存储器读出的二进制数信息量，一般用字节数&#x2F;秒表示。</li>
<li><strong>主频&#x2F;时钟周期</strong>：CPU 的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟度量单位是 MHz、GHz</li>
</ul>
<p>主频的倒数称为 CPU 时钟周期（T），T&#x3D;1&#x2F;f，度量单位是 μs、ns。</p>
<p>K&#x3D; 103 ，M&#x3D; 106 ，G&#x3D; 109</p>
<p>易错：时钟频率的提高，不能保证CPU执行速度又同倍速的提高，有时候还会减慢。</p>
<ul>
<li><strong>CPU 执行时间</strong>：表示 CPU 执行一般程序所占用的 CPU 时间，可用下式计算：</li>
</ul>
<p>CPU 执行时间 &#x3D; CPU 时钟周期数 * CPU 时钟周期</p>
<ul>
<li><strong>CPI</strong>：执行一条指令所需的平均时钟周期数。用下式计算：</li>
</ul>
<p>CPI &#x3D; 执行某段程序所需的 CPU 时钟周期数 &#x2F; 程序包含的指令条数</p>
<ul>
<li><strong>MIPS</strong>：（Million Instructions Per Second）的缩写，表示平均每秒执行多少百万条定点指令数，用下式计算：</li>
</ul>
<p>MIPS &#x3D; 指令数 &#x2F; （程序执行时间 * 10^6）</p>
<ul>
<li><strong>FLOPS</strong>：（Floating-point Operations Per Second）的缩写，表示每秒执行浮点操作的次数，用来衡量机器浮点操作的性能。用下式计算：FLOPS &#x3D; 程序中的浮点操作次数 &#x2F; 程序执行时间（s）</li>
</ul>
<h3 id="题目总结："><a href="#题目总结：" class="headerlink" title="题目总结："></a>题目总结：</h3><p>①对于<strong>高级</strong>语言程序员来说，浮点数格式、乘法指令、数据如何在运算器中运算时透明的。对于<strong>汇编语言</strong>程序员，指令格式，机器构造，数据格式则不是透明的。</p>
<p>②在CPU中，IR、MAR、MDR对各类程序员都是透明。</p>
<p>③机器字长，指令字长，存储字长</p>
<p>机器字长也称字长——是计算机直接处理二进制数据的位数，机器字长一半等于内部寄存器的大小，它决定了计算机的运算精度。</p>
<p>指令字长——一个指令中包含的二进制代码的位数。</p>
<p>存储字长——一个存储单元中二进制代码的长度。</p>
<p>指令字长一般是存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取值周期为机器周期的2倍；若指令字长等于存储字长，则取值周期等于机器周期的。</p>
<h2 id="第二章-数据的表示和运算"><a href="#第二章-数据的表示和运算" class="headerlink" title="第二章 数据的表示和运算"></a>第二章 数据的表示和运算</h2><p>一、无符号整数的表示和运算</p>
<p>Ⅰ、无符号整数的加法：从最低位开始，按位相加，并往更高位进位。</p>
<p>Ⅱ、”被减数“不变，”减数“<strong>全部按位取反</strong>，末位+1，<strong>减法变加法。</strong></p>
<p>二、带符号整数的表示和运算</p>
<p>带符号的整数表示：原码、补码、反码</p>
<p>※带符号的整数运算可以用原码吗？</p>
<p>用原码的话符号位不能参与运算，需要设计复杂的硬件电路才能处理，贵。</p>
<p>这时候就可以利用补码来进行带符号的整数运算。</p>
<p>①涉及原码和补码的转化。</p>
<p>正数：原码-&gt;补码，不变</p>
<p>负数：原码-&gt;补码，除符号位外，各位取反，末位+1</p>
<p>Ⅰ、补码的加法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-e9d73f22bbb9bd56cd52788979fcff57_720w.webp" alt="img"></p>
<p>从最低位开始，然后按位相加，并往高位进位。算出来的结果，转回原码，就可以得到正值。</p>
<p>补充：补码-&gt;原码：类似，除符号位外，各位取反，末位+1</p>
<p>Ⅱ、补码的减法</p>
<p>※加法电路造价便宜，减法电路造价昂贵，若将减法变为加法，更加economize。</p>
<ul>
<li>那我们知道了”减数“的补码，那如何求得”减数“负值的补码呢？</li>
</ul>
<p>补码<strong>全部位</strong>取反，末位+1（易错这里是全部位取反，而带符号位的负数，是除符号位外，各位取反）</p>
<p>其实啊，这里的运算的逻辑结构和无符号的减法运算是一样的，通用一套电路，省钱！</p>
<p>三、原码、反码和补码的特性对比</p>
<table>
<thead>
<tr>
<th>8bit</th>
<th>合法的表示范围</th>
<th>最大的数</th>
<th>最小的数</th>
<th>真值0的表示</th>
</tr>
</thead>
<tbody><tr>
<td>带符号原码</td>
<td>-127~127</td>
<td>127</td>
<td>-127</td>
<td>+0&#x3D;00000000 -0&#x3D;10000000</td>
</tr>
<tr>
<td>带符号反码</td>
<td>-127~127</td>
<td>127</td>
<td>-127</td>
<td>+0&#x3D;00000000 -0&#x3D;11111111</td>
</tr>
<tr>
<td>带符号补码</td>
<td>-128~127</td>
<td>127</td>
<td>-128</td>
<td>-&#x2F;+0&#x3D;00000000 只有这一种</td>
</tr>
<tr>
<td>无符号整数</td>
<td>0~255</td>
<td>255</td>
<td>0</td>
<td>00000000</td>
</tr>
<tr>
<td>带符号移码</td>
<td>-128~127</td>
<td>127</td>
<td>-128</td>
<td>0&#x3D;10000000 只有这一种</td>
</tr>
</tbody></table>
<p>原码和反码的合法表示范围完全相同，而且都有两种表示真值0的方法。</p>
<p>补码的合法表示范围多一个负数，原因就是只有一种0的表示方法，因为-0的补码就是00000000</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-5599be316c1aae1b8618fa0cde826632_720w.webp" alt="img"></p>
<p>四、移码，定点小数</p>
<p>移码：在补码的基础上符号位取反。且移码只能表示整数。表示范围和补码相同。</p>
<p>移码的作用：<em>移码的作用就是方便计算机比较两个数数值的大小。</em></p>
<p>定点小数的编码表示：原码、反码、补码。</p>
<p>运算规则和整数的运算规则一模一样。</p>
<p>五、电路的基本原理和加法器设计</p>
<p>Ⅰ、补码&#x2F;无符号整数加减法运算器</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-ea35ee2801583ba73372d324e077841d_720w.webp" alt="img"></p>
<p>减法运算过程：</p>
<p>①首先Sub信号置为1；</p>
<p>②多路选择器的值为1，Y（减数）经过非门，都取反；</p>
<p>③cin来自低位加1；</p>
<p>Ⅱ、标志位生成</p>
<p>①进位标志CF (Carry Flag)只对无符号运算有意义<br>当运算结果的最高有效位有进位（加法）或借位（减法）时，进位标志置1，</p>
<p>即CF &#x3D; 1；否则CF&#x3D; 0。</p>
<p>49H + 6DH＝B6H，　没有进位：CF &#x3D; 0</p>
<p>BBH + 6AH＝（1）25H，有进位：CF &#x3D; 1</p>
<p>②零标志ZF (Zero Flag)<br>若运算结果为0，则ZF &#x3D; 1；否则ZF &#x3D; 0</p>
<p>49H + 6DH＝B6H，结果不是零：ZF &#x3D; 0</p>
<p>75H + 8BH＝（1）00H，结果是零：ZF &#x3D; 1</p>
<p>③符号标志SF (Sign Flag)只对有符号运算有意义<br>运算结果最高位为1，则SF &#x3D; 1；否则SF &#x3D; 0</p>
<p>49H + 6DH＝B6H&#x3D;10110110B，SF&#x3D;1</p>
<p>④溢出标志OF (Overflow Flag)只对有符号运算有意义<br>若算术运算的结果有溢出，则OF＝1；否则 OF＝0</p>
<p>49H + 6DH ＝B6H，产生溢出：OF &#x3D; 1</p>
<p>75H + 8BH ＝（1）26H，没有溢出：OF &#x3D; 0</p>
<p>进位CF和溢出OF位有什么区别呢？</p>
<p>进位标志表示无符号数运算结果是否超出范围，运算结果仍然正确，对有符号位加减法无意义。</p>
<p>溢出标志表示有符号数运算结果是否超出范围，运算结果已经不正确，对无符号加减无意义。</p>
<p>溢出的判断判断运算结果是否溢出有一个简单的规则：</p>
<p>只有当两个相同符号数相加（包括不同符号数相减），而运算结果的符号与原数据符号相反时，产生溢出；因为，此时的运算结果显然不正确其他情况下，则不会产生溢出</p>
<p>1.当两个符号相同的数相加，结果的符号与之相反，则OF&#x3D;1,否则OF&#x3D;0.</p>
<p>2.当两个符号不同的数相减，结果的符号与减数相同，则OF&#x3D;1,否则OF&#x3D;0.</p>
<p>六、定点数的移位运算</p>
<ul>
<li>左移1位相当于×2，右移1位相当于÷2</li>
<li>原码：符号位不参与移位。左移，右移都补0</li>
<li>反码：符号位不参与移位。<strong>若反码是负数补1；若反码是正数补0</strong></li>
<li>补码：符号位不参与移位。<strong>若补码是负数左移低位补0，右移高位补1；若补码是正数，左移右移都补0</strong></li>
</ul>
<p>七、原码补码的乘法除法运算</p>
<p>Ⅰ、原码的一位乘法</p>
<p>符号位通过异或确定；数值部分通过被乘数和乘数绝对值的n轮加法、移位完成，根据当前乘数中参与运算的位确定（ACC）加什么。若当运算位&#x3D;1，则（ACC）+[|x|],若为0，则(ACC)+1。每轮加法完成后，ACC,MQ的内容统一逻辑右移。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-391e106f8411d22834924628fce767cc_720w.webp" alt="img"></p>
<p>先ACC初始化。x置于通用寄存器中，y置于MQ。</p>
<p>Ⅱ、补码的一位乘法</p>
<p>原码一位乘法和补码一位乘法的不同点</p>
<table>
<thead>
<tr>
<th>原码一位乘法</th>
<th>补码一位乘法</th>
</tr>
</thead>
<tbody><tr>
<td>进行n轮的加法、移位</td>
<td>进行n轮加法，移位，最后再多来一次加法</td>
</tr>
<tr>
<td>每次加法相加，只有两种情况+0或加x</td>
<td>每次加法加有三种情况，0或+x或+[-x]</td>
</tr>
<tr>
<td>每次移位都是逻辑右移，补1</td>
<td>每次都是补码的右移，正数右移补0，负数右移补1</td>
</tr>
<tr>
<td>符号位不参与运算</td>
<td>符号位参与运算</td>
</tr>
</tbody></table>
<ul>
<li>会添加一位辅助位</li>
<li>辅助位-MQ中“最低位”&#x3D;1时，(ACC)+[X)]补</li>
<li>辅助位-MQ中“最低位”&#x3D;0时，(ACC)+0</li>
<li>辅助位-MQ中“最低位”&#x3D;-1时，(ACC)+[-X]补</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-2893d67d4084b3376497e97a8eb18f31_720w.webp" alt="img"></p>
<p>八、C语言类型转换和数据存储排列</p>
<ul>
<li>C语言中定点整数是用”补码“存储的。</li>
<li>无符号数转为有符号数：不改变数据内容，改变解释方式。</li>
<li>长整数变为短整数：高位截断，保留低位。</li>
<li>短整数变长整数：若为有符号数，在符号位和数值位添1，若为无符号，直接在高位添0。</li>
<li>大小端模式：大端方式便于人类阅读；小段方式便于机器处理，因为机器最先读入的就是最应被处理的数据。</li>
<li>边界对齐：假设存储字长为32位，则1个字&#x3D;32bit,半字&#x3D;16bit。每次访存只能读&#x2F;写1个字。若采用边界对齐的方式，则访问一个字&#x2F;半字都需要一次访存，虽然会造成一点点的空间浪费。采用不对齐的方式，对空间利用率高，但是可能会涉及到两次访存时间大大增加。</li>
</ul>
<p>九、浮点数的表示和运算</p>
<p>Ⅰ、概念：之前我们学习了定点数，其中「定点」指的是约定小数点位置固定不变。那浮点数的「浮点」就是指，其小数点的位置是可以是<strong>漂浮不定</strong>的。</p>
<p>Ⅱ、表示：阶符表示的是阶码正负，尾数的数符表示的是尾数正负。</p>
<p>阶码：常用补码或移码表示的定点整数，反映表示范围。</p>
<p>尾数：常用原码或补码表示的定点小数，反映精度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-a33b270ce33f2c1941135149253f12c3_720w.webp" alt="img"></p>
<p>Ⅲ、<strong>规格化：规定尾数的最高位必须是有效位</strong>。</p>
<p>①”有效位“又分两种情况。分为尾数是补码表示还是原码表示</p>
<p>原码表示的尾数视格化：<strong>尾数的最高数值位必须是1</strong></p>
<p>补码表示的尾数规格化：<strong>尾数最高数值位必须和尾数符号位相反</strong></p>
<p>②左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码减1。</p>
<blockquote>
<p>b&#x3D; 22×(+0.01001)&#x3D;21×(+0.10010) #尾数最高位为0，左规</p>
</blockquote>
<p>右规：当<strong>浮点数运算的结果尾数出现溢出（双符号位为01或10）时</strong>，将尾数算数右移一位，阶码加1。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-752d22af369fc6e9b81a2d0aaaea880f_720w.webp" alt="img"></p>
<p>采用双符号位，当发生溢出时（双符号位为01或10），可以采用右规，更高位的符号位是正确的符号位。</p>
<p>③虽然浮点数的范围和精度也有限，但其范围和精度都已非常之大，所以在计算机中，对于小数的表示我们通常会使用浮点数来存储。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-8acb78c4e63abb8a46248012d48d880d_720w.webp" alt="img"></p>
<p>十、IEEE 754</p>
<p>背景：在浮点数提出的早期，各个计算机厂商各自制定自己的浮点数规则，导致不同厂商对于同一个数字的浮点数表示各不相同，在计算时还需要先进行转换才能进行计算。后来 IEEE 组织提出了浮点数的标准，统一了浮点数的格式，并规定了单精度浮点数 float 和双精度浮点数 double，从此以后各个计算机厂商统一了浮点数的格式，一直延续至今。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-c3a75e79d45d887b84a5f25f50b38906_720w.webp" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-6c230c6c155cc19c71654f99d4cc65b7_720w.webp" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-d945a91caf4fa11ce472acbc8af7adb6_720w.webp" alt="img"></p>
<p>十一、浮点数运算（重点）</p>
<p>现代计算机表示数的方法通常都是浮点数了，所以这节很重要。</p>
<p>①对阶：小阶向大阶靠齐，方便计算机对尾数进行处理。</p>
<p>②尾数加减：尾数常规加减。</p>
<p>③规格化：如果尾数加减出现类似0.0099517× 1012 时，需要“左规”；</p>
<p>如果尾数加减出现类似99.517107× 1012 时，需要“右规”。</p>
<p>④舍入：尾数位数有限，若规定只能保留6位有效尾数，则9.9517107× 1012 →9.95171× 1012 (多余的直接砍掉)或者，9.9517107× 1012 →9.95172× 1012 （若砍掉分非0，则入1)或者，也可以采用四舍五入的原则，当舍弃位≥5时，高位入1。</p>
<p>⑤判溢出：若规定阶码不能超过两位，则运算后阶码超出范围，则溢出。</p>
<p>如：9.85211× 1099 +9.96007× 1099 &#x3D;19.81218× 1099 规格化并用四舍五入的原则保留6位尾数，得1.98122× 10100 ,阶码超过两位，溢出。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-6d338dce25cad304ddea223a2e1c3581_720w.webp" alt="img"></p>
<p>强制类型转化：</p>
<p>无损：char-&gt;int-&gt;long-&gt;double</p>
<p>float-&gt;double</p>
<p>有损：int-&gt;float,可能会损失精度</p>
<p>float-&gt;int，可能会溢出，也可能会损失精度</p>
<h2 id="第三章-存储系统"><a href="#第三章-存储系统" class="headerlink" title="第三章 存储系统"></a>第三章 存储系统</h2><h3 id="第一节-存储器概述"><a href="#第一节-存储器概述" class="headerlink" title="第一节 存储器概述"></a>第一节 存储器概述</h3><p>一、存储器的层次结构</p>
<p>寄存器-&gt;Cache-&gt;主存-&gt;辅存-&gt;外存</p>
<p>Cache-主存：解决了主存与CPU速度不匹配的问题。</p>
<p>主存-辅存：实现虚拟存储系统，解决了主存容量不够的问题。</p>
<p>※辅存中的数据要调入到主存才能被CPU访问</p>
<p>二、存储器的分类</p>
<p>Ⅰ、按照存取方式：分为随机存取存储器（RAM），如内存；顺序存取存储器（SAM），如磁带；直接存取存储器（DAM），如磁盘；相联存储器（可按内容访问的存储器，CAM），如快表。</p>
<p>Ⅱ、按信息是否可改：分为读&#x2F;写存储器和只读存储器（ROM）</p>
<p>Ⅲ、断电后是否消失：分为易失性存储器，如内存、Cache；非易失性存储器，如磁盘、光盘</p>
<p>三、存储器的性能指标</p>
<p>1.存储容量：存储字数×字长</p>
<p>2.单位成本：每位价格&#x3D;总成本&#x2F;总容量</p>
<p>3.存储速度：数据传输率&#x3D;数据的宽带&#x2F;存储周期</p>
<p>存储周期&#x3D;存取时间+恢复时间</p>
<h3 id="第二节-主存储器"><a href="#第二节-主存储器" class="headerlink" title="第二节 主存储器"></a>第二节 主存储器</h3><p>一、SRAM和DRAM</p>
<p>一个静态RAM，一个动态RAM。动态的用于主存，静态的用于Cache</p>
<p>SRAM和DRAM的差别</p>
<table>
<thead>
<tr>
<th>类型特点</th>
<th>SRAM</th>
<th>DRAM</th>
</tr>
</thead>
<tbody><tr>
<td>存储信息</td>
<td>触发器</td>
<td>电容</td>
</tr>
<tr>
<td>破坏性读出</td>
<td>非</td>
<td>是</td>
</tr>
<tr>
<td>读出后是否需要重写</td>
<td>不用</td>
<td>需要</td>
</tr>
<tr>
<td>运行速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>集成度</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>发热量</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td>存储成本</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>是否易失</td>
<td>易失</td>
<td>易失</td>
</tr>
<tr>
<td>是否需要刷新</td>
<td>不需要</td>
<td>需要</td>
</tr>
<tr>
<td>作用</td>
<td>常用作Cache</td>
<td>常用作主存</td>
</tr>
</tbody></table>
<p>二、ROM只读存储器</p>
<p>RAM芯片——易失性，断电后数据消失</p>
<p>ROM芯片——非易失性，断电后数据不会消失</p>
<p>①MROM——掩模式只读存储器：任何人都不可重写</p>
<p>②PROM——可编程只读存储器：写一次后就不可更改</p>
<p>③EPROM——可擦除可编程只读存储器：可进行多次重写，写入时间很长</p>
<p>④Flash Memory——闪速存储器：可进行多次快速擦除重写，但写的速度比读的速度慢</p>
<p>⑤SSD——固态硬盘：可进行多次快速擦除重写，目前个人电脑大都市这种。速度快，功耗低，价格高。</p>
<h3 id="第三节-主存储器与CPU的连接"><a href="#第三节-主存储器与CPU的连接" class="headerlink" title="第三节 主存储器与CPU的连接"></a>第三节 主存储器与CPU的连接</h3><p>一、单块存储器与CPU连接</p>
<p>Ⅰ、连接原理：主存器通过数据总线，地址总线和控制总线与CPU连接。</p>
<p>地址总线的位数决定了可寻址的最大内存空间。</p>
<p>控制总线指出总线周期类型和本次输入输出操作完成的时刻。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-eb7b6cf42b14d9175b741d581365c965_720w.webp" alt="img"></p>
<p>主存储器的线路</p>
<p>二、多块存储器与CPU连接</p>
<p>Ⅰ、位扩展法</p>
<p>原理：CPU的数据线与存储芯片的数据位数不相等，此时必须使用多个存储器件对字长进行扩位。每个存储器的数据线都并行连接在CPU的数据总线上，而地址位数是串行相连。那CPU传一个地址过来，怎么知道是使用哪个存储芯片呢，此时就要WE来控制使用哪个存储芯片。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-e226ddea6ccd4cc021ac8560cf82e77e_720w.webp" alt="img"></p>
<p>Ⅱ、字扩展法</p>
<p>原理：当主存储器位数不足，字数足够时，我们会通过位扩展的方法来扩展主存储器，将多个字数相同的存储芯片并联起来，增加位数，并且存储空间是连续的。里面还会涉及译码器，主要功能就是增加控制存储器的个数，如有两位地址线连接了译码器，那么译码器可以控制 22 个存储器。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-02a88dd94b7a0072f1ef0359fe4b63e7_720w.webp" alt="img"></p>
<table>
<thead>
<tr>
<th>线选法</th>
<th>译码片选法</th>
</tr>
</thead>
<tbody><tr>
<td>n条线n个片选信号</td>
<td>n条线2的n次方个片选信号</td>
</tr>
<tr>
<td>电路简单</td>
<td>电路复杂</td>
</tr>
<tr>
<td>地址不连续（两位举例，00和11的地址用不到）</td>
<td>地址连续（00和11的地址也都用到了）</td>
</tr>
</tbody></table>
<p>Ⅲ、字位同时扩展</p>
<p>原理：而当字数和位数都不足时，我们会通过字位同时扩展的方法来扩展存储器，将多个字数和位数都相同的存储芯片连接起来，同时增加字数和位数。</p>
<p>Ⅳ、三者比较</p>
<p>字扩展方法只能增加主存储器的容量，存取速度没有提升。而位扩展方法不光可以增加主存储器的容量，同时还可以让多个存储芯片同时工作，同时做读写操作，增加了存取速度。字位同时扩展的方法又可以增加主存储器的容量，又可以让多个存储芯片同时工作，那么是不是只用字位同时扩展这一种方法就可以了呢？任何事情都是有利弊两面性的，在能力增强的同时，他的成本，功耗和体积都会增加，所以我们还是要根据实际的系统需求来判断具体使用的主存储器扩展方法。</p>
<p>Ⅴ、题目总结</p>
<p>【2018统考真题】假定DRAM芯片中存储阵列的行数为r、列数为c,对于一个2K×1位的DRAM芯片，为保证其地址引脚数最少，并尽量减少刷新开销，则r、c的取值分别是()。</p>
<p>解：r是行，c是列，为了保证地址引脚数最少，就要求，行列相差小，并且减少刷新开销，则要求行数越小越好。故最终行数位32，列数位64。</p>
<p>三、多模块存储器</p>
<p>背景：随着CPU的功能不断增强，I&#x2F;O设备数量不断增多，这也导致了主存的存取速度已成为计算机系统的发展瓶颈。为了解决此问题，除了寻找更高速的原件和采用存储器层次结构外，调整主存的结构也可以提高访存速度，这就涉及到了多模块存储器。</p>
<p>由于取值周期&#x3D;存取时间+恢复时间。DRAM芯片恢复时间较短，有可能是存取时间的几倍。那怎么半，不能让设备停着吧。那太浪费资源了。</p>
<p>Ⅰ、双端口RAM</p>
<p>顾名思义，就是利用两个端口实现多核CPU存储，需要有两组完全独立的数据线，地址线，控制线。支持两个CPU同时访问。</p>
<p>两个端口可以同时对不同单元的地址中取数据，也可以对同一地址单元中读出数据，但是不行同时对同一单元中写入数据，也不能对同一单元一边读一边写入数据。</p>
<p>解决办法：发出”busy“信号，其中一个CPU的访问端口暂时关闭。</p>
<p>Ⅱ、单体多字存储器</p>
<p>原理：原来每行只存放一个存储字，变为每行存放多个存储字，这样原来一次只能读取一个存储字，变为一次能读取多个存储字，这需要数据总线根数变大。</p>
<p>限制：指令和数据在主存必须是连续存放的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-2081a3ed77b1b86bec4cf0e7c0b04b71_720w.webp" alt="img"></p>
<p>Ⅲ、多体并行存储器（重点）</p>
<p>原理：每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路，地址<a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?q=%E5%AF%84%E5%AD%98%E5%99%A8&spm=1001.2101.3001.7020">寄存器</a>，和数据寄存器，既能并行工作，又能交叉工作（一个模块进入恢复时间，另一个模块进行存取）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-ad7b439961372bdb3c1d340ba39c5d18_720w.webp" alt="img"></p>
<p>区别：在高位交叉中，由于下一个访问的地址还是在这个存储体上，所以必须等到恢复时间结束后才能继续访问，故不能并行访问。效果也仅仅是扩容。而在低位交叉编制中，下一个访问地址不在同一个存储体上，所以可以交叉访问，不仅扩容还加快了访问速度。当块数m ≥ T&#x2F;r时，能达到最佳存储效率。T为存取周期，r为存取时间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-eb9c1f45b40f9101b1f4f4793b4a9404_720w.webp" alt="img"></p>
<h3 id="第四节-外部存储器"><a href="#第四节-外部存储器" class="headerlink" title="第四节 外部存储器"></a>第四节 外部存储器</h3><p>一、磁盘存储器</p>
<p>优点：存储容量大，价格低，长期保存而不丢失。</p>
<p>缺点：存取速度慢，机械结构复杂，对环境要求高。</p>
<p>磁盘最小的读写单位是一个扇区。</p>
<p>二、固态存储器SSD（新增考点）</p>
<p>优点：读写速度快。若要写的页有数据，则不能写入，需要将块内其他页全部复制到一个新的块中，再写入新的页。</p>
<p>缺点：价格高，一个块被写入多次可能会坏掉（采用平均磨损，对我们来说仍然很耐用）而磁盘不会。</p>
<h3 id="第五节-高速缓冲存储器（重点）"><a href="#第五节-高速缓冲存储器（重点）" class="headerlink" title="第五节 高速缓冲存储器（重点）"></a>第五节 高速缓冲存储器（重点）</h3><p>一、什么是Cache，为什么要引入Cache？</p>
<p>Cache存储器也被称为高速缓冲存储器，位于CPU和主存储器之间。之所以在CPU和主存之间要加cache是因为现代的CPU频率大大提高，内存的发展已经跟不上CPU访存的速度。在2001 – 2005年间，处理器时钟频率以每年55%的速度增长，而主存的增长速度只是7%。<strong>在现在的系统中，处理器需要上百个时钟周期才能从主存中取到数据。如果没有cache，处理器在等待数据的大部分时间内将会停滞不动</strong>。</p>
<p>二、原理</p>
<p>采用了程序访问的时间局部性原理和空间局部性原理</p>
<p>时间局部性：<strong>如果一个数据现在被访问了，那么以后很有可能也会被访问</strong></p>
<p>空间局部性：<strong>如果一个数据现在被访问了，那么它周围的数据在以后可能也会被访问</strong></p>
<p>三、多级Cache的由来？</p>
<p>cache分为L1，L2，L3甚至L4等多级。为什么不能把L1的容量做大，不要其它的cache了？原因在于性能&#x2F;功耗&#x2F;面积（PPA）权衡考虑。L1 cache一般工作在CPU的时钟频率，要求的就是够快，可以在2-4时钟周期内取到数据。L2 cache相对来说是为提供更大的容量而优化的。虽然L1和L2往往都是SRAM，但构成存储单元的晶体管并不一样。L1是为了更快的速度访问而优化过的，它用了更多&#x2F;更复杂&#x2F;更大的晶体管，从而更加昂贵和更加耗电；L2相对来说是为提供更大的容量优化的，用了更少&#x2F;更简单的晶体管，从而相对便宜和省电。在有一些CPU设计中，会用DRAM实现大容量的L3 cache。</p>
<p>四、如何区分Cache和主存的数据块对应关系？</p>
<p>每次被访问的主存块，一定会被立即调入Cache，而且是以块为单位进行调入。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-0f70d191adbfc39a630028975a91c9e9_720w.webp" alt="img"></p>
<p>那是采用什么方式将主存块号调入到Cache呢？有三种方式</p>
<p>①全相联映射——主存块可以放在Cache的任意位置。</p>
<p><strong>那它是如何来访问主存的呢？</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-dac5bfcf4320627d7382756d787e9282_720w.webp" alt="img"></p>
<p>对以上图只要能看懂，对于全相联映射就没什么问题了。做几点说明，CPU在访问主存时，会先对比Cache所有块中的标记Tag，Tag就是在主存中的主存块号，占22位。</p>
<p>②直接映射——每个主存块只能放在一个特定的位置。Cache块号&#x3D;主存块号%Cache块总数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-3281b09fe554d06d1f0a7c3582a5a65a_720w.webp" alt="img"></p>
<p>做以下几点说明</p>
<ul>
<li>相对于全相联映射，直接映射对<strong>Tag进行了优化</strong>，因为主存块号最后三位地址就是Cache中的位置，所以将主存块号其余位作为标记即可。</li>
<li>若Cache总块数&#x3D; 2� ,则主存块号末尾n位直接反映它在Cache的位置，所以将主存块号其余位作为标志位即可。</li>
</ul>
<p>③组相联映射——Cache块分为若干组，每个主存块可以放到特定分组中的任意一个位置。组号&#x3D;主存块号%分组数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-472544d30167b0d77932054da9636e3d_720w.webp" alt="img"></p>
<p>做以下几点说明</p>
<ul>
<li>相对于全相联映射，直接映射对<strong>Tag进行了优化</strong>，因为主存块号最后两位地址就是Cache中的位置，所以将主存块号其余位作为标记即可。</li>
<li>一个组内有几个Cache块就成为几路相联映射</li>
</ul>
<p>④三种映射方法对比总结</p>
<table>
<thead>
<tr>
<th></th>
<th>全相联</th>
<th>直接</th>
<th>组相联</th>
</tr>
</thead>
<tbody><tr>
<td>特点</td>
<td>任意位置</td>
<td>特定位置</td>
<td>分组中的任意位置</td>
</tr>
<tr>
<td>主存地址结构</td>
<td>标记+块内地址</td>
<td>标记+行号+块内地址</td>
<td>标记+组号+块内地址</td>
</tr>
<tr>
<td>优点</td>
<td>Cache存储空间利用充分</td>
<td>对任意地址，执行对比一个Tag，速度快</td>
<td>折中办法</td>
</tr>
<tr>
<td>缺点</td>
<td>可以会对比所有行的标记，速度慢</td>
<td>Cache空间利用不充分</td>
<td>&#x2F;</td>
</tr>
</tbody></table>
<p>五、Cache很小，而主存很大，如果Cache满了，是利用了什么替换算法？</p>
<p>替换条件：对于全相联映射，需要在全局中选择替换哪一块，对于直接映射，若非空，则直接替换，对于组相联，组内满了，则在组内选择替换哪一块。</p>
<p>Ⅰ、随机算法(RAND)</p>
<p>随机，随便，随意，换哪一个都行。实现简单，但完全没有考虑局部性原理，命中率低，实际效果很不稳定。</p>
<p>可能会导致，换出的块，下一次又需要访问。就会多次访问内存块。导致抖动现象。</p>
<p>Ⅱ、先进先出算法(FIFO)</p>
<p>替换最先进入的块。同样实现简单，但仍然没有考虑到局部性原理，最先被调入Cache块可能是被访问最频繁的。</p>
<p>Ⅲ、近期最少使用(LRU)</p>
<p>为每个Cache块设置一个”计数器“，用于记录每个Cache块多久没有被访问了。然后替换”计数器“值最大的。</p>
<ul>
<li>计数器的位数&#x3D;Cache块的总数&#x3D; 2� ，只需要n位，且Cache装满后所有计数器的值一定不重复。</li>
<li>基于局部性原理，近期被访问的主存块，未来可能仍会被使用，LRU算法实际运行效果优秀。</li>
<li>若频繁访问的主存块数量&gt;Cache行的数量，则有可能发生”抖动“</li>
</ul>
<p>Ⅳ、最近不经常使用(LFU)</p>
<p>为每个Cache设置一个”计数器“，用于记录Cache被访问过几次，然后替换”计数器“值最小的（访问次数最少的）</p>
<p>曾经被经常访问的主存块不一定在未来会被用到。并没有很好的遵循局部性原理，因此实际运行效果不如LRU。</p>
<p>六、Cache写策略——CPU修改了Cache中的数据副本，如何确保主存中数据母本一致性？</p>
<p>Ⅰ、写命中——写入的时候，在Cache中</p>
<p>①回写法：当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当次块被换出时才写回主存。减少了访存次数，但存在数据不一致的隐患。</p>
<p>被换出时，看”脏位“是否知道是否被修改。</p>
<p>②全写法：当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲。访存次数增加，速度变慢，但是能保证数据的一致性。无脏位。</p>
<p>Ⅱ、写不命中——写入的时候，不在Cache中</p>
<p>①写分配法——当CPU对Cache不命中时，把主存中的块调入Cache，在Cache中修改。通常搭配<strong>回写法</strong>使用，改完后要被换出，才在主存中修改。</p>
<p>②非写分配法——当CPU对Cache写不命中时，只写入主存，不调入Cache，搭配全写法使用。</p>
<h3 id="第六节-虚拟存储器"><a href="#第六节-虚拟存储器" class="headerlink" title="第六节 虚拟存储器"></a>第六节 虚拟存储器</h3><p>虚拟存储器：在操作系统的管理下，只把当前需要的部分数据调入主存，暂不需要的部分留在辅存中。在用户看来，似乎获得了一个超大的主存。（虚拟性）</p>
<p>一、页式虚拟存储器</p>
<p>背景：CPU执行的机器指令中，使用的是”逻辑地址“，因此需要通过”页表“将逻辑地址转为物理地址。</p>
<p>一个程序在逻辑上被分为若干个大小相等的”页面“，”页面“大小与”块“的大小相同。每个页面可以离散的存放在不同主存块中。</p>
<p>页表的作用：记录了每个逻辑页面存放在哪个主存块中。</p>
<p>无快表：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-21fdfa251e8eb343e068c88d0b9f29aa_720w.webp" alt="img"></p>
<ul>
<li>逻辑地址&#x3D;逻辑页号+页内地址</li>
<li>物理地址&#x3D;主存块号+页内地址</li>
</ul>
<p>增加快表（存放在Cache中，先访问快表，若未命中，则去访问主存中的慢表）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-50e00a292c05bed40918aa296e075da5_720w.webp" alt="img"></p>
<ul>
<li>快表查询速度很快，若快表中无，则会去慢表中查找，会把相应的内容存入快表中</li>
</ul>
<p><strong>清楚整个查找流程</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-b465572e1822271d789a22a4df05abc5_720w.webp" alt="img"></p>
<p>二、段式虚拟存储（按功能拆分成大小不同的模块）</p>
<p>按照功能模块拆分不同的模块大小。</p>
<p>虚拟地址：段号+段内地址</p>
<p>优点：段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护。</p>
<p>缺点：段的长度可变，分配空间不便，容易留下碎片，不好利用，造成浪费。</p>
<p>三、段页式虚拟存储</p>
<p>把程序按逻辑结构分段，每段在分固定大小的页，主存空间也划分为大小相等的页，每个程序对应一个段表，每段对应一个页表。</p>
<p>虚拟地址：段号+段内地址+页内地址</p>
<p>优点是兼具段式和页式的优点缺点是需要查两次表，系统开销较大。</p>
<p>四、虚拟存储器与Cache的比较</p>
<table>
<thead>
<tr>
<th>Cache</th>
<th>虚拟存储器</th>
</tr>
</thead>
<tbody><tr>
<td>解决CPU与主存速度不匹配的问题</td>
<td>解决主存容量的问题</td>
</tr>
<tr>
<td>全由硬件组成，对所有程序员透明</td>
<td>由OS和硬件组成，逻辑上存储器对系统程序员不透明</td>
</tr>
<tr>
<td>不命中影响小</td>
<td>不命中影响大</td>
</tr>
<tr>
<td>不命中时，主存直接与CPU通信</td>
<td>不命中时，不能直接和CPU通信，要先硬盘调入主存</td>
</tr>
</tbody></table>
<h3 id="题目总结：-1"><a href="#题目总结：-1" class="headerlink" title="题目总结："></a>题目总结：</h3><p>【2015统考真题】假定主存地址为32位，按字节编址，主存和Cache之间采用直接映射方式，主存块大小为4个字，每字32位，采用回写方式，则能存放4K字数据的Cache的总容量的位数至少是()</p>
<ul>
<li>Cache的容量分为两个部分一个是数据存储容量+标记阵列容量</li>
<li>标记阵列中一定包含有效位和标记位，若为回写法，则还存在一位的”脏位“，若为LRU、LFU替换算法，则还存在替换算法位（计数器）位数为 ���2� ,n为Cache的个数。</li>
<li>本题按照字节编址，则块内地址占4位，采用直接映射方法中的标志位为32-4-10&#x3D;18，Tag&#x3D;18。</li>
<li>采用回写法，有一位脏位，故最终标记项有18+1+1&#x3D;20</li>
<li>标记阵列容量为 210 ×20&#x3D;20K，数据储存容量为4K×32&#x3D;128K，故总的为148K。</li>
</ul>
<h2 id="第四章-指令系统"><a href="#第四章-指令系统" class="headerlink" title="第四章 指令系统"></a>第四章 指令系统</h2><h3 id="第一节-指令格式"><a href="#第一节-指令格式" class="headerlink" title="第一节 指令格式"></a>第一节 指令格式</h3><p>指令概念：又称机器指令，是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。</p>
<p>一条指令就是机器语言的一个语句，一条指令通常要包括操作码和地址码两部分：操作码主要指明用户干什么，地址码主要指明对谁操作。</p>
<p>一、指令分类</p>
<p>按操作数个数分：</p>
<p>Ⅰ、零地址指令：不需要操作数，如空操作、停机、关中断等指令</p>
<p>Ⅱ、一地址指令：只需要单个操作数，如自增，自减，取反，求补，需要两个操作数，但其中一个隐含在某个寄存器中</p>
<p>Ⅲ、二地址指令：常用于两个操作数的算术运算、逻辑运算相关指令。</p>
<p>完成一条指令需要访存四次，分别为取值，读第一个操作数，读第二个操作数，写回第一个操作数。</p>
<p>Ⅳ、三地址指令：常用于两个操作数的计算，结果放在第三个地址中。</p>
<p>完成一条指令需要访存四次，分别为取值，读读一个操作数，读第二个操作数，写到第三个操作数。</p>
<p>※若指令长度不变，地址码数量越多，寻址能力就越差</p>
<p>按指令长度是机器指令的多少倍分：</p>
<p>Ⅰ、半长指令：是机器指令长度一半</p>
<p>Ⅱ、单字长指令：与机器指令长度一样</p>
<p>Ⅲ、双字长指令：是机器指令长度两倍</p>
<p>二、扩展操作码指令格式（考点：会设计指令系统）</p>
<p>概念：指令是定长的，但是操作码的长度可变。</p>
<p>通常情况下，使用频率高的指令使用短的操作码，减少指令译码和分析的时间。而使用频率低的指令使用长的操作码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-be3a17c0e449bcb3b40d118da740ade5_720w.webp" alt="img"></p>
<p>定长指令和扩展操作码的比较</p>
<table>
<thead>
<tr>
<th></th>
<th>定长操作码</th>
<th>扩展操作码</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>硬件设计简单，识别速度快</td>
<td>在指令长度限制下仍有丰富指令</td>
</tr>
<tr>
<td>缺点</td>
<td>指令难以增加，不灵活</td>
<td>增加指令译码和分析难度，速度慢</td>
</tr>
</tbody></table>
<p>【2017统考真题】某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令29条、二地址指令107条，每个地址字段为6位，则指令字长至少应该是()。</p>
<p>解答：三地址29条需要的位数是5位，多出3位，而107条需要6位。故总共5+6+12&#x3D;23，因为按照字节编址，所以最少需要24位。</p>
<h3 id="第二节-寻址方式（重点）"><a href="#第二节-寻址方式（重点）" class="headerlink" title="第二节 寻址方式（重点）"></a>第二节 寻址方式（重点）</h3><p>一、指令寻址（由PC指出）</p>
<p>Ⅰ、顺序寻址</p>
<p>PC+”1“，这里的1指指令字长，每次取值结束后PC会+1</p>
<p>Ⅱ、跳跃寻址</p>
<p>执行转移类指令导致的PC值改变</p>
<p>二、数据寻址（由本条指令的地址码指明真实地址）</p>
<p>非偏移指令</p>
<table>
<thead>
<tr>
<th>寻址方式</th>
<th>有效地址</th>
<th>优点</th>
<th>缺点</th>
<th>访存次数（指令执行期间）</th>
</tr>
</thead>
<tbody><tr>
<td>直接寻址</td>
<td>操作数的真实地址</td>
<td>简单</td>
<td>限制寻址范围</td>
<td>1</td>
</tr>
<tr>
<td>间接寻址</td>
<td>操作数地址的地址</td>
<td>可扩大寻址范围</td>
<td>指令在执行阶段要多次访存</td>
<td>最少2次</td>
</tr>
<tr>
<td>寄存器寻址</td>
<td>寄存器的地址</td>
<td>不访问主存，速度快</td>
<td>寄存器昂贵</td>
<td>0</td>
</tr>
<tr>
<td>寄存器间接寻址</td>
<td>寄存器地址，内部是操作数主存地址</td>
<td>与一般的间址快</td>
<td>但执行仍然会访存</td>
<td>1</td>
</tr>
<tr>
<td>隐含寻址</td>
<td>指令中隐含操作数地址</td>
<td>有利于缩短指令字长</td>
<td>需要增加存储操作数的硬件</td>
<td>0</td>
</tr>
<tr>
<td>立即寻址</td>
<td>就是操作数本身</td>
<td>最快</td>
<td>限制操作数范围</td>
<td>0</td>
</tr>
</tbody></table>
<p>偏移寻址（重中之重）</p>
<p>指令执行过程中，都会在将运算结果放入主存中，涉及一次访存。</p>
<p>Ⅰ、基址寻址</p>
<p>将CPU中基址寄存器(BR)&#x2F;通用寄存器的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即EA&#x3D;(BR)+A</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-c426e479dc932fe12028a48168538710_720w.webp" alt="img"></p>
<p>※采用通用寄存器作为基址寄存器 �0 的位数，根据通用寄存器的总数判断，程序运行前，CPU将BR的值修改为该程序的起始地址。</p>
<ul>
<li>基址寄存器是面向操作系统的，其内容由<strong>操作系统或管理程序</strong>确定。用户无法修改，在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。</li>
<li>当采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由<strong>操作系统</strong>确定。</li>
<li>优点：可扩大寻址范围（基址寄存器的位数大于形式地址A的位数）</li>
</ul>
<p>Ⅱ、变址寻址</p>
<p>有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和，即EA&#x3D; (IX)+A，其中IX可为变址寄存器（专用），也可用通用寄存器作为变址寄存器 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-6df574e85878849521f251069abee20a_720w.webp" alt="img"></p>
<ul>
<li>变址寄存器是面向用户的，在执行过程中，变址寄存器的内容可由用户改变（IX作为偏移量），形式地址A不变（作为基地址）。刚好与基址寻址相反。</li>
<li>在针对<strong>数组处理</strong>过程中，不断改变IX的值，便很容易形成数组中任一数据的地址，特别适合<strong>编制循环程序</strong>。</li>
<li>基址变址复合执行。EA&#x3D;(IX)+(BR)+A。</li>
</ul>
<p>Ⅲ、相对寻址</p>
<p>相对寻址：把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA&#x3D;(PC)+A，其中A是相对于PC所指地址的位移量，可正可负，补码表示 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-f24ae7c93c806bdd93b31154b7564dff_720w.webp" alt="img"></p>
<ul>
<li>优点：这段代码在程序内浮动时不用更改跳转指令的地址码</li>
<li>相对寻址广泛应用于转移指令</li>
<li>注意：对于JMP A转移指令，当从CPU中取出一字节时，会自动执行PC+1。若指令的地址为X，且占2B，在取出该指令后，会自定跳转到X+2+A。</li>
</ul>
<p>堆栈寻址</p>
<p>操作数存放在堆栈中，隐含使用堆栈指针作为操作数地址。</p>
<ul>
<li>硬堆栈是将寄存器作为栈，成本很高；软堆栈是将主存作为栈，成本低。</li>
<li>硬堆栈不访存，软堆栈访存一次</li>
</ul>
<h3 id="第三节-高级语言程序与机器级代码之间的对应"><a href="#第三节-高级语言程序与机器级代码之间的对应" class="headerlink" title="第三节 高级语言程序与机器级代码之间的对应"></a>第三节 高级语言程序与机器级代码之间的对应</h3><p>一、基本概念</p>
<ul>
<li>对操作数的操作地址只涉及三种：寄存器到寄存器，主存到寄存器，立即数到寄存器。</li>
<li>dword 32bit ；word 16bit ；byte 8bit</li>
<li>通用寄存器 eax ebx ecx edx 变址寄存器 esi edi 堆栈寄存器 ebp esp。</li>
</ul>
<p>二、选择结构语句的机器级表示</p>
<table>
<thead>
<tr>
<th>je</th>
<th>jump when equal,</th>
</tr>
</thead>
<tbody><tr>
<td>jne</td>
<td>jump when not equal,</td>
</tr>
<tr>
<td>jg</td>
<td>jump when greater,</td>
</tr>
<tr>
<td>jge</td>
<td>jump when greater or equal</td>
</tr>
<tr>
<td>jl</td>
<td>jump when less</td>
</tr>
<tr>
<td>jle</td>
<td>jump when less or equal</td>
</tr>
</tbody></table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-4b5d24029f1096007c35dcb29e34a7a9_720w.webp" alt="img"></p>
<p>例如</p>
<blockquote>
<p>cmp eax ,ebx #比较寄存器eax和ebx里的值<br>jg NEXT #若eax&gt;ebx，则跳转到NEXT</p>
</blockquote>
<p>三、循环结构语句的机器级表示</p>
<p>用条件指令实现循环</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-96caf8f78b1b6a289b88f4840799eb6e_720w.webp" alt="img"></p>
<p>用loop指令实现循环</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-5fa788a175c098bb2283fe9ef3808155_720w.webp" alt="img"></p>
<p>就是将”某些处理“封装到了Looptop内，使得代码更加简洁。</p>
<p>四、CISC和RISC</p>
<table>
<thead>
<tr>
<th>对比项目</th>
<th>CISC</th>
<th>RISC</th>
</tr>
</thead>
<tbody><tr>
<td>指令系统</td>
<td>复杂，庞大</td>
<td>简单，精简</td>
</tr>
<tr>
<td>指令数目</td>
<td>一般大于200条</td>
<td>一般小于100条</td>
</tr>
<tr>
<td>指令字长</td>
<td>不固定</td>
<td>定长</td>
</tr>
<tr>
<td>可访存指令</td>
<td>没有限制</td>
<td>只有Load&#x2F;Store指令</td>
</tr>
<tr>
<td>各种指令执行时间</td>
<td>相差较大</td>
<td>绝大多数在一个周期内完成</td>
</tr>
<tr>
<td>各指令使用频率</td>
<td>有的常用，有点不常用</td>
<td>一般都常用</td>
</tr>
<tr>
<td>通用寄存器的数量</td>
<td>较少</td>
<td>多</td>
</tr>
<tr>
<td>控制方式</td>
<td>绝大多数为微程序控制</td>
<td>绝大多数为组合逻辑控制</td>
</tr>
<tr>
<td>指令流水线</td>
<td>可以通过一定方式实现</td>
<td>必须实现</td>
</tr>
</tbody></table>
<h2 id="第五章-中央处理器"><a href="#第五章-中央处理器" class="headerlink" title="第五章 中央处理器"></a>第五章 中央处理器</h2><h3 id="第一节-CPU"><a href="#第一节-CPU" class="headerlink" title="第一节 CPU"></a>第一节 CPU</h3><p>一、CPU的结构</p>
<p>CPU由运算器和控制器组成。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-4b8e102d396ad3c46994b1db74f31df7_720w.webp" alt="img"></p>
<p>二、CPU的功能</p>
<p>指令控制、操作控制、时间控制、数据加工、中断处理。</p>
<p>运算器的功能：对数据加工</p>
<p>控制器的功能：取指令、分析指令、执行指令</p>
<h3 id="第二节-指令执行过程"><a href="#第二节-指令执行过程" class="headerlink" title="第二节 指令执行过程"></a>第二节 指令执行过程</h3><p>在指令周期中，包含了：取指周期，在取指周期后需要判断是否有间址周期，如果没有就进入到执行周期，在执行周期后又需要判断是否有中断程序，如果有就响应中断并保存断点生成中断服务程序入口；如果没有就进入下一个取指周期。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-b654a0a7ae41e17adb83c4b78a878c44_720w.webp" alt="img"></p>
<blockquote>
<p>四个周期都有CPU访存操作，只是访存目的不同。取值周期是取指令；间址周期是取有效地址；执行周期是为了取操作数；中断周期是为了保存程序断点。</p>
</blockquote>
<p>指令周期常常有若干个机器周期，机器周期里面又包含若干个时钟周期。每个指令周期内的机器周期可以不同，机器周期内的时钟周期也可以不同。时钟周期是CPU操作的最基本单位。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-317924ae7f3d6f8258e5a311020eee89_720w.webp" alt="img"></p>
<p>一、取值周期</p>
<p>取指周期：取指周期的任务是根据PC中的内容从主存中取出指令代码并存放在IR中。而PC中存放的是指令的地址，根据这个地址从内存单元取出的是指令，并放在指令寄存器IR中，取指令的同时，PC加1。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-2fa4b95ed36149c68e6bca747d752918_720w.webp" alt="img"></p>
<p>二、间址周期</p>
<p>间址周期：间址周期的任务是取操作数有效地址，以一次间址为例，将指令中的地址码送到MAR并送至地址总线，此后CU向存储器发读命令，以获取有效地址并存至MDR。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-bf45033e4d627d05e098b4702a07adfa_720w.webp" alt="img"></p>
<p>三、执行周期</p>
<p>执行周期：执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。</p>
<p>指令执行方案：</p>
<table>
<thead>
<tr>
<th>单指令周期</th>
<th>所有指令选用相同的执行时间（取决于最长指令执行时间），指令间串行，但原本只需要很短时间完成指令也分配了很长时间，降低整个系统运行速度</th>
</tr>
</thead>
<tbody><tr>
<td>多指令周期</td>
<td>对不同指令选用不同的执行时间，需要更复杂的硬件设计，指令间是串行</td>
</tr>
<tr>
<td>流水线</td>
<td>在每个时钟周期让多个指令同时运行，指令间是并行</td>
</tr>
</tbody></table>
<p>四、中断周期</p>
<p>中断周期：中断周期的任务是处理中断请求。假设程序断点存入堆栈中，并用SP指示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-0a9db9ebd720e62143d040e3c48eafb1_720w.webp" alt="img"></p>
<h3 id="第三节-数据通路的功能和基本结构"><a href="#第三节-数据通路的功能和基本结构" class="headerlink" title="第三节 数据通路的功能和基本结构"></a>第三节 数据通路的功能和基本结构</h3><p>一、数据通路的基本结构</p>
<p>Ⅰ：CPU内部单总线方式。将所有寄存器的输入端和输出端都连接在一条公共通路上。易发生冲突。</p>
<p>Ⅱ：双总线&#x2F;多总线方式。多个总线上传不同的数据，提高效率。</p>
<p>Ⅲ：专用数据通路方式。专门给某些部件设计通路。性能很高但是硬件量大。</p>
<p>说明：</p>
<p>①对于单总线的连接方式来说，ALU只能有一端与总线相连，因为两端相连就必会发生冲突。所以另一段要设计一个暂存器，先把数据放入暂存器，暂存器再与总线相连。</p>
<p>②单周期就是指令在一个周期内完成，这是需要与多总线结构配合。才能使各个部件的数据传递。因为单总线一个周期内只能传递一个数据，所以指令不可能在一个周期内完成。</p>
<table>
<thead>
<tr>
<th>内部总线</th>
<th>是指同一部件，如CPU内部连接各个寄存器及运算部件之间的总线</th>
</tr>
</thead>
<tbody><tr>
<td>系统总线</td>
<td>指同一台计算机的各部件，如CPU，主存，I&#x2F;O之间连接的总线</td>
</tr>
</tbody></table>
<h3 id="第四节-控制器的功能和工作原理"><a href="#第四节-控制器的功能和工作原理" class="headerlink" title="第四节 控制器的功能和工作原理"></a>第四节 控制器的功能和工作原理</h3><p>一、硬布线控制器</p>
<p><em>多提一嘴，一定要看看王道视频是如何设计出组合逻辑图的，我保证看完一定会有颠覆性的收获。</em></p>
<p><strong>根据指令操作码、目前的机器周期、节拍信号、机器状态条件，即可确定现在这个节拍应该发出哪些”微命令“</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-3af7e2c234438b972cecf3ef0e2cce32_720w.webp" alt="img"></p>
<p>硬布线控制器的特点：</p>
<ul>
<li>指令越多，设计和实现就越复杂（逻辑图很复杂），因此一般使用RISC。</li>
<li>如果扩充一条新的指令，则控制器的设计就需要大改，因此扩充指令较为困难。</li>
<li>由于使用存纯硬件实现控制，因此执行速度很快。</li>
</ul>
<p>二、微程序控制器（重难点）</p>
<p>要求：会基本概念微命令与微操作，微指令与微周期，主存储器与控制存储器，程序与微程序，MAR与CMAR，IR与CMDR。还会一些基本结构，比如为地址形成部件，微地址寄存器CMAR，微指令寄存器CMDR,控制存储器CM。</p>
<ul>
<li><strong>微命令</strong>：控制器部件向执行部件发出的控制命令，是构成控制序列的最小单位，例如打开或者关闭控制门的电位信号。是各部件完成某个基本微操作的命令</li>
<li><strong>微操作</strong>：执行部件接受微命令后所进行的操作，和微操作是一一对应的。 （实际上，微命令是微操作的控制信号，微操作是微命令的执行过程，微操作是执行部件中最基本的操作）</li>
<li><strong>微指令</strong>：若干微命令的集合，存放在一个控制存储器中，而<strong>存放微指令的控制存储器的单元成为微地址</strong>。在同一CPU周期内，<strong>并行执行的一组微命令，存储在控制存储器上面，称为一条微指令</strong>。</li>
<li><strong>微周期</strong>：从读取一条微指令，到执行执行完毕所需要的时间称为微周期。</li>
<li><strong>控制存储器</strong>：<strong>主存储器</strong>，主要用来存放程序和数据，位于CPU的外部，使用的是RAM。而<strong>控制存储器，则主要用于存储微程序，位于CPU内部，采用的是ROM</strong>。</li>
<li><strong>微程序</strong>：实现一条机器指令功能的微指令序列。</li>
<li><strong>程序与微程序</strong>：程序由机器指令构成，编写好以后放到主存中运行，可以改写。而微程序由微指令构成，事先编写好在CM（控制存储器）中，一般是不可改写的。微程序的作用就是实现一条对应的机器指令。</li>
<li>微程序&gt;微指令&gt;微命令&#x3D;微操作是微命令的执行过程。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-e226b0670a4abe69cbc4e0fa00cc9043_720w.webp" alt="img"></p>
<p>秒懂哦</p>
<ul>
<li>一台计算机可以分为控制部件和执行部件。其中控制部件有指令寄存器，程序计数器，操作控制器，执行部件有运算器，存储器，外围设备，状态条件寄存器。</li>
<li>汇编程序员可见的寄存器有基址寄存器和状态&#x2F;标志寄存器，程序计数器PC及通用寄存器。而MAR,MDR,IR,是CPU内部寄存器，汇编程序员不可见，微指令相关的汇编程序员也不可见。</li>
</ul>
<p>水平型微指令的编码方式（重点会考）</p>
<p><strong>①字段直接编码</strong>对于直接编码的方式最大的好处就是能够并行微操作，缩短了微命令的字段长度。有个题能很好的解释这其中的原因。某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码方式，共有33歌微命令，构成5个互斥类，分别包含7，3，12，5和6个微命令，则操作控制字段至少有几位？</p>
<p><strong>每个互斥类要留1个状态位不操作</strong>，故为8，4，13，6，7个微命令。则需要3，2，4，3，3位共15位控制字段，而直接控制法要33位。很明显的缩减操作字段位数。</p>
<p>优点明显，缺点也明显啊。增加了译码，执行时间会增长，而却增大成本。</p>
<p>②<strong>直接编码</strong>就是每个控制字段位，就代表一个微命令，优点就是快，电力嘎嘎简单。但是若微命令要是多达几百条。那不是要几百位了。因此指令位数太长。</p>
<p>③某带有中断的指令系统有101中操作，采用微程序控制方式，存储器中相应最少有103个微程序。</p>
<p><strong>要加上取值操作和终端操作，</strong>若有n条操作，则有<strong>n+2个微程序</strong></p>
<p>④下一条微指令的形成方法常考的：<strong>断定法（根据当前执行的微指令寻找到下一条微指令）和计数器法（类似PC）</strong></p>
<h3 id="第五节-异常和中断机制"><a href="#第五节-异常和中断机制" class="headerlink" title="第五节 异常和中断机制"></a>第五节 异常和中断机制</h3><p><em>这节会在后面第七章一起讲</em></p>
<h3 id="第六节-指令流水线"><a href="#第六节-指令流水线" class="headerlink" title="第六节 指令流水线"></a>第六节 指令流水线</h3><p>讲在前面，为什么要引入指令流水线。相信都听说过华强北的流水线运作方式吧。最明显的优点就是相较于顺序执行的吞吐量更大（单位时间内）运行相同数量的指令也更快。效率也更高。</p>
<p>这里就可以知道指令流水线的概念：<strong>把指令执行过程划分为不同的阶段，占用不同的资源，就能使多条指令同时执行</strong>。</p>
<p>①在流水执行的过程中，会经常遇到冲突，包括结构冲突，<strong>数据冲突</strong>，控制冲突。</p>
<table>
<thead>
<tr>
<th></th>
<th>结构相关&#x2F;冲突&#x2F;冒险</th>
<th>数据相关&#x2F;冲突&#x2F;冒险</th>
<th>控制相关&#x2F;冲突&#x2F;冒险</th>
</tr>
</thead>
<tbody><tr>
<td>概念</td>
<td>多条指令在同一时刻争用同一资源</td>
<td>下一条指令会用到当前指令计算的结果</td>
<td>遇到执行转移、调用、返回导致PC中断</td>
</tr>
<tr>
<td>处理办法</td>
<td>1.单独设置数据存储器和指令存储器，使取数和取值操作在不同的存储器中进行 2.暂停时钟周期</td>
<td>1.暂停时钟周期 2.数据旁路技术 3.编译优化</td>
<td>1.早判断，早生成 2.预取转移成功和不成功两个控制流方向的目标指令 3.加快和提前形成条件码 4.提高转移方向的猜准率</td>
</tr>
</tbody></table>
<p>②<strong>五段式指令流水线（超重要）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-3e5fc6faa036d3008f39d36abc062a41_720w.webp" alt="img"></p>
<p>顾名思义，五段分为IF(取值),ID(译码&amp;取数),EX(执行),M(访存),WB(写回寄存器)</p>
<p>只有上一条指令进入ID段后，下一条指令才能开始IF段，否则会覆盖IF段锁存器的内容</p>
<p>考试中常见的五类指令：</p>
<p><strong>Ⅰ、运算类指令的执行过程</strong></p>
<p>IF：根据PC从指令Cache取指令至IF段的锁存器</p>
<p>ID：取出操作数至ID段的锁存器</p>
<p>EX：运算，将结果存入EX段锁存器</p>
<p>M：空段</p>
<p>WB：将运算结果写回指定的寄存器</p>
<p><strong>Ⅱ、LOAD指令执行过程</strong></p>
<p><strong>作用</strong>：load指令可以完成将数据从存储器中复制到目的寄存器中，会访存</p>
<p>IF：根据PC从指令Cache取指令至IF段的锁存器</p>
<p>ID：将基址寄存器的值放到锁存器A，将偏移量的值放到lmm</p>
<p>EX：运算，得到有效地址</p>
<p>M：从数据Cache中取数并放入锁存器</p>
<p>WB：将运算结果写回指定的寄存器</p>
<p><strong>Ⅲ、STORE指令执行过程</strong></p>
<p><strong>作用：</strong>将数据从寄存器中，复制到存储器中，会访存</p>
<p>IF：根据PC从指令Cache取指令至IF段的锁存器</p>
<p>ID：将基址寄存器的值放到锁存器A，将偏移量的值放到lmm。将要存的数放到B</p>
<p>EX：运算，得到有效地址。并将锁存器B的内容放到锁存器Store</p>
<p>M：写入数据Cache</p>
<p>WB：空段</p>
<p><strong>Ⅳ、条件转移指令执行过程</strong></p>
<p>IF：根据PC从指令Cache取指令至IF段的锁存器</p>
<p>ID：进行比较的两个数放入锁存器A，B；偏移量放入lmm</p>
<p>EX：运算，比较两个数</p>
<p>M：将目标PC值写回PC</p>
<p>WB：空段</p>
<p><strong>Ⅴ、无条件转移指令的执行过程</strong></p>
<p>IF：根据PC从指令Cache取指令至IF段的锁存器</p>
<p>ID：偏移量放入lmm</p>
<p>EX：将目标PC值写回PC</p>
<p>M：空段</p>
<p>WB：空段</p>
<p>针对条件转移指令和无条件转移指令做以下说明：写入PC的好事比EX更短，可以安排在EX段时间内完成。越<strong>早完成就越能避免控制冲突</strong>。当然也有在WB段修改PC值的</p>
<h3 id="题目总结：-2"><a href="#题目总结：-2" class="headerlink" title="题目总结："></a>题目总结：</h3><p>①流水CPU是由一系列叫做“段”的处理线路组成的。一个m段流水线稳定时的CPU的吞吐能力，与m个并行部件的CPU的吞吐能力相比<strong>具有相同的吞吐能力</strong></p>
<p>原因是当流水线稳定后，说明已经进行了一条指令，往后每多一个时钟周期就多一条指令执行成功。</p>
<p>m个并行平均下来也是一个时针周期就多条指令</p>
<p>故具有相同的吞吐能力，但是流水线的方式，结构实现较为简单。</p>
<h3 id="第七节-多处理器的基本概念（选择题）"><a href="#第七节-多处理器的基本概念（选择题）" class="headerlink" title="第七节 多处理器的基本概念（选择题）"></a>第七节 多处理器的基本概念（选择题）</h3><p>这节的要求就是明白基本概念</p>
<p>①SISD（单指令流单数据流）</p>
<p>特点：只能并发，不能并行，每条指令处理一个指令</p>
<p>不是数据级并行技术</p>
<table>
<thead>
<tr>
<th></th>
<th>SISD（单指令流单数据流）</th>
<th>SIMD（单指令多数据流）</th>
<th>MIMD（多指令多数据流）</th>
<th>多处理器系统</th>
<th>多计算机系统</th>
</tr>
</thead>
<tbody><tr>
<td>特点</td>
<td>不是数据级并行技术</td>
<td>是一种数据级并行技术</td>
<td>是一种线程级并行技术</td>
<td>多个处理器共享单一物理地址空间</td>
<td>每台计算机拥有私有存储器，相互独立</td>
</tr>
<tr>
<td>特征</td>
<td>一条指令处理一个数据</td>
<td>一条指令处理多个数据</td>
<td>多条指令处理多个数据</td>
<td>多个处理器+一个主存储器</td>
<td>多个处理器+多个主存储器</td>
</tr>
</tbody></table>
<ul>
<li>并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。</li>
<li>并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。</li>
</ul>
<p>并发不是并行。并行是让不同的代码片段同时在不同的物理处理器上执行。并行的关键是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。（你学废了吗？）</p>
<h2 id="第六章-总线"><a href="#第六章-总线" class="headerlink" title="第六章 总线"></a>第六章 总线</h2><h3 id="第一节-总线的概述"><a href="#第一节-总线的概述" class="headerlink" title="第一节 总线的概述"></a>第一节 总线的概述</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-c70a08296cbc4ae215427c4595001fe0_720w.webp" alt="img"></p>
<ul>
<li>片内总线：芯片内部的总线，是CPU芯片内部寄存器与寄存器之间，寄存器与ALU之间的公共连接线</li>
<li>系统总线：计算机系统内部功能部件（CPU、主存、I&#x2F;O接口）之间相互连接的总线，可分为三类，数据总线，地址总线，控制总线</li>
<li>通信总线：计算机系统之间或计算机系统与其它系统之间的信息传送的总线</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>数据总线</th>
<th>地址总线</th>
<th>控制总线</th>
</tr>
</thead>
<tbody><tr>
<td>功能</td>
<td>传输数据信息</td>
<td>传输地址信息</td>
<td>传输控制信息</td>
</tr>
<tr>
<td>大小与什么有关</td>
<td>机器字长、存储字长</td>
<td>主存地址空间大小</td>
<td>传输一个信号</td>
</tr>
<tr>
<td>方向</td>
<td>双向</td>
<td>单向</td>
<td>既有双向也有单向</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>总线结构</th>
<th>单总线（常用）</th>
<th>双总线</th>
<th>三总线</th>
</tr>
</thead>
<tbody><tr>
<td>内容</td>
<td>系统总线</td>
<td>主存总线、I&#x2F;O总线</td>
<td>主存总线、I&#x2F;O总线、DMA总线</td>
</tr>
<tr>
<td>结构</td>
<td>CPU、主存、I&#x2F;O设备都连接在一组总线上</td>
<td>主存总线用于CPU，主存之间的传送；I&#x2F;O总线用于多个外部设备与通道之间进行传送</td>
<td>多加的一条DMA总线是用于主存访问高速外设</td>
</tr>
<tr>
<td>优点</td>
<td>结构简单，成本低，易于接入新的设备</td>
<td>将较低速的I&#x2F;O设备从单总线分离出来，实现存储器总线和I&#x2F;O总线分离</td>
<td>更加提高了I&#x2F;O设备的性能，更快响应命令，提高系统吞吐量</td>
</tr>
<tr>
<td>缺点</td>
<td>带宽低，负载重，不支持并发传送操作</td>
<td>需要增加硬件设备</td>
<td>系统工作效率低，同一时刻只能一个总线工作</td>
</tr>
</tbody></table>
<h3 id="第二节-性能指标"><a href="#第二节-性能指标" class="headerlink" title="第二节 性能指标"></a>第二节 性能指标</h3><p>写一些会考的性能指标，配合相应的题</p>
<h3 id="第三节-总线定时方式"><a href="#第三节-总线定时方式" class="headerlink" title="第三节 总线定时方式"></a>第三节 总线定时方式</h3><table>
<thead>
<tr>
<th></th>
<th>同步通信</th>
<th>异步通信</th>
<th>半同步通信</th>
<th>分离式通信</th>
</tr>
</thead>
<tbody><tr>
<td>特点</td>
<td>由统一时钟控制数据传送</td>
<td>采用应答方式，没有公共时钟的标准</td>
<td>同步、异步结合</td>
<td>充分挖掘系统总线每瞬间的潜力</td>
</tr>
<tr>
<td>优点</td>
<td>传送速度快</td>
<td>保证两个工作速度相差很大的部件之间进行传输</td>
<td></td>
<td></td>
</tr>
<tr>
<td>缺点</td>
<td>强制性同步</td>
<td>复杂，慢</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>补充：关于异步通信还分为三类：不互锁，速度最快，可靠性最差；半互锁；全互锁。速度最慢，可靠性最好。</p>
<h2 id="第七章-I-O系统"><a href="#第七章-I-O系统" class="headerlink" title="第七章 I&#x2F;O系统"></a>第七章 I&#x2F;O系统</h2><h3 id="第一节-I-O接口"><a href="#第一节-I-O接口" class="headerlink" title="第一节 I&#x2F;O接口"></a>第一节 I&#x2F;O接口</h3><p>简单来说，<strong>I&#x2F;O接口就是负责协调主机与外部设备之间的数据传输</strong>。</p>
<p>可以这样理解就是你的电脑，怎么控制你的U盘上，做一些读写操作。U盘不是“亲儿子”啊，所以要单独给它设置接口来控制它。</p>
<p>CPU那如何确定要操作的是主存还是外部设备呢。这就引出了编制方式——统一编制和独立编址</p>
<table>
<thead>
<tr>
<th></th>
<th>统一编制</th>
<th>独立编制</th>
</tr>
</thead>
<tbody><tr>
<td>内容</td>
<td>把外部设备的存储当成内存进行分配，有统一的地区分配，靠不同的地址区别内存和外部设备</td>
<td>独立编制，专门为输入&#x2F;输出指令设置访问端口，靠不同指令区别内存和外部设备</td>
</tr>
<tr>
<td>优点</td>
<td>1.不需要专门的指令表示访问外存 2.读写控制电路简单 3，程序设计灵活性高</td>
<td>1.地址译码快 2.不占用主存地址空间</td>
</tr>
<tr>
<td>缺点</td>
<td>1.端口占用了主存地址空间，使主存地址空间变小 2.寻址时间长（外部设备）</td>
<td>1.程序设计灵活差 2.指令增加，控制电路复杂</td>
</tr>
</tbody></table>
<p>补充个会考的内容，关于显存VRAM（就是显示存储器）</p>
<p>显存是为了提高刷新图像的信号，会提前把需要显示的数据放入显存中。如今的计算机很多都有独立显存，就这可以避免，显存占用主存的空间。</p>
<p>显存会考的计算：</p>
<p>容量&#x3D;分辨率×灰度级位数</p>
<p>带宽&#x3D;分辨率×灰度级位数×帧数</p>
<h3 id="第二节-主机访问I-O设备的控制方式"><a href="#第二节-主机访问I-O设备的控制方式" class="headerlink" title="第二节 主机访问I&#x2F;O设备的控制方式"></a>第二节 主机访问I&#x2F;O设备的控制方式</h3><p><strong>一、程序查询方式</strong></p>
<p>特点：CPU与I&#x2F;O串行工作，CPU不断查询I&#x2F;O设备状态，直到外设准备就绪。</p>
<p>优点：接口设计简单，设备量少。</p>
<p>缺点：CPU信息传送过程中要花费很多时间用于查询和等待，而且在一段时间内只能和一台外设交换信息，效率低。</p>
<p>独占查询：CPU100%的时间都在查询I&#x2F;O状态，完全串行。</p>
<p>定时查询：每隔一段时间CPU就查询I&#x2F;O状态，查询的间隔内CPU可以执行其他程序。</p>
<p><strong>二、中断方式</strong></p>
<p>Ⅰ、程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂时中断现行程序，而转去执行这些异常情况或特殊请求进行处理。处理完毕后又自动返回到现行程序的断点处，继续执行原程序。</p>
<p>引出几个问题：</p>
<p>问题一：接收到中断信号后是怎么转到执行中断程序的？</p>
<p>问题二：中断程序执行完后是怎么回来执行原先程序的？</p>
<p>问题三：假如有多个程序断源同时申请，怎么专门安排优先顺序？</p>
<p>问题四、如何判断是哪个设备发来的中断信号？</p>
<p>Ⅱ、*<strong>整个中断方式的流程（重点）*</strong></p>
<p>1.中断请求</p>
<p><em>“先说明开中断和关中断的作用，关中断保证原子操作，不会被打断，标志位IF&#x3D;1为开中断（允许中断）”</em></p>
<p>CPU在统一时刻每条指令执行阶段结束前向接口发出中断查询信号，获取I&#x2F;O的中断请求，也就是说，CPU响应中断的时间是在每条指令执行阶段的结束时刻。</p>
<p>如何判断是哪个设备发来的中断信号？</p>
<p>会存在一个中断请求标记寄存器，里面不同位代表不同的设备中断。状态位为1的话，代表处理中断申请。</p>
<p>CPU响应中断必须满足以下3个条件：</p>
<p>①中断源有中断请求。</p>
<p>②CPU允许中断即断开中断。</p>
<p>③一条指令执行完毕，且没有更紧迫的任务。</p>
<p>2.中断响应</p>
<p>假如有多个程序断源同时申请，怎么专门安排优先顺序？</p>
<p>有两种处理办法：</p>
<p>①硬件实现硬件排队器</p>
<p>②软件实现查询程序</p>
<p>中断的优先级：</p>
<p>硬件故障中断&gt;软件中断</p>
<p>非屏蔽中断&gt;可屏蔽中断</p>
<p>DMA请求&gt;I&#x2F;O设备传送的中断请求</p>
<p>有再补充</p>
<p>3.中断处理</p>
<p>接收到中断信号后是怎么转到执行中断程序的？</p>
<p>这时候就需要中断隐指令：保存原程序的PC值，并让PC指向中断程序的第一条。</p>
<p><strong>中断隐指令的任务：</strong></p>
<p><strong>①关中断。在中断服务程序中，为保护中断现场不会再被新的中断打断，就必须关中断</strong></p>
<p><strong>②保存断点。保证“回得来”</strong></p>
<p><strong>③引出中断服务。将中断服务程序入口地址传送给程序计数器</strong></p>
<p>引出中断服务，如何将中断传给PC？</p>
<p>通过硬件向量法，将硬件（中断向量地址形成部件）产生向量地址，再由向量地址找到入口地址。</p>
<p>中断处理过程—硬件向量法。为什么要用向量地址去寻找中断的入口，而不是直接去寻找中断入口？</p>
<p>1.若是通过中断向量地址形成部件直接去入口地址的话，会造成中断程序有时候长短不一，就要频繁修改中断向量地址形成部件。</p>
<p>2.若是先通过向量地址，在内存中找到中断地址的话，只需修改内存的地址就可以。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-4a84ec2d9a1d077ae2fa52a9305d6cd0_720w.webp" alt="img"></p>
<p><strong>中断服务程序的任务</strong></p>
<p><strong>①保护现场。保存通用寄存器和状态寄存器的内容。</strong></p>
<p><strong>②中断服务。主体部分。例如将需要打印的字符传送到打印机的缓冲存储器中。</strong></p>
<p><strong>③恢复现场。通过出栈或取值把之前保存的信息传送回寄存器中。</strong></p>
<p><strong>④中断返回。通过中断返回指令回到原程序断点处。</strong></p>
<p>总结：中断处理过程&#x3D;中断隐指令+中断服务程序</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-02648200b81d1278cb12f6cb504bbd5f_720w.webp" alt="img"></p>
<p>中断流程</p>
<p>Ⅲ、单重中断和多重中断</p>
<p>单重中断：执行中断服务程序时不响应新的中断请求。</p>
<p>多重中断：又称中断嵌套，执行中断服务程序时可响应新的中断请求。</p>
<p>对于多重中断有中断屏蔽技术，在中断服务开启前打开中断指令。优先级别高的中断源有权中断优先级别低的中断源。</p>
<p>这时候就要设置一个屏蔽触发器，1表示屏蔽该中断请求，0表示正常申请，所有屏蔽触发器构成一个屏蔽寄存器，屏蔽寄存器里面内容就是屏蔽字。</p>
<p>有以下几个说明</p>
<p>①每个中断源至少有一个1（对自身中断源）</p>
<p>②1越多，优先级越高</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-8aa734eff62a85a1c978bc11074b031f_720w.webp" alt="img"></p>
<p>看懂这个例题就够了</p>
<p><strong>三、DMA方式</strong></p>
<p>DMA的特点：</p>
<p>1、内存既可以被CPU访问也可以被DMA控制器访问，CPU和DMA控制器会竞争总线的使用权，因而需要仲裁机制。</p>
<p>2、外部设备与内存之间的整个数据交换过程全部在DMA控制器的控制下完成，CPU能够与外部设备并行工作，大大提高了效率。</p>
<p>3、在DMA方式开始之前CPU要对DMA控制器进行初始化，在DMA方式结束之后，CPU要申请中断，对内存缓冲区进行后处理。</p>
<p>DMA的处理方式：</p>
<p>1.预处理：CPU完成寄存器初值设置等准备工作。</p>
<p>2.数据传输：CPU继续执行主程序，DMA控制器完成数据传送</p>
<p>3.后处理：CPU执行中断服务程序做DMA结束处理</p>
<p>DMA的传送方式：</p>
<p>1.停止CPU访存：需要传送数据时，停止CPU访存，总线控制器交给DMA控制器。</p>
<p>2.周期挪用方式：当I&#x2F;O接口没有DMA请求时，CPU按程序要求访问内存；一旦I&#x2F;P接口有DMA请求，则I&#x2F;O接口挪用一个或几个周期。缺点是：数据输入或输出过程中实际占用了CPU时间。</p>
<p>3.交替访存方式：CPU与DMA控制器交替访问内存。不需要总线使用权的申请、建立和归还过程。</p>
<p>效率高，但实现起来有困难，基本上不被使用。</p>
<ul>
<li>DMA与中断方式的差别</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>中断</th>
<th>DMA</th>
</tr>
</thead>
<tbody><tr>
<td>数据传送</td>
<td>程序控制</td>
<td>硬件控制—DMA控制器。CPU只需进行预处理和后处理</td>
</tr>
<tr>
<td>中断请求</td>
<td>传送数据</td>
<td>向CPU报告传输结束</td>
</tr>
<tr>
<td>响应</td>
<td>指令执行周期结束后响应中断</td>
<td>每个机器周期结束都可，即总线空闲即可</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>适用场景</td>
<td>CPU控制，低速设备</td>
<td>DMA控制器控制，高速设备</td>
</tr>
<tr>
<td>优先级</td>
<td>低于DMA</td>
<td>高于中断</td>
</tr>
<tr>
<td>工作方式</td>
<td>CPU与外设并行，传送与主程序串行</td>
<td>CPU与外设并行，传送与主程序并行</td>
</tr>
<tr>
<td>请求内容</td>
<td>请求的是CPU处理时间</td>
<td>请求的是总线使用权</td>
</tr>
</tbody></table>
<ul>
<li>中断的分类：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/v2-9e0782f89fa170d9a75f607f4612b901_720w.webp" alt="img"></p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="操作系统的四个特性？"><a href="#操作系统的四个特性？" class="headerlink" title="操作系统的四个特性？"></a>操作系统的四个特性？</h2><p>并发：同一段时间内多个程序执行（与并行区分，并行指的是同一时刻有多个事件，多处理器系统可以使程序并行执行）</p>
<p>共享：系统中的资源可以被内存中多个并发执行的进线程共同使用</p>
<p>虚拟：通过分时复用（如分时系统）以及空分复用（如虚拟内存）技术把一个物理实体虚拟为多个</p>
<p>异步：系统进程用一种走走停停的方式执行，（并不是一下子走完），进程什么时候以怎样的速度向前推进是不可预知的</p>
<h2 id="进程线程-1"><a href="#进程线程-1" class="headerlink" title="进程线程"></a>进程线程</h2><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间。</p>
<p>线程是比进程更小的执行单位，它是在一个进程中独立的控制流，一个进程可以启动多个线程，每条线程并行执行不同的任务。</p>
<p><strong>进程和线程的区别如下</strong>：</p>
<ul>
<li>调度：进程是资源管理的基本单位，线程是程序执行的基本单位。</li>
<li>切换：线程上下文切换比进程上下文切换要快得多。</li>
<li>拥有资源： 进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源。</li>
<li>系统开销： 创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I&#x2F;O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。</li>
</ul>
<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。单核处理器可以做到并发。比如有两个进程<code>A</code>和<code>B</code>，<code>A</code>运行一个时间片之后，切换到<code>B</code>，<code>B</code>运行一个时间片之后又切换到<code>A</code>。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。</p>
<p>并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。</p>
<h2 id="多线程相较单线程的好处"><a href="#多线程相较单线程的好处" class="headerlink" title="多线程相较单线程的好处"></a>多线程相较单线程的好处</h2><p>1、并发提升程序执行效率</p>
<p>2、提升CPU利用率，访存的时候可以切换线程来执行</p>
<p>3、更快的响应速度，可以有专门的线程来监听用户请求和专门的线程来处理请求。比如监听线程和工作线程是两个线程，这样监听就负责监听，工作的就负责工作，监听到用户请求马上把请求转到工作线程去处理，监听线程继续监听</p>
<h2 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h2><p>协程是一种用户态的轻量级线程。</p>
<p>协程不是由操作系统内核管理，而是完全由用户程序所控制，这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<p>协程可以理解为可以暂停执行的函数。它拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<h2 id="线程和协程有什么区别呢？"><a href="#线程和协程有什么区别呢？" class="headerlink" title="线程和协程有什么区别呢？"></a>线程和协程有什么区别呢？</h2><p>1、线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。<br>2、线程是协程的资源。协程通过 可以关联任意线程或线程池的执行器（Interceptor）来间接使用线程的资源的。</p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程间通信方式有以下几种：</p>
<p>1、<strong>管道通信</strong></p>
<p>匿名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。<br>有名管道是半双工的通信方式，数据只能单向流动。</p>
<p>2、<strong>消息队列</strong></p>
<p>3、<strong>共享内存</strong>。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
<p>4、<strong>信号量</strong>。信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<h2 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h2><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，它们都将无法推进下去。</p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方持有的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/%E6%AD%BB%E9%94%81.png" alt="img"></p>
<p>下面通过例子说明线程死锁，代码来自并发编程之美。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource2</span><br><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]waiting get resource1</span><br></pre></td></tr></table></figure>

<p>线程 A 通过 <code>synchronized</code> (resource1) 获得 resource1 的监视器锁，然后通过 <code>Thread.sleep(1000)</code>。让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p>
<h2 id="死锁怎么产生？怎么避免？"><a href="#死锁怎么产生？怎么避免？" class="headerlink" title="死锁怎么产生？怎么避免？"></a>死锁怎么产生？怎么避免？</h2><p><strong>死锁产生的四个必要条件</strong>：</p>
<ul>
<li>互斥：一个资源每次只能被一个进程使用</li>
<li>请求与保持：一个进程因请求资源而阻塞时，不释放获得的资源</li>
<li>不剥夺：进程已获得的资源，在未使用之前，不能强行剥夺</li>
<li>循环等待：进程之间循环等待着资源</li>
</ul>
<p><strong>避免死锁的方法</strong>：</p>
<ul>
<li>互斥条件不能破坏，因为加锁就是为了保证互斥</li>
<li>一次性申请所有的资源，避免线程占有资源而且在等待其他资源</li>
<li>占有部分资源的线程进一步申请其他资源时，如果申请不到，主动释放它占有的资源</li>
<li>按序申请资源</li>
</ul>
<h2 id="进程调度策略有哪几种？"><a href="#进程调度策略有哪几种？" class="headerlink" title="进程调度策略有哪几种？"></a>进程调度策略有哪几种？</h2><ul>
<li><p><strong>先来先服务</strong>：非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。另外，对<code>I/O</code>密集型进程也不利，因为这种进程每次进行<code>I/O</code>操作之后又得重新排队。</p>
</li>
<li><p><strong>短作业优先</strong>：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
</li>
<li><p><strong>最短剩余时间优先</strong>：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
</li>
<li><p><strong>时间片轮转</strong>：将所有就绪进程按 <code>FCFS</code> 的原则排成一个队列，每次调度时，把 <code>CPU</code> 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 <code>CPU</code> 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。</p>
</li>
<li><p><strong>优先级调度</strong>：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
</li>
</ul>
<h2 id="进程有哪些状态？"><a href="#进程有哪些状态？" class="headerlink" title="进程有哪些状态？"></a>进程有哪些状态？</h2><p>进程一共有<code>5</code>种状态，分别是创建、就绪、运行（执行）、终止、阻塞。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../UpPictures/Java%E5%85%AB%E8%82%A1%E6%96%87Pictures/20220613090034.png" alt="img"></p>
<ul>
<li>运行状态就是进程正在<code>CPU</code>上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。</li>
<li>就绪状态就是说进程已处于准备运行的状态，即进程获得了除<code>CPU</code>之外的一切所需资源，一旦得到<code>CPU</code>即可运行。</li>
<li>阻塞状态就是进程正在等待某一事件而暂停运行，比如等待某资源为可用或等待<code>I/O</code>完成。即使<code>CPU</code>空闲，该进程也不能运行。</li>
</ul>
<p><strong>运行态→阻塞态</strong>：往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。<br><strong>阻塞态→就绪态</strong>：则是等待的条件已满足，只需分配到处理器后就能运行。<br><strong>运行态→就绪态</strong>：不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。<br><strong>就绪态→运行态</strong>：系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态。</p>
<h2 id="操作系统里的内存碎片怎么理解？"><a href="#操作系统里的内存碎片怎么理解？" class="headerlink" title="操作系统里的内存碎片怎么理解？"></a>操作系统里的内存碎片怎么理解？</h2><p>内存碎片通常分为内部碎片和外部碎片：</p>
<ol>
<li>内部碎片是由于采用固定大小的内存分区，当一个进程不能完全使用分给它的固定内存区域时就会产生内部碎片。通常内部碎片难以完全避免</li>
<li>外部碎片是由于某些未分配的连续内存区域太小，以至于不能满足任意进程的内存分配请求，从而不能被进程利用的内存区域。</li>
</ol>
<p><strong>有什么解决办法</strong>？</p>
<p>现在普遍采取的内存分配方式是段页式内存分配。将内存分为不同的段，再将每一段分成固定大小的页。通过页表机制，使段内的页可以不必连续处于同一内存区域。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟存储器就是具有请求调入功能，能从逻辑上对内存容量加以扩充的一种存储器系统，虚拟内存有多次性，对换性和虚拟性三个特征，它可以将程序分多次调入内存，使得在较小的用户空间可以执行较大的用户程序，所以同时容纳更多的进程并发执行，从而提高系统的吞吐量。发生缺页时可以调入一个段也可以调入一个页，取决于内存的存储管理方式。虚拟性表示虚拟内存和物理内存的映射。</p>
<p>Linux下，进程不能直接读写内存物理地址，只能访问【虚拟内存地址】。操作系统会把虚拟内存地址–&gt;物理地址。</p>
<p>虚拟内存解决有限的内存空间加载较大应用程序的问题，根据需要在内存和磁盘之间来回传送数据。</p>
<p>通过段页表的形式，虚拟内存中取一段连续的内存空间映射到主内存中，主内存空间的程序段可以不连续 。</p>
<h2 id="什么是分页？"><a href="#什么是分页？" class="headerlink" title="什么是分页？"></a>什么是分页？</h2><p>把内存空间划分为<strong>大小相等且固定的块</strong>，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，<strong>因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。</strong></p>
<p>访问分页系统中内存数据需要<strong>两次的内存访问</strong> (一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。</p>
<h2 id="什么是分段？"><a href="#什么是分段？" class="headerlink" title="什么是分段？"></a>什么是分段？</h2><p><strong>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</strong></p>
<p>分段内存管理当中，<strong>地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。</p>
<h2 id="分页和分段有什区别？"><a href="#分页和分段有什区别？" class="headerlink" title="分页和分段有什区别？"></a>分页和分段有什区别？</h2><ul>
<li>分页对程序员是透明的，但是分段需要程序员显式划分每个段。</li>
<li>分页的地址空间是一维地址空间，分段是二维的。</li>
<li>页的大小不可变，段的大小可以动态改变。</li>
<li>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p><strong>为什么要页面置换：</strong></p>
<p>因为应用程序是分多次装入内存的，所以运行到一定的时间，一定会发生缺页。地址映射的过程中，如果页面中发现要访问的页面不在内存中，会产生缺页中断。此时操作系统必须在内存里选择一个页面把他移出内存，为即将调入的页面让出空间。选择淘汰哪一页的规则就是页面置换算法</p>
<p><strong>几种页面置换算法：</strong></p>
<p><strong>最佳置换算法（理想）</strong>：将当前页面中在未来最长时间内不会被访问的页置换出去</p>
<p><strong>先进先出</strong>：淘汰最早调入的页面</p>
<p><strong>最近最久未使用 LRU</strong>：每个页面有一个t来记录上次页面被访问直到现在，每次置换时置换t值最大的页面（用寄存器或栈实现）</p>
<p><strong>时钟算法clock</strong>（也被称为最近未使用算法NRU）：页面设置访问为，将页面链接为一个环形列表，每个页有一个访问位0&#x2F;1, 1表示又一次获救的机会，下次循环指针指向它时可以免除此次置换，但是会把访问位置为0， 代表他下次如果碰到循环指针就该被置换了。页面被访问的时候访问位设为1。页面置换的时候，如果当前指针的访问位为0，置换，否则将这个值置为0，循环直到遇到访问位为0的页面。</p>
<p><strong>改进型Clock算法</strong>：在clock算法的基础上添加一个修改位，优先替换访问位和修改位都是0的页面，其次替换访问位为0修改位为1的页面。</p>
<p><strong>最少使用算法LFU</strong>：设置寄存器记录页面被访问次数，每次置换当前访问次数最少的。</p>
<h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><p>内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。</p>
<p>用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。</p>
<p>最大的区别就是权限不同，在运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。</p>
<h3 id="为什么要有这两种状态？"><a href="#为什么要有这两种状态？" class="headerlink" title="为什么要有这两种状态？"></a>为什么要有这两种状态？</h3><p>内核速度快但是资源有限，能控制的进程数不多，所以需要速度慢一些的用户态协助，但是为了避免用户态被恶意利用，所以限制了用户态程序的权限。</p>
<p>需要限制不同的程序之间的访问能力，防止他们获取别的程序的内存数据，或者获取外围设备的数据，并发送到网络，CPU划分出<strong>两个权限等级</strong> – 用户态和内核态。</p>
<h3 id="什么时候转换"><a href="#什么时候转换" class="headerlink" title="什么时候转换"></a>什么时候转换</h3><p><strong>1、系统调用</strong>：</p>
<p>用户进程主动发起的。用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()就是执行一个创建新进程的系统调用</p>
<p>用户程序使用系统调用，系统调用会转换为内核态并调用操作系统</p>
<p><strong>2、发生异常</strong>：</p>
<p>会从当前运行进程切换到处理次此异常的内核相关程序中</p>
<p><strong>3、外围设备的中断：</strong></p>
<p>所有程序都运行在用户态，但在从硬盘读取数据、或从键盘输入时，这些事情只有操作系统能做，程序需要向操作系统请求以程序的名义来执行这些操作。这个时候用户态程序切换到内核态。</p>
<h2 id="什么是缓冲区溢出？有什么危害？"><a href="#什么是缓冲区溢出？有什么危害？" class="headerlink" title="什么是缓冲区溢出？有什么危害？"></a>什么是缓冲区溢出？有什么危害？</h2><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p>
<p>危害有以下两点：</p>
<ul>
<li>程序崩溃，导致拒绝额服务</li>
<li>跳转并且执行一段恶意代码</li>
</ul>
<p>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p><strong>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合</strong>：</p>
<ul>
<li>当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I&#x2F;O复用。</li>
<li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>
<li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I&#x2F;O复用。</li>
<li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I&#x2F;O复用。</li>
<li>如果一个服务器要处理多个服务或多个协议，一般要使用I&#x2F;O复用。</li>
<li>与多进程和多线程技术相比，I&#x2F;O多路复用技术的最大优势是系统开销小，系统不必创建进程&#x2F;线程，也不必维护这些进程&#x2F;线程，从而大大减小了系统的开销。</li>
</ul>
<h1 id="常见架构模式"><a href="#常见架构模式" class="headerlink" title="常见架构模式"></a>常见架构模式</h1><h3 id="三、单库单应用模式"><a href="#三、单库单应用模式" class="headerlink" title="三、单库单应用模式"></a><strong>三、单库单应用模式</strong></h3><p>这是最简单的一种设计模式，我们的大部分本科毕业设计、一些小的应用，基本上都是这种模式，这种模式的一般设计见下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/29/16eb61a5f8e57770~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p>
<p>如上图所示，这种模式一般只有一个数据库，一个业务应用层，一个后台管理系统，所有的业务都是用过业务层完成的，所有的数据也都是存储在一个数据库中的，好一点会有数据库的同步。虽然简单，但是<strong>也并不是一无是处</strong>。</p>
<ul>
<li><strong>优点</strong>：结构简单、开发速度快、实现简单，可用于产品的第一版等有原型验证需求、用户少的设计。</li>
<li><strong>缺点</strong>：性能差、基本没有高可用、扩展性差，不适用于大规模部署、应用等生产环境。</li>
</ul>
<h3 id="四、内容分发模式"><a href="#四、内容分发模式" class="headerlink" title="四、内容分发模式"></a><strong>四、内容分发模式</strong></h3><p>基本上所有的大型的网站都有或多或少的采用这一种设计模式，常见的应用场景是使用CDN技术把网页、图片、CSS、JS等这些静态资源分发到离用户最近的服务器。这种模式的一般设计见下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/29/16eb61a5f8ff4662~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p>
<p>如上图所示，这种模式较单库单应用模式多了一个CDN、一个云存储OSS(七牛、又拍等雷同)。一个典型的应用流程(以用户上传、查看图片需求为例)如下：</p>
<ol>
<li>上传的时候，用户选择本地机器上的一个图片进行上传</li>
<li>程序会把这个图片上传到云存储OSS上，并返回该图片的一个URL</li>
<li>程序把这个URL字符串存储在业务数据库中，上传完成。</li>
<li>查看的时候，程序从业务数据库得到该图片的URL</li>
<li>程序通过DNS查询这个URL的图片服务器</li>
<li><strong>智能DNS会解析这个URL，得到与用户最近的服务器(或集群)的地址A</strong></li>
<li>然后把服务器A上的图片返回给程序</li>
<li>程序显示该图片，查看完成。</li>
</ol>
<p>由上可知，这个模式的关键是智能DNS，它能够解析出离用户最近的服务器。运行原理大致是：根据请求者的IP得到请求地点B，然后通过计算或者配置得到与B最近或通讯时间最短的服务器C，然后把C的IP地址返回给请求者。这种模式的优缺点如下：</p>
<ul>
<li><strong>优点</strong>：资源下载快、无需过多的开发与配置，同时也减轻了后端服务器对资源的存储压力，减少带宽的使用。</li>
<li><strong>缺点</strong>：目前来说OSS，CDN的价格还是稍微有些贵(虽然已经降价好几次了)，只适用于中小规模的应用，另外由于网络传输的延迟、CDN的同步策略等，会有一些一致性、更新慢方面的问题。</li>
</ul>
<h3 id="五、查询分离模式"><a href="#五、查询分离模式" class="headerlink" title="五、查询分离模式"></a><strong>五、查询分离模式</strong></h3><p>这种模式主要解决单机数据库压力过大，从而导致业务缓慢甚至超时，查询响应时间变长的问题，也包括需要大量数据库服务器计算资源的查询请求。这个可以说是单库单应用模式的升级版本，也是技术架构迭代演进过程中的必经之路。 这种模式的一般设计见下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/29/16eb61a5fcca9706~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p>
<p>如上图所示，这种模式较单库单应用模式与内容分发模式多了几个部分，一个是<strong>业务数据库的主从分离</strong>，一个是<strong>引入了ES</strong>，为什么要这样？都解决了哪些痛点，下面具体结合业务需求场景进行叙述。</p>
<p><strong>场景一：全文关键词检索</strong></p>
<p>我想这个需求，绝大多数应用都会有，如果使用传统的数据库技术，大部分可能都会使用like这种SQL语句，高级一点可能是先分词，然后通过分词index相关的记录。SQL语句的性能问题与全表扫描机制导致了非常严重的性能问题，现在基本上很少见到。 这里的ES是ElasticSearch的缩写，是一种查询引擎，类似的还有Solr等，都差不多的技术，ES较Solr配置简单、使用方便，所以这里选用了它。另外，ES支持横向扩展，理论上没有性能的瓶颈。同时，还支持各种插件、自定义分词器等，可扩展性较强。在这里，使用ES不仅可以替代数据库完成全文检索功能，还可以实现诸如分页、排序、分组、分面等功能。具体的，请同学们自行学习之。那怎么使用呢？一个一般的流程是这样的：</p>
<ol>
<li>服务端把一条业务数据落库</li>
<li>服务端异步把该条数据发送到ES</li>
<li>ES把该条记录按照规则、配置<strong>放入自己的索引库</strong></li>
<li>客户端查询的时候，由服务端把这个<strong>请求发送到ES</strong>，得到数据后，根据需求拼装、组合数据，返回给客户端</li>
</ol>
<p>实际中怎么用，还请同学们根据实际情况做组合、取舍。</p>
<p><strong>场景二：大量的普通查询</strong></p>
<p>这个场景是指我们的业务中的大部分辅助性的查询，如：取钱的时候先查询一下余额，根据用户的ID查询用户的记录，取得该用户最新的一条取钱记录等。我们肯定是要天天要用的，而且用的还非常多。同时呢，我们的写入请求也是非常多的，导致<strong>大量的写入、查询操作压向同一数据库</strong>，然后，数据库挂了，系统挂了，领导生气了，被开除了，还不起房贷了，露宿街头了，老婆跟别人跑了，……</p>
<p>不敢想，所以要求我们必须分散数据库的压力，一个业界较成熟的方案就是数据库的读写分离，<strong>写的时候入主库，读的时候读从库</strong>。这样就把压力分散到不同的数据库了，如果一个读库性能不行，扛不住的话，可以一主多从，横向扩展。可谓是一剂良药啊！那怎么使用呢？一个一般的流程是这样的：</p>
<ol>
<li>服务端把一条业务数据落库</li>
<li>数据库同步或异步或半同步把该条数据<strong>复制</strong>到从库</li>
<li>服务端读数据的时候直接去<strong>从库读</strong>相应的数据</li>
</ol>
<p>比较简单吧，一些聪明的、爱思考的、上进的同学可能发现问题了，也包括上面介绍的场景一，就是延迟问题，如：数据还没有到从库，我就马上读，那么是读不到的，会发生问题的。 对于这个问题，各家公司解决的思路不一样，方法不尽相同。一个普遍的解决方案是：<strong>读不到就读主库</strong>，当然这么说也是有前提条件的，但具体的方案这里就不一一展开了，我可能会在接下来的分享中详解各种方案。 另外，关于数据库的复制模式，还请同学们自行学习，太多了，这里说不清。该总结一下这种模式的优缺点的了，如下：</p>
<ul>
<li><strong>优点</strong>：减少数据库的压力，理论上提供无限高的读性能，间接提高业务(写)的性能，专用的查询、索引、全文(分词)解决方案。</li>
<li><strong>缺点</strong>：数据延迟，数据一致性的保证。</li>
</ul>
<h3 id="六、微服务模式"><a href="#六、微服务模式" class="headerlink" title="六、微服务模式"></a><strong>六、微服务模式</strong></h3><p>上面的模式看似不错，解决了性能问题，我可以不用露宿街头了、老婆还是我的，哈哈。但是</p>
<p>软件系统天生的复杂性决定了，除了性能，还有其他诸如高可用、健壮性等大量问题等待我们解决，再加上各个部门间的撕逼、扯皮，更让我们码农雪上加霜，所以</p>
<p>继续吧……</p>
<p>微服务模式可以说是最近的热点，花花绿绿、大大小小、国内国外的公司都在鼓吹，实践这个模式，可是大部分都没有弄清楚<strong>为什么</strong>要这么做，也并不知道这么做有什么<strong>好处、坏处</strong>，在这里，我将以我自己的亲身实践说一下我对这个模式的看法，不喜勿喷！随着业务与人员的增加，遇到了如下的问题：</p>
<ol>
<li>单机数据库写请求量大量增加，导致数据库压力变大</li>
<li>数据库一旦挂了，那么整个业务都挂了</li>
<li>业务代码越来越多，都在一个GIT里，越来越难以维护</li>
<li>代码腐化严重、臭味越来越浓</li>
<li>上线越来越频繁，经常是一个小功能的修改，就要整个大项目要重新编译</li>
<li>部门越来越多，该哪个部门改动大项目中的哪个东西，撕逼的厉害</li>
<li>其他一些外围系统直接连接数据库，导致一旦数据库结构发生变化，所有的相关系统都要通知，甚至对修改不敏感的系统也要通知</li>
<li>每个应用服务器需要开通所有的权限、网络、FTP、各种各样的，因为每个服务器部署的应用都是一样的</li>
<li>作为架构师，我已经失去了对这个系统的把控……</li>
</ol>
<p>为了解决上述问题，我司使用了微服务模式，这种模式的一般设计见下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/29/16eb61a5fc90d54b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p>
<p>如上图所示，我把<strong>业务分块，做了垂直切分，切成一个个独立的系统，每个系统各自衍化，有自己的库、缓存、ES等辅助系统，系统之间的实时交互通过RPC，异步交互通过MQ，通过这种组合，共同完成整个系统功能。</strong> 那么，这么做是否真的解决上述问题了呢？不玩虚的，一个个来说。对于问题一，由于拆分成了多个子系统，系统的压力被分散了，而各个子系统都有自己的数据库实例，所以数据库的压力变小。</p>
<p>对于问题二，一个子系统A的数据库挂了，只是影响到系统A和使用系统A的那些功能，不会所有的功能不可用，从而解决一个数据库挂了，导致所有功能不可用的问题。</p>
<p>问题三、四，也因为拆分得到了解决，各个子系统有自己独立的GIT代码库，不会相互影响。通用的模块可通过库、服务、平台的形式解决。</p>
<p>问题五，子系统A发生改变，需要上线，那么我只需要编译A，然后上线就可以了，不需要其他系统做同样的事情。</p>
<p>问题六，顺应了<strong>康威定律</strong>，我部门该干什么事、输出什么，也通过服务的形式暴露出来，我部只管把我部的职责、软件功能做好就可以。</p>
<p>问题七，所有需要我部数据的需求，都通过接口的形式发布出去，客户通过接口获取数据，从而屏蔽了底层数据库结构，甚至数据来源，我部只需保证我部的接口契约没有发生变化即可，新的需求增加新的接口，不会影响老的接口。</p>
<p>问题八，不同的子系统需要不同的权限，这个问题也优雅的解决了。</p>
<p>问题九，暂时控制住了复杂性，我只需控制好大的方面，定义好系统边界、接口、大的流程，然后再分而治之、逐个击破、合纵连横。</p>
<p>目前来说，所有问题得到解决！bingo! 但是，还有许多其他的副作用会随之产生，如RPC、MQ的超高稳定性、超高性能，网络延迟，数据一致性等问题，这里就不展开来讲了，太多了，一本书都讲不完。</p>
<p>另外，对于这个模式来说，最难把握的是<strong>度</strong>，切记<strong>不要切分过细</strong>，我见过一个功能一个子系统，上百个方法分成上百个子系统的，真的是太过度了。实践中，一个较为可行的方法是：<strong>能不分就不分，除非有非常必要的理由</strong>！。</p>
<ul>
<li><strong>优点</strong>：相对高性能，可扩展性强，高可用，适合于中等以上规模公司架构。</li>
<li><strong>缺点</strong>：复杂、度不好把握。指不仅需要一个能在高层把控大方向、大流程、总体技术的人，还需要能够针对各个子系统有针对性的开发。把握不好度或者滥用的话，这个模式适得其反！</li>
</ul>
<h3 id="七、多级缓存模式"><a href="#七、多级缓存模式" class="headerlink" title="七、多级缓存模式"></a><strong>七、多级缓存模式</strong></h3><p>这个模式可以说是应对超高查询压力的一种普遍采用的策略，基本的思想就是在所有链路的地方，能加缓存就加缓存，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/29/16eb61a5fe721312~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p>
<p>如上图所示，一般在三个地方加入缓存，一个是客户端处，一个是API网关处，一个是具体的后端业务处，下面分别介绍。</p>
<p><strong>客户端处缓存</strong>：这个地方加缓存可以说是效果最好的—无延迟。因为不用经过长长的网络链条去后端业务处获取数据，从而导致加载时间过长，客户流失等损失。虽然有CDN的支持，但是从客户端到CDN还是有网络延迟的，虽然不大。具体的技术依据不同的客户端而定，对于WEB来讲，有浏览器本地缓存、Cookie、Storage、缓存策略等技术；对于APP来讲，有本地数据库、本地文件、本地内存、进程内缓存支持。以上提到的各种技术有兴趣的同学可以继续展开来学习。如果客户端缓存没有命中，那么就会去后端业务拿数据，一般来讲，都会有个API网关，在这里加缓存也是非常有必要的。</p>
<p><strong>API网关处缓存</strong>：这个地方加缓存的好处是不用把请求发送到后方，直接在这里就处理了，然后返回给请求者。常见的技术，如http请求，API网关用的基本都是nginx，可以使用nginx本身的缓存模块，也可以使用Lua+Redis技术定制化。其他的也都大同小异。</p>
<p><strong>后端业务处</strong>：这个我想就不用多说了，大家应该差不多都知道，什么Redis,Memcache,Jvm内等等，不熬述了。</p>
<p>实践中，要结合具体的实际情况，综合利用各级缓存技术，使得各种请求最大程度的在到达后端业务之前就被解决掉，从而减少后端服务压力、减少占用带宽、增强用户体验。至于是否只有这三个地方加缓存，我觉得要活学活用，<strong>心法比剑法重要！</strong>总结一下这个模式的优缺点：</p>
<ul>
<li><strong>优点</strong>：抗住大量读请求，减少后端压力。</li>
<li><strong>缺点</strong>：数据一致性问题较突出，容易发生雪崩，即：如果客户端缓存失效、API网关缓存失效，那么所有的大量请求瞬间压向后端业务系统，后果可想而知。</li>
</ul>
<h3 id="八、分库分表模式"><a href="#八、分库分表模式" class="headerlink" title="八、分库分表模式"></a><strong>八、分库分表模式</strong></h3><p>这种模式主要解决单表写入、读取、存储压力过大，从而导致业务缓慢甚至超时，交易失败，容量不够的问题。一般有水平切分和垂直切分两种，这里主要介绍水平切分。这个模式也是技术架构迭代演进过程中的必经之路。 这种模式的一般设计见下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/29/16eb61a717cfbdbf~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p>
<p>如上图所示红色部分，把一张表分到了几个不同的库中，从而分担压力。是不是很笼统？哈哈，那我们接下来就详细的讲解一下。首先澄清几个概念，如下： <strong>主机</strong>：硬件，指一台物理机，或者虚拟机，有自己的CPU，内存，硬盘等。 <strong>实例</strong>：数据库实例，如一个MySQL服务进程。一个主机可以有多个实例，不同的实例有不同的进程，监听不同的端口。 <strong>库</strong>：指表的集合，如学校库，可能包含教师表、学生表、食堂表等等，这些表在一个库中。一个实例中可以有多个库。库与库之间用库名来区分。 <strong>表</strong>：库中的表，不必多说，不懂的就不用往下看了，不解释。</p>
<p>那么怎么把单表分散呢？到底怎么个分发呢？分发到哪里呢？以下是几个工作中的实践，分享一下： <strong>主机</strong>：这是最主要的也是最重要的点，本质上分库分表是因为计算与存储资源不够导致的，而这种资源主要是由物理机，主机提供的，所以在这里分是最基本的，毕竟没有可用的计算资源，怎么分效果都不是太好的。 实例：实例控制着连接数，同时受OS限制，CPU、内存、硬盘、网络IO也会受间接影响。会出现热实例的现象，即：有些实例特别忙，有些实例非常的空闲。一个典型的现象是：由于单表反应慢，导致连接池被打满，所有其他的业务都受影响了。这时候，把表分到不同的实例是有一些效果的。 库：一般是由于单库中最大单表数量的限制，才采取分库。 表：单表压力过大，索引量大，容量大，单表的锁。据以上，把单表水平切分成不同的表。</p>
<p>大型应用中，都是一台主机上只有一个实例，一个实例中只有一个库，<strong>库实例主机，所以才有了分库分表</strong>这个简称。</p>
<p>既然知道了基本理论，那么具体是怎么做的呢？逻辑是怎么跑的呢？接下来以一个例子来讲解一下。 这个需求很简单，用户表(user)，单表数据量1亿，查询、插入、存储都出现了问题，怎么办呢？</p>
<p>首先，分析问题，这个明显是由于数据量太大了而导致的问题。 其次，设计方案，可以分为10个库，这样每个库的数据量就降到了1KW，单表1KW数据量还是有些大，而且不利于以后量的增长，所以每个库再分100个表，这个每个单表数据量就为10W了，对于查询、索引更新、单表文件大小、打开速度，都有一些益处。接下来，给IT部门打电话，要10台物理机，扩展数据库…… 最后，逻辑实现，这里应该是最有学问的地方。首先是写入数据，需要知道写到哪个分库分表中，读也是一样的，所以，需要有个请求<strong>路由层</strong>，负责把请求分发、转换到不同的库表中，一般有路由规则的概念。</p>
<p>怎么样，简单吧？哈哈，too 那义务。说说这个模式的问题，主要是带来了事务上的问题，因为分库分表，事务完成不了，而<strong>分布式事务</strong>又太笨重，所以这里需要有一定的策略，保证在这种情况下事务能够完成。采取的策略如：最终一致性、复制、特殊设计等。再有就是业务代码的改造，一些关联查询要改造，一些单表orderBy的问题需要特殊处理，也包括groupBy语句，如何解决这些副作用不是一句两句能说清楚的，以后有时间，我单独讲讲这些。</p>
<p>该总结一下这种模式的优缺点的了，如下：</p>
<ul>
<li><strong>优点</strong>：减少数据库单表的压力。</li>
<li><strong>缺点</strong>：事务保证困难、业务逻辑需要做大量改造。</li>
</ul>
<h3 id="九、弹性伸缩模式"><a href="#九、弹性伸缩模式" class="headerlink" title="九、弹性伸缩模式"></a><strong>九、弹性伸缩模式</strong></h3><p>这种模式主要解决突发流量的到来，导致无法横向扩展或者横向扩展太慢，进而影响业务，全站崩溃的问题。这个模式是一种相对来说比较高级的技术，也是各个大公司目前都在研究、试用的技术。截至今日，有这种思想的架构师就已经是很不错了，能够拿到较高薪资，更别提那些已经实践过的，甚至实现了底层系统的那些，所以，你懂得…… 这种模式的一般设计见下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/29/16eb61a719a46586~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p>
<p>如上图所示，多了一个弹性伸缩服务，用来动态的增加、减少实例。原理上非常简单，但是这个模式到底解决什么问题呢？先说说由来和意义。</p>
<p>每年的双11、六一八或者一些大促到来之前，我们都会为大流量的到来做以下几个方面的工作: 提前准备10倍甚至更多的机器，即使用不上也要放在那里备着，以防万一。这样浪费了大量的资源。 每台机器配置、调试、引流，以便让所有的机器都可用。这样浪费了大量的人力、物力，更容易出错。 如果机器准备不充分，那么还要加班加点的重复上面的工作。这样做特别容易出错，引来领导的不满，没时间回家陪老婆，然后你的老婆就……(自己想)</p>
<p>在双十一之后，我们还要人工做缩容，非常的辛苦。一般一年中会有多次促销，那么我们就会一直这样，实在是烦！</p>
<p>最严重的，<strong>突然间的大流量爆发，会让我们触不及防</strong>，半夜起来扩容是在正常不过的事情，为此，我们偷懒起来，要更多的机器备着，也就出现了大量的cpu利用率为1%的机器。</p>
<p>我相信，如果你是老板一定很<strong>震惊</strong>吧！！！ 哈哈，那么如何改变这种情况呢？请接着看</p>
<p>为此，首先把所有的计算资源整合成资源池的概念，然后通过一些策略、监控、服务，动态的从资源池中获取资源，用完后在放回到池子中，供其他系统使用。 具体实现上比较成熟的两种资源池方案是VM、docker，每个都有着自己强大的生态。监控的点有CPU、内存、硬盘、网络IO、服务质量等，根据这些，在配合一些预留、扩张、收缩策略，就可以简单的实现自动伸缩。怎么样？是不是很神奇？深入的内容我们会在的码农原创的公众号文章中详细介绍。</p>
<p>该总结一下这种模式的优缺点的了，如下：</p>
<ul>
<li><strong>优点</strong>：弹性、随需计算，充分优化企业计算资源。</li>
<li><strong>缺点</strong>：应用要从架构层做到可横向扩展化改造、依赖的底层配套比较多，对技术水平、实力、应用规模要求较高。</li>
</ul>
<h3 id="十、多机房模式"><a href="#十、多机房模式" class="headerlink" title="十、多机房模式"></a><strong>十、多机房模式</strong></h3><p>这种模式主要解决<strong>不同地区高性能、高可用</strong>的问题。</p>
<p>随着应用用户不断的增加，用户群体分布在全球各地，如果把服务器部署在一个地方，一个机房，比如北京，那么美国的用户使用应用的时候就会特别慢，因为每一个请求都需要通过海底光缆走上个那么一秒钟(预估)左右，这样对用户体验及其不好。怎么办？使用多机房部署。</p>
<p>这种模式的一般设计见下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/29/16eb61a7198c976d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p>
<p>如上图所示，一个典型的用户请求流程如下：</p>
<p>用户请求一个链接A 通过DNS智能解析到离用户最近的机房B 使用B机房服务链接A</p>
<p>是不是觉得很简单，没啥？其实这里面的问题没有表面这么简单，下面一一道来。 首先是<strong>数据同步</strong>问题，在中国产生的数据要同步到美国，美国的也一样，数据同步就会涉及数据版本、一致性、更新丢弃、删除等问题。 其次是一地多机房的请求<strong>路由</strong>问题，典型的是如上图，中国的北京机房和杭州机房，如果北京机房挂了，那么要能够通过路由把所有发往北京机房的请求转发到杭州机房。异地也存在这个问题。</p>
<p>所以，多机房模式，也就是异地多活并不是那么的简单，这里只是起了个头，具体的有哪些坑，会在另一篇文章中介绍。</p>
<p>该总结一下这种模式的优缺点的了，如下：</p>
<ul>
<li><strong>优点</strong>：高可用、高性能、异地多活。</li>
<li><strong>缺点</strong>：数据同步、数据一致性、请求路由。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chabai000.github.io">茶白</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chabai000.github.io/posts/17883/">https://chabai000.github.io/posts/17883/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chabai000.github.io" target="_blank">茶白的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a></div><div class="post_share"><div class="social-share" data-image="/UpPictures/UpCover/%E5%85%AB%E8%82%A1%E6%96%87%E5%B0%81%E9%9D%A2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/%E8%B5%9E%E8%B5%8F%E7%A0%81.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E8%B5%9E%E8%B5%8F%E7%A0%81.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/62590/" title="mybatis3-5-7"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/MybatisCover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">mybatis3-5-7</div></div></a></div><div class="next-post pull-right"><a href="/posts/29325/" title="SpringBoot2.5"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/SpringBoot.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot2.5</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/2740/" title="SpringMvc"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/SpringMVCCover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-29</div><div class="title">SpringMvc</div></div></a></div><div><a href="/posts/29325/" title="SpringBoot2.5"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/SpringBoot.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-12</div><div class="title">SpringBoot2.5</div></div></a></div><div><a href="/posts/62590/" title="mybatis3-5-7"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/MybatisCover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-24</div><div class="title">mybatis3-5-7</div></div></a></div><div><a href="/posts/44170/" title="mybatis3.4.1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/MybatisCover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-28</div><div class="title">mybatis3.4.1</div></div></a></div><div><a href="/posts/39655/" title="spring5"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/SpringCover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-01</div><div class="title">spring5</div></div></a></div><div><a href="/posts/39847/" title="spring6"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/SpringCover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-24</div><div class="title">spring6</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">茶白</div><div class="author-info__description">不论你在什么时候开始，重要的是开始之后就不要停止；不论你在什么时候结束，重要的是结束之后就不要悔恨</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/chabai000"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chabai000" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1693522579@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">Java基础常见面试题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">1.Java的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Java%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2.Java是如何实现跨平台的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Java-%E4%B8%8E-C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">3.Java 与 C++ 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-JDK-JRE-JVM%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.</span> <span class="toc-text">4.JDK&#x2F;JRE&#x2F;JVM三者的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Java%E7%A8%8B%E5%BA%8F%E6%98%AF%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E8%BF%98%E6%98%AF%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">5.Java程序是编译执行还是解释执行？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">6.面向对象和面向过程的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">7.面向对象有哪些特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">1.8.</span> <span class="toc-text">8.面向对象编程的六大原则?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%95%B0%E7%BB%84%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">9.数组到底是不是对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">10.Java的基本数据类型有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E6%B5%AE%E7%82%B9%E5%9E%8B%E8%A1%A8%E7%A4%BA%E9%87%91%E9%A2%9D%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">11.为什么不能用浮点型表示金额？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E4%BB%80%E4%B9%88%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">12.什么是值传递和引用传递？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E4%BA%86%E8%A7%A3Java%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">13.了解Java的包装类型吗？为什么需要包装类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-number">1.14.</span> <span class="toc-text">14.自动装箱和拆箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-String-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%9F"><span class="toc-number">1.15.</span> <span class="toc-text">15.String 为什么不可变？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E4%B8%BA%E4%BD%95JDK9%E8%A6%81%E5%B0%86String%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%94%B1char-%E6%94%B9%E6%88%90byte"><span class="toc-number">1.16.</span> <span class="toc-text">16.为何JDK9要将String的底层实现由char[]改成byte[]?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-String-StringBuffer-%E5%92%8C-StringBuilder%E5%8C%BA%E5%88%AB"><span class="toc-number">1.17.</span> <span class="toc-text">17.String, StringBuffer 和 StringBuilder区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E4%BB%80%E4%B9%88%E6%98%AFStringJoiner%EF%BC%9F"><span class="toc-number">1.18.</span> <span class="toc-text">18.什么是StringJoiner？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-String-%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.19.</span> <span class="toc-text">19.String 类的常用方法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-new-String-%E2%80%9Cdabin%E2%80%9D-%E4%BC%9A%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">1.20.</span> <span class="toc-text">20.new String(“dabin”)会创建几个对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F"><span class="toc-number">1.21.</span> <span class="toc-text">21.什么是字符串常量池？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-String%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">1.22.</span> <span class="toc-text">22.String最大长度是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-Object%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.23.</span> <span class="toc-text">23.Object常用方法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E8%AE%B2%E8%AE%B2%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">1.24.</span> <span class="toc-text">24.讲讲深拷贝和浅拷贝？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84hashCode-%E7%9B%B8%E5%90%8C%EF%BC%8C%E5%88%99-equals-%E6%98%AF%E5%90%A6%E4%B9%9F%E4%B8%80%E5%AE%9A%E4%B8%BA-true%EF%BC%9F"><span class="toc-number">1.25.</span> <span class="toc-text">25.两个对象的hashCode()相同，则 equals()是否也一定为 true？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E4%B8%80%E5%AE%9A%E8%A6%81%E9%87%8D%E5%86%99-hashCode%EF%BC%9F"><span class="toc-number">1.26.</span> <span class="toc-text">26.为什么重写 equals 时一定要重写 hashCode？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.27.</span> <span class="toc-text">27.Java创建对象有几种方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E8%AF%B4%E8%AF%B4%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.28.</span> <span class="toc-text">28.说说类实例化的顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-equals%E5%92%8C-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.29.</span> <span class="toc-text">29.equals和&#x3D;&#x3D;有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.30.</span> <span class="toc-text">30.常见的关键字有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-final-finally-finalize-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.31.</span> <span class="toc-text">31.final, finally, finalize 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.32.</span> <span class="toc-text">32.final关键字的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.33.</span> <span class="toc-text">33.方法重载和重写的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.34.</span> <span class="toc-text">34.接口与抽象类区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E5%B8%B8%E8%A7%81%E7%9A%84Exception%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.35.</span> <span class="toc-text">35.常见的Exception有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-Error%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.36.</span> <span class="toc-text">36.Error和Exception的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E9%9D%9E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%EF%BC%88checked%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.37.</span> <span class="toc-text">37.运行时异常和非运行时异常（checked）的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.38.</span> <span class="toc-text">38.throw和throws的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E9%80%9A%E8%BF%87%E6%95%85%E4%BA%8B%E8%AE%B2%E6%B8%85%E6%A5%9ANIO"><span class="toc-number">1.39.</span> <span class="toc-text">39.通过故事讲清楚NIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-BIO-NIO-AIO%E5%8C%BA%E5%88%AB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.40.</span> <span class="toc-text">40.BIO&#x2F;NIO&#x2F;AIO区别的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.41.</span> <span class="toc-text">41.守护线程是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-Java%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%90%97%EF%BC%9F"><span class="toc-number">1.42.</span> <span class="toc-text">42.Java支持多继承吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%9F"><span class="toc-number">1.43.</span> <span class="toc-text">43.如何实现对象克隆？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.44.</span> <span class="toc-text">44.同步和异步的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.45.</span> <span class="toc-text">45.阻塞和非阻塞的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.46.</span> <span class="toc-text">46.Java8的新特性有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.47.</span> <span class="toc-text">47.序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%91%A2"><span class="toc-number">1.48.</span> <span class="toc-text">48.什么时候需要用到序列化和反序列化呢?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%9E%E7%8E%B0-Serializable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.49.</span> <span class="toc-text">49.实现序列化和反序列化为什么要实现 Serializable 接口?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50-%E5%AE%9E%E7%8E%B0-Serializable-%E6%8E%A5%E5%8F%A3%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9A-serialVersionUID-%E7%9A%84%E5%80%BC"><span class="toc-number">1.50.</span> <span class="toc-text">50.实现 Serializable 接口之后，为什么还要显示指定 serialVersionUID 的值?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-static-%E5%B1%9E%E6%80%A7%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.51.</span> <span class="toc-text">51.static 属性为什么不会被序列化?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-transient%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.52.</span> <span class="toc-text">52.transient关键字的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-number">1.53.</span> <span class="toc-text">53.什么是反射？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E5%8F%8D%E5%B0%84%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%91%A2%EF%BC%9F"><span class="toc-number">1.54.</span> <span class="toc-text">54.反射有哪些应用场景呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E8%AE%B2%E8%AE%B2%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.55.</span> <span class="toc-text">55.讲讲什么是泛型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.56.</span> <span class="toc-text">56.如何停止一个正在运行的线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%9F"><span class="toc-number">1.57.</span> <span class="toc-text">57.什么是跨域？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%91%A2%EF%BC%9F"><span class="toc-number">1.58.</span> <span class="toc-text">58.跨域问题怎么解决呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88"><span class="toc-number">1.59.</span> <span class="toc-text">59.设计接口要注意什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.60.</span> <span class="toc-text">60.过滤器和拦截器有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E5%AF%B9%E6%8E%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%8F%A3%E8%A6%81%E8%80%83%E8%99%91%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.61.</span> <span class="toc-text">61.对接第三方接口要考虑什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.62.</span> <span class="toc-text">62.后端接口性能优化有哪些方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E4%B8%AD%E5%BC%BA%E5%88%B6%E8%A6%81%E6%B1%82%E4%BD%BF%E7%94%A8%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%91%A2%EF%BC%9F"><span class="toc-number">1.63.</span> <span class="toc-text">63.为什么在阿里巴巴Java开发手册中强制要求使用包装类型定义属性呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-8%E6%8B%9B%E8%AE%A9%E6%8E%A5%E5%8F%A3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87100%E5%80%8D"><span class="toc-number">1.64.</span> <span class="toc-text">64.8招让接口性能提升100倍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9B%86%E5%90%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">常见的集合有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List-%E3%80%81Set%E5%92%8CMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">List 、Set和Map 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">ArrayList 了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">ArrayList 的扩容机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%9C%A8%E9%81%8D%E5%8E%86-ArrayList-%E6%97%B6%E7%A7%BB%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">怎么在遍历 ArrayList 时移除一个元素？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arraylist-%E5%92%8C-Vector-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.6.</span> <span class="toc-text">Arraylist 和 Vector 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arraylist-%E4%B8%8E-LinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.</span> <span class="toc-text">Arraylist 与 LinkedList的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-number">2.8.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E7%9A%84%E5%8A%9E%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FHashMap%E7%94%A8%E7%9A%84%E5%93%AA%E7%A7%8D%EF%BC%9F"><span class="toc-number">2.8.1.</span> <span class="toc-text">解决hash冲突的办法有哪些？HashMap用的哪种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%9A%84hash%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">2.8.2.</span> <span class="toc-text">使用的hash算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E8%AE%BE%E7%BD%AEHashMap%E7%9A%84%E5%AE%B9%E9%87%8F%EF%BC%9F"><span class="toc-number">2.8.3.</span> <span class="toc-text">为什么建议设置HashMap的容量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.8.4.</span> <span class="toc-text">扩容过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.8.5.</span> <span class="toc-text">put方法流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">2.8.6.</span> <span class="toc-text">红黑树的特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E8%A7%A3%E5%86%B3-hash-%E5%86%B2%E7%AA%81%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E5%85%88%E7%94%A8%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%86%8D%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.8.7.</span> <span class="toc-text">在解决 hash 冲突的时候，为什么选择先用链表，再转红黑树?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2-%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9%EF%BC%9F"><span class="toc-number">2.8.8.</span> <span class="toc-text">HashMap 的长度为什么是 2 的幂次方？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E9%BB%98%E8%AE%A4%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-0-75%EF%BC%9F"><span class="toc-number">2.8.9.</span> <span class="toc-text">HashMap默认加载因子是多少？为什么是 0.75？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E7%94%A8%E4%BB%80%E4%B9%88%E4%BD%9C%E4%B8%BAHashMap%E7%9A%84key"><span class="toc-number">2.8.10.</span> <span class="toc-text">一般用什么作为HashMap的key?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">2.8.11.</span> <span class="toc-text">HashMap为什么线程不安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.8.12.</span> <span class="toc-text">HashMap和HashTable的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">LinkedHashMap底层原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8BTreeMap%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">讲一下TreeMap？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">2.11.</span> <span class="toc-text">HashSet底层原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.12.</span> <span class="toc-text">HashSet、LinkedHashSet 和 TreeSet 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFfail-fast%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">什么是fail fast？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFfail-safe%EF%BC%9F"><span class="toc-number">2.14.</span> <span class="toc-text">什么是fail safe？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8BArrayDeque%EF%BC%9F"><span class="toc-number">2.15.</span> <span class="toc-text">讲一下ArrayDeque？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E7%B1%BB%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">2.16.</span> <span class="toc-text">哪些集合类是线程安全的？哪些不安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.17.</span> <span class="toc-text">迭代器 Iterator 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator-%E5%92%8C-ListIterator-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.18.</span> <span class="toc-text">Iterator 和 ListIterator 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E4%B8%8D%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9%EF%BC%9F"><span class="toc-number">2.19.</span> <span class="toc-text">如何让一个集合不能被修改？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">2.20.</span> <span class="toc-text">并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">2.20.1.</span> <span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#put%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.20.1.1.</span> <span class="toc-text">put执行流程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9%EF%BC%9F"><span class="toc-number">2.20.1.2.</span> <span class="toc-text">怎么扩容？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.20.1.3.</span> <span class="toc-text">ConcurrentHashMap 和 Hashtable 的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWrite"><span class="toc-number">2.20.2.</span> <span class="toc-text">CopyOnWrite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">2.20.3.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentLinkedQueue"><span class="toc-number">2.20.4.</span> <span class="toc-text">ConcurrentLinkedQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">2.20.5.</span> <span class="toc-text">阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK%E6%8F%90%E4%BE%9B%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">2.20.5.1.</span> <span class="toc-text">JDK提供的阻塞队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.20.5.2.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">3.1.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B9%B3%E6%97%B6%E9%83%BD%E6%98%AF%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E7%9B%B4%E6%8E%A5new%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%A5%BD%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">为什么平时都是使用线程池创建线程，直接new一个线程不好吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">3.1.2.</span> <span class="toc-text">为什么使用线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">3.1.3.</span> <span class="toc-text">线程池执行原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.1.4.</span> <span class="toc-text">线程池参数有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%EF%BC%9F"><span class="toc-number">3.1.5.</span> <span class="toc-text">线程池大小怎么设置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">3.1.6.</span> <span class="toc-text">线程池的类型有哪些？适用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%98%AF%E4%B8%8D%E6%98%AF%E6%89%A7%E8%A1%8C%E5%AE%8C%E4%BA%86%EF%BC%9F"><span class="toc-number">3.1.7.</span> <span class="toc-text">怎么判断线程池的任务是不是执行完了？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A1%86%E6%9E%B6%E5%91%A2%EF%BC%9F"><span class="toc-number">3.1.8.</span> <span class="toc-text">为什么要使用Executor线程池框架呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#execute%E5%92%8Csubmit%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">execute和submit的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">进程线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.3.1.</span> <span class="toc-text">线程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%EF%BC%9F"><span class="toc-number">3.3.2.</span> <span class="toc-text">讲讲线程中断？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">3.3.3.</span> <span class="toc-text">创建线程有哪几种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">3.3.4.</span> <span class="toc-text">什么是线程死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%EF%BC%9F%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-number">3.3.5.</span> <span class="toc-text">线程死锁怎么产生？怎么避免？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8Brun%E5%92%8Cstart%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.3.6.</span> <span class="toc-text">线程run和start的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">3.3.7.</span> <span class="toc-text">线程都有哪些方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">3.3.8.</span> <span class="toc-text">如何停止一个正在运行的线程？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">volatile底层原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">volatile为什么不能保证原子性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E7%9A%84%E7%94%A8%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.6.</span> <span class="toc-text">synchronized的用法有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E7%9A%84%E4%BD%9C%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.7.</span> <span class="toc-text">synchronized的作用有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">3.8.</span> <span class="toc-text">synchronized 底层实现原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E5%92%8Csynchronized%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">volatile和synchronized的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock%E5%92%8Csynchronized%E5%8C%BA%E5%88%AB"><span class="toc-number">3.10.</span> <span class="toc-text">ReentrantLock和synchronized区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait-%E5%92%8Csleep-%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9%EF%BC%9F"><span class="toc-number">3.11.</span> <span class="toc-text">wait()和sleep()的异同点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Runnable%E5%92%8CCallable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.12.</span> <span class="toc-text">Runnable和Callable有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%80%8E%E4%B9%88%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-number">3.13.</span> <span class="toc-text">线程执行顺序怎么控制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.14.</span> <span class="toc-text">守护线程是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">3.15.</span> <span class="toc-text">线程间通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">3.16.</span> <span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%8E%9F%E7%90%86"><span class="toc-number">3.16.1.</span> <span class="toc-text">ThreadLocal原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-number">3.16.2.</span> <span class="toc-text">ThreadLocal内存泄漏的原因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.16.3.</span> <span class="toc-text">ThreadLocal使用场景有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAQS%EF%BC%9F"><span class="toc-number">3.17.</span> <span class="toc-text">什么是AQS？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88AQS%E6%98%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8D%95%E5%90%91%E7%9A%84%EF%BC%9F"><span class="toc-number">3.18.</span> <span class="toc-text">为什么AQS是双向链表而不是单向的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS%E5%8E%9F%E7%90%86"><span class="toc-number">3.19.</span> <span class="toc-text">AQS原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7%E7%9A%84"><span class="toc-number">3.20.</span> <span class="toc-text">ReentrantLock 是如何实现可重入性的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.21.</span> <span class="toc-text">锁的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">3.21.1.</span> <span class="toc-text">公平锁与非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%BC%8F%E4%B8%8E%E7%8B%AC%E5%8D%A0%E5%BC%8F%E9%94%81"><span class="toc-number">3.21.2.</span> <span class="toc-text">共享式与独占式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">3.21.3.</span> <span class="toc-text">悲观锁与乐观锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">3.22.</span> <span class="toc-text">乐观锁有什么问题?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCAS%EF%BC%9F"><span class="toc-number">3.23.</span> <span class="toc-text">什么是CAS？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.24.</span> <span class="toc-text">CAS存在的问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-number">3.25.</span> <span class="toc-text">并发工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">3.25.1.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">3.25.2.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CyclicBarrier%E5%92%8CCountDownLatch%E5%8C%BA%E5%88%AB"><span class="toc-number">3.25.3.</span> <span class="toc-text">CyclicBarrier和CountDownLatch区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore"><span class="toc-number">3.25.4.</span> <span class="toc-text">Semaphore</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">3.26.</span> <span class="toc-text">原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">3.26.1.</span> <span class="toc-text">基本类型原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">3.26.2.</span> <span class="toc-text">数组类型原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">3.26.3.</span> <span class="toc-text">引用类型原子类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDaemon%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">3.27.</span> <span class="toc-text">什么是Daemon线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SynchronizedMap%E5%92%8CConcurrentHashMap%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.28.</span> <span class="toc-text">SynchronizedMap和ConcurrentHashMap有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFFuture%EF%BC%9F"><span class="toc-number">3.29.</span> <span class="toc-text">什么是Future？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select%E3%80%81poll%E3%80%81epoll%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.30.</span> <span class="toc-text">select、poll、epoll之间的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReadWriteLock-%E5%92%8C-StampedLock-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.31.</span> <span class="toc-text">ReadWriteLock 和 StampedLock 的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">4.1.</span> <span class="toc-text">泛型带来的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E4%B8%AD%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">4.2.</span> <span class="toc-text">泛型中通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-T%EF%BC%8CE%EF%BC%8CK%EF%BC%8CV%EF%BC%8C%EF%BC%9F"><span class="toc-number">4.2.1.</span> <span class="toc-text">常用的 T，E，K，V，？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%9F%E6%97%A0%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">4.2.2.</span> <span class="toc-text">？无界通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6-extends-E"><span class="toc-number">4.2.3.</span> <span class="toc-text">上界通配符 &lt; ? extends E&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6-super-E"><span class="toc-number">4.2.4.</span> <span class="toc-text">下界通配符 &lt; ? super E&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%9F%E5%92%8C-T-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.5.</span> <span class="toc-text">？和 T 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB1%EF%BC%9A%E9%80%9A%E8%BF%87-T-%E6%9D%A5-%E7%A1%AE%E4%BF%9D-%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">4.2.5.1.</span> <span class="toc-text">区别1：通过 T 来 确保 泛型参数的一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB2%EF%BC%9A%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%A4%9A%E9%87%8D%E9%99%90%E5%AE%9A%E8%80%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8D%E8%A1%8C"><span class="toc-number">4.2.5.2.</span> <span class="toc-text">区别2：类型参数可以多重限定而通配符不行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB3%EF%BC%9A%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E8%B6%85%E7%B1%BB%E9%99%90%E5%AE%9A%E8%80%8C%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E4%B8%8D%E8%A1%8C"><span class="toc-number">4.2.5.3.</span> <span class="toc-text">区别3：通配符可以使用超类限定而类型参数不行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class%E5%92%8C-Class%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">Class&lt;T&gt;和 Class&lt;?&gt;区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#jvm"><span class="toc-number">5.</span> <span class="toc-text">jvm</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJVM%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">什么是JVM？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8BJVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">讲一下JVM内存结构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">Java对象的定位方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%A0%86%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">说一下堆栈的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">什么情况下会发生栈溢出？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">5.6.</span> <span class="toc-text">类文件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">5.7.</span> <span class="toc-text">什么是类加载？类加载的过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">5.8.</span> <span class="toc-text">什么是双亲委派模型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">5.9.</span> <span class="toc-text">为什么需要双亲委派模型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">5.10.</span> <span class="toc-text">什么是类加载器，类加载器有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">5.11.</span> <span class="toc-text">类的实例化顺序？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%EF%BC%9F"><span class="toc-number">5.12.</span> <span class="toc-text">如何判断一个对象是否存活？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%BD%9C%E4%B8%BAGC-Roots%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.13.</span> <span class="toc-text">可作为GC Roots的对象有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%B1%BB%E4%BC%9A%E8%A2%AB%E5%8D%B8%E8%BD%BD%EF%BC%9F"><span class="toc-number">5.14.</span> <span class="toc-text">什么情况下类会被卸载？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.15.</span> <span class="toc-text">强引用、软引用、弱引用、虚引用是什么，有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81GC%EF%BC%9F"><span class="toc-number">5.16.</span> <span class="toc-text">GC是什么？为什么要GC？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Minor-GC-%E5%92%8C-Full-GC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.17.</span> <span class="toc-text">Minor GC 和 Full GC的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-number">5.18.</span> <span class="toc-text">内存的分配策略？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Full-GC-%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="toc-number">5.19.</span> <span class="toc-text">Full GC 的触发条件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.20.</span> <span class="toc-text">垃圾回收算法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="toc-number">5.21.</span> <span class="toc-text">有哪些垃圾回收器？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%91%BD%E4%BB%A4%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.22.</span> <span class="toc-text">常用的 JVM 调优的命令都有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">5.23.</span> <span class="toc-text">对象头了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-o-new-Object-%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="toc-number">5.24.</span> <span class="toc-text">Object o &#x3D; new Object()占用多少个字节？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">5.25.</span> <span class="toc-text">main方法执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">5.26.</span> <span class="toc-text">对象创建过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5-OOM-%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">5.27.</span> <span class="toc-text">如何排查 OOM 的问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%9F"><span class="toc-number">5.28.</span> <span class="toc-text">什么是内存溢出和内存泄露？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java8"><span class="toc-number">6.</span> <span class="toc-text">java8</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">6.1.</span> <span class="toc-text">函数式编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">Lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.3.</span> <span class="toc-text">函数式接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.4.</span> <span class="toc-text">内置的函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Predicate-%E6%96%AD%E8%A8%80"><span class="toc-number">6.4.1.</span> <span class="toc-text">Predicate 断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Comparator"><span class="toc-number">6.4.2.</span> <span class="toc-text">Comparator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Consumer"><span class="toc-number">6.4.3.</span> <span class="toc-text">Consumer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream"><span class="toc-number">6.5.</span> <span class="toc-text">Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Filter-%E8%BF%87%E6%BB%A4"><span class="toc-number">6.5.1.</span> <span class="toc-text">Filter 过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sorted-%E6%8E%92%E5%BA%8F"><span class="toc-number">6.5.2.</span> <span class="toc-text">Sorted 排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.5.3.</span> <span class="toc-text">Map 转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Match-%E5%8C%B9%E9%85%8D"><span class="toc-number">6.5.4.</span> <span class="toc-text">Match 匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Count-%E8%AE%A1%E6%95%B0"><span class="toc-number">6.5.5.</span> <span class="toc-text">Count 计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reduce"><span class="toc-number">6.5.6.</span> <span class="toc-text">Reduce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flatMap"><span class="toc-number">6.5.7.</span> <span class="toc-text">flatMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parallel-Streams"><span class="toc-number">6.6.</span> <span class="toc-text">Parallel-Streams</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88"><span class="toc-number">6.7.</span> <span class="toc-text">Map集合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tomcat"><span class="toc-number">7.</span> <span class="toc-text">tomcat</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">7.1.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%89%A7%E8%A1%8C"><span class="toc-number">7.2.</span> <span class="toc-text">各组件的实现与执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.2.1.</span> <span class="toc-text">组件实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">7.2.2.</span> <span class="toc-text">启动流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">7.2.3.</span> <span class="toc-text">执行流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">7.3.</span> <span class="toc-text">配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Server-xml-%E9%87%8D%E7%82%B9"><span class="toc-number">7.3.1.</span> <span class="toc-text">Server.xml(重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Server"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">Server</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Service"><span class="toc-number">7.3.1.2.</span> <span class="toc-text">Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executor"><span class="toc-number">7.3.1.3.</span> <span class="toc-text">Executor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Connector"><span class="toc-number">7.3.1.4.</span> <span class="toc-text">Connector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Engine"><span class="toc-number">7.3.1.5.</span> <span class="toc-text">Engine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Host"><span class="toc-number">7.3.1.6.</span> <span class="toc-text">Host</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Context"><span class="toc-number">7.3.1.7.</span> <span class="toc-text">Context</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tomcat-user-xml-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">7.3.2.</span> <span class="toc-text">tomcat-user.xml(权限管理)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-xml-%E4%B8%8D%E5%B8%B8%E7%94%A8"><span class="toc-number">7.3.3.</span> <span class="toc-text">Web.xml(不常用)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ServletContext-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A8%E5%B1%80%E5%8F%82%E6%95%B0"><span class="toc-number">7.3.3.1.</span> <span class="toc-text">ServletContext 初始化全局参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E8%AE%BE%E7%BD%AE"><span class="toc-number">7.3.3.2.</span> <span class="toc-text">会话设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet-%E9%85%8D%E7%BD%AE"><span class="toc-number">7.3.3.3.</span> <span class="toc-text">Servlet 配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Listener-%E9%85%8D%E7%BD%AE"><span class="toc-number">7.3.3.4.</span> <span class="toc-text">Listener 配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Filter-%E9%85%8D%E7%BD%AE"><span class="toc-number">7.3.3.5.</span> <span class="toc-text">Filter 配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AC%A2%E8%BF%8E%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE"><span class="toc-number">7.3.3.6.</span> <span class="toc-text">欢迎页面配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE"><span class="toc-number">7.3.3.7.</span> <span class="toc-text">错误页面配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">7.4.</span> <span class="toc-text">安全与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8"><span class="toc-number">7.4.1.</span> <span class="toc-text">安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%AE%89%E5%85%A8"><span class="toc-number">7.4.1.1.</span> <span class="toc-text">配置安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8"><span class="toc-number">7.4.1.2.</span> <span class="toc-text">应用安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8"><span class="toc-number">7.4.1.3.</span> <span class="toc-text">传输安全</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">7.4.2.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-number">7.4.2.1.</span> <span class="toc-text">性能测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM-%E4%BC%98%E5%8C%96"><span class="toc-number">7.4.2.2.</span> <span class="toc-text">JVM 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tomcat-%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96"><span class="toc-number">7.4.2.3.</span> <span class="toc-text">Tomcat 配置优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat-%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD-WebSocket"><span class="toc-number">7.5.</span> <span class="toc-text">Tomcat 附加功能 WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket-%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-number">7.5.1.</span> <span class="toc-text">WebSocket 请求过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#spring"><span class="toc-number">8.</span> <span class="toc-text">spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">8.1.</span> <span class="toc-text">Spring的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">Spring 用到了哪些设计模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAOP%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">什么是AOP？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">8.4.</span> <span class="toc-text">AOP有哪些实现方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">8.5.</span> <span class="toc-text">Spring AOP的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.6.</span> <span class="toc-text">JDK动态代理和CGLIB动态代理的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-number">8.7.</span> <span class="toc-text">Spring AOP相关术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E9%80%9A%E7%9F%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">8.8.</span> <span class="toc-text">Spring通知有哪些类型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFIOC%EF%BC%9F"><span class="toc-number">8.9.</span> <span class="toc-text">什么是IOC？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">8.10.</span> <span class="toc-text">IOC的好处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="toc-number">8.11.</span> <span class="toc-text">什么是依赖注入？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">8.12.</span> <span class="toc-text">IOC容器初始化过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">8.13.</span> <span class="toc-text">Bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory%E5%92%8CFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.14.</span> <span class="toc-text">BeanFactory和FactoryBean的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory%E5%92%8CApplicationContext%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.15.</span> <span class="toc-text">BeanFactory和ApplicationContext有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">8.16.</span> <span class="toc-text">Bean注入容器有哪些方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">8.17.</span> <span class="toc-text">Bean的作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">8.18.</span> <span class="toc-text">Spring自动装配的方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.19.</span> <span class="toc-text">@Autowired和@Resource的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qualifier-%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">8.20.</span> <span class="toc-text">@Qualifier 注解有什么作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E5%92%8C-Component%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.21.</span> <span class="toc-text">@Bean和@Component有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Component%E3%80%81-Controller%E3%80%81-Repositor%E5%92%8C-Service-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.22.</span> <span class="toc-text">@Component、@Controller、@Repositor和@Service 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">8.23.</span> <span class="toc-text">Spring 事务实现方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%EF%BC%9F"><span class="toc-number">8.24.</span> <span class="toc-text">有哪些事务传播行为？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">8.25.</span> <span class="toc-text">Spring事务在什么情况下会失效？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">8.26.</span> <span class="toc-text">Spring怎么解决循环依赖的问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">8.27.</span> <span class="toc-text">Spring启动过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E7%9A%84%E5%8D%95%E4%BE%8B-Bean-%E6%98%AF%E5%90%A6%E6%9C%89%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">8.28.</span> <span class="toc-text">Spring 的单例 Bean 是否有并发安全问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Bean%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">8.29.</span> <span class="toc-text">Spring Bean如何保证并发安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Async%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">8.30.</span> <span class="toc-text">@Async注解的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Spring%E5%92%8CIDEA-%E9%83%BD%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-Autowired-%E6%B3%A8%E8%A7%A3%EF%BC%9F"><span class="toc-number">8.31.</span> <span class="toc-text">为什么 Spring和IDEA 都不推荐使用 @Autowired 注解？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#springmvc"><span class="toc-number">9.</span> <span class="toc-text">springmvc</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-SpringMVC-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">9.1.</span> <span class="toc-text">说说你对 SpringMVC 的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMVC%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">9.2.</span> <span class="toc-text">什么是MVC模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-number">9.3.</span> <span class="toc-text">SpringMVC 有哪些优点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC%E5%92%8CStruts%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.4.</span> <span class="toc-text">Spring MVC和Struts的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">9.5.</span> <span class="toc-text">Spring MVC的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">9.6.</span> <span class="toc-text">Spring MVC的主要组件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E7%94%B1%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">9.7.</span> <span class="toc-text">Spring MVC的常用注解由有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Controller-%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">9.8.</span> <span class="toc-text">@Controller 注解有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RequestMapping-%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">9.9.</span> <span class="toc-text">@RequestMapping 注解有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RestController-%E5%92%8C-Controller-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">9.10.</span> <span class="toc-text">@RestController 和 @Controller 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RequestMapping-%E5%92%8C-GetMapping-%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">9.11.</span> <span class="toc-text">@RequestMapping 和 @GetMapping 注解有什么不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RequestParam-%E5%92%8C-PathVariable-%E4%B8%A4%E4%B8%AA%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.12.</span> <span class="toc-text">@RequestParam 和 @PathVariable 两个注解的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RequestBody%E5%92%8C-RequestParam%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.13.</span> <span class="toc-text">@RequestBody和@RequestParam的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">9.14.</span> <span class="toc-text">Spring MVC的异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC-%E7%94%A8%E4%BB%80%E4%B9%88%E5%AF%B9%E8%B1%A1%E4%BB%8E%E5%90%8E%E5%8F%B0%E5%90%91%E5%89%8D%E5%8F%B0%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%9A%84%EF%BC%9F"><span class="toc-number">9.15.</span> <span class="toc-text">SpringMVC 用什么对象从后台向前台传递数据的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMvc%E7%9A%84Controller%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">9.16.</span> <span class="toc-text">SpringMvc的Controller是不是单例模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8B-Spring-MVC-%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%9F"><span class="toc-number">9.17.</span> <span class="toc-text">介绍下 Spring MVC 拦截器？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMvc%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%9F"><span class="toc-number">9.18.</span> <span class="toc-text">SpringMvc怎么配置拦截器？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC-%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C-Filter-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%B7%AE%E5%88%AB%EF%BC%9F"><span class="toc-number">9.19.</span> <span class="toc-text">Spring MVC 的拦截器和 Filter 过滤器有什么差别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFREST"><span class="toc-number">9.20.</span> <span class="toc-text">什么是REST?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8REST%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%E5%91%A2%EF%BC%9F"><span class="toc-number">9.21.</span> <span class="toc-text">使用REST有什么优势呢？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mybatis"><span class="toc-number">10.</span> <span class="toc-text">mybatis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">Mybatis是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ORM%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">10.2.</span> <span class="toc-text">ORM是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E5%92%8CHibernate%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.3.</span> <span class="toc-text">Mybatis和Hibernate的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E5%85%B6%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E5%90%88"><span class="toc-number">10.4.</span> <span class="toc-text">MyBatis框架的优缺点及其适用的场合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">10.5.</span> <span class="toc-text">Mybatis的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9BExecutor%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.6.</span> <span class="toc-text">Mybatis都有哪些Executor执行器？它们之间的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%BB%91%E5%AE%9A%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">10.7.</span> <span class="toc-text">MyBatis中接口绑定有几种实现方式?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E7%9A%84%EF%BC%9F"><span class="toc-number">10.8.</span> <span class="toc-text">Mybatis 是如何进行分页的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.9.</span> <span class="toc-text">分页插件的基本原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0Mybatis%E7%9A%84%E6%8F%92%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">10.10.</span> <span class="toc-text">简述Mybatis的插件运行原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6%EF%BC%9F"><span class="toc-number">10.11.</span> <span class="toc-text">如何编写一个插件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis-%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-number">10.12.</span> <span class="toc-text">Mybatis 是否支持延迟加载？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.13.</span> <span class="toc-text">延迟加载的基本原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.14.</span> <span class="toc-text">#{}和${}的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">10.15.</span> <span class="toc-text">Mybatis的预编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">10.16.</span> <span class="toc-text">一级缓存和二级缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#springboot"><span class="toc-number">11.</span> <span class="toc-text">springboot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Springboot%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">11.1.</span> <span class="toc-text">Springboot的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Javaweb%E3%80%81spring%E3%80%81springmvc%E5%92%8Cspringboot%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E9%83%BD%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">11.2.</span> <span class="toc-text">Javaweb、spring、springmvc和springboot有什么区别，都是做什么用的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot-%E4%B8%AD%E7%9A%84-starter-%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">11.3.</span> <span class="toc-text">SpringBoot 中的 starter 到底是什么 ?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C-SpringBoot-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">11.4.</span> <span class="toc-text">运行 SpringBoot 有哪几种方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot-%E5%B8%B8%E7%94%A8%E7%9A%84-Starter-%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">11.5.</span> <span class="toc-text">SpringBoot 常用的 Starter 有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Boot-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E6%98%AF%E5%93%AA%E4%B8%AA%EF%BC%9F"><span class="toc-number">11.6.</span> <span class="toc-text">Spring Boot 的核心注解是哪个？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">11.7.</span> <span class="toc-text">自动配置原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">11.8.</span> <span class="toc-text">实现自动配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Value%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">11.9.</span> <span class="toc-text">@Value注解的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Boot-%E9%9C%80%E8%A6%81%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-number">11.10.</span> <span class="toc-text">Spring Boot 需要独立的容器运行吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Boot-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="toc-number">11.11.</span> <span class="toc-text">Spring Boot 支持哪些日志框架？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#YAML-%E9%85%8D%E7%BD%AE%E7%9A%84%E4%BC%98%E5%8A%BF%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-number">11.12.</span> <span class="toc-text">YAML 配置的优势在哪里 ?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Profiles%EF%BC%9F"><span class="toc-number">11.13.</span> <span class="toc-text">什么是 Spring Profiles？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86"><span class="toc-number">11.14.</span> <span class="toc-text">SpringBoot多数据源事务如何管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-boot-starter-parent-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">11.15.</span> <span class="toc-text">spring-boot-starter-parent 有什么用 ?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Boot-%E6%89%93%E6%88%90%E7%9A%84-jar-%E5%92%8C%E6%99%AE%E9%80%9A%E7%9A%84-jar-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">11.16.</span> <span class="toc-text">Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%8B%86%E5%88%86%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">11.17.</span> <span class="toc-text">SpringBoot多数据源拆分的思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#springcloud"><span class="toc-number">12.</span> <span class="toc-text">springcloud</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSpring-Cloud-%EF%BC%9F"><span class="toc-number">12.1.</span> <span class="toc-text">1、什么是Spring Cloud ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="toc-number">12.2.</span> <span class="toc-text">2、什么是微服务？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Spring-Cloud%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF"><span class="toc-number">12.3.</span> <span class="toc-text">3、Spring Cloud有什么优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E7%8B%AC%E7%AB%8B%E9%80%9A%E8%AE%AF%E7%9A%84"><span class="toc-number">12.4.</span> <span class="toc-text">4、微服务之间如何独立通讯的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%EF%BC%9F"><span class="toc-number">12.5.</span> <span class="toc-text">5、 什么是服务熔断？什么是服务降级？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81-%E8%AF%B7%E8%AF%B4%E8%AF%B4Eureka%E5%92%8Czookeeper-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.6.</span> <span class="toc-text">6、 请说说Eureka和zookeeper 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81SpringBoot%E5%92%8CSpringCloud%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.7.</span> <span class="toc-text">7、SpringBoot和SpringCloud的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%84%8F%E4%B9%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.8.</span> <span class="toc-text">8、负载平衡的意义什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFHystrix%EF%BC%9F%E5%AE%83%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%B9%E9%94%99%EF%BC%9F"><span class="toc-number">12.9.</span> <span class="toc-text">9、什么是Hystrix？它如何实现容错？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFHystrix%E6%96%AD%E8%B7%AF%E5%99%A8%EF%BC%9F%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%AE%83%E5%90%97%EF%BC%9F"><span class="toc-number">12.10.</span> <span class="toc-text">10、什么是Hystrix断路器？我们需要它吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E8%AF%B4%E8%AF%B4-RPC-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">12.11.</span> <span class="toc-text">11、说说 RPC 的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%EF%BC%8Ceureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">12.12.</span> <span class="toc-text">12，eureka自我保护机制是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AFRibbon%EF%BC%9F"><span class="toc-number">12.13.</span> <span class="toc-text">13，什么是Ribbon？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF-Netflix-Feign%EF%BC%9F%E5%AE%83%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.14.</span> <span class="toc-text">14，什么是 Netflix Feign？它的优点是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%EF%BC%8C-Ribbon%E5%92%8CFeign%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.15.</span> <span class="toc-text">15， Ribbon和Feign的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81Spring-Cloud-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">12.16.</span> <span class="toc-text">16、Spring Cloud 的核心组件有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E8%AF%B4%E8%AF%B4Spring-Boot%E5%92%8CSpring-Cloud%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">12.17.</span> <span class="toc-text">17、说说Spring Boot和Spring Cloud的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81%E8%AF%B4%E8%AF%B4%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E7%8B%AC%E7%AB%8B%E9%80%9A%E8%AE%AF%E7%9A%84%EF%BC%9F"><span class="toc-number">12.18.</span> <span class="toc-text">18、说说微服务之间是如何独立通讯的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81Spring-Cloud%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="toc-number">12.19.</span> <span class="toc-text">19、Spring Cloud如何实现服务的注册?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%EF%BC%9F"><span class="toc-number">12.20.</span> <span class="toc-text">20、什么是服务熔断？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81%E4%BA%86%E8%A7%A3Eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%90%97%EF%BC%9F"><span class="toc-number">12.21.</span> <span class="toc-text">21、了解Eureka自我保护机制吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81%E7%86%9F%E6%82%89-Spring-Cloud-Bus-%E5%90%97"><span class="toc-number">12.22.</span> <span class="toc-text">22、熟悉 Spring Cloud Bus 吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81Spring-Cloud-%E6%96%AD%E8%B7%AF%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">12.23.</span> <span class="toc-text">23、Spring Cloud 断路器有什么作用?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81%E4%BA%86%E8%A7%A3Spring-Cloud-Config-%E5%90%97"><span class="toc-number">12.24.</span> <span class="toc-text">24、了解Spring Cloud Config 吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Spring-Cloud-Gateway%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">12.25.</span> <span class="toc-text">25、说说你对Spring Cloud Gateway的理解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql"><span class="toc-number">13.</span> <span class="toc-text">mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMySQL"><span class="toc-number">13.1.</span> <span class="toc-text">什么是MySQL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">13.2.</span> <span class="toc-text">事务的四大特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">13.3.</span> <span class="toc-text">数据库的三大范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">13.4.</span> <span class="toc-text">事务隔离级别有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%88%AC%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%91%A2%EF%BC%9F"><span class="toc-number">13.5.</span> <span class="toc-text">生产环境数据库一般用的什么隔离级别呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">13.6.</span> <span class="toc-text">编码和字符集的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#utf8%E5%92%8Cutf8mb4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.7.</span> <span class="toc-text">utf8和utf8mb4的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">13.8.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">13.8.1.</span> <span class="toc-text">什么是索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">13.8.2.</span> <span class="toc-text">索引的优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">13.8.3.</span> <span class="toc-text">索引的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">13.8.4.</span> <span class="toc-text">什么情况下需要建索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">13.8.5.</span> <span class="toc-text">什么情况下不建索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">13.8.6.</span> <span class="toc-text">索引的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%B4%A2%E5%BC%95%E5%92%8CB-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">13.8.7.</span> <span class="toc-text">Hash索引和B+树索引的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88B-%E6%A0%91%E6%AF%94B%E6%A0%91%E6%9B%B4%E9%80%82%E5%90%88%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">13.8.8.</span> <span class="toc-text">为什么B+树比B树更适合实现数据库索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="toc-number">13.8.9.</span> <span class="toc-text">索引有什么分类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">13.8.10.</span> <span class="toc-text">什么是最左匹配原则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">13.8.11.</span> <span class="toc-text">什么是聚集索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">13.8.12.</span> <span class="toc-text">什么是覆盖索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">13.8.13.</span> <span class="toc-text">索引的设计原则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">13.8.14.</span> <span class="toc-text">索引什么时候会失效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">13.8.15.</span> <span class="toc-text">什么是前缀索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">13.8.16.</span> <span class="toc-text">索引下推</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">13.9.</span> <span class="toc-text">常见的存储引擎有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">13.10.</span> <span class="toc-text">MyISAM和InnoDB的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81%EF%BC%9F"><span class="toc-number">13.11.</span> <span class="toc-text">MySQL有哪些锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">13.12.</span> <span class="toc-text">MVCC 实现原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">13.13.</span> <span class="toc-text">快照读和当前读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81"><span class="toc-number">13.14.</span> <span class="toc-text">共享锁和排他锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bin-log-redo-log-undo-log"><span class="toc-number">13.15.</span> <span class="toc-text">bin log&#x2F;redo log&#x2F;undo log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bin-log%E5%92%8Credo-log%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">13.16.</span> <span class="toc-text">bin log和redo log有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8BMySQL%E6%9E%B6%E6%9E%84%EF%BC%9F"><span class="toc-number">13.17.</span> <span class="toc-text">讲一下MySQL架构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">13.18.</span> <span class="toc-text">分库分表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%8C%BA%E8%A1%A8%EF%BC%9F"><span class="toc-number">13.19.</span> <span class="toc-text">什么是分区表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">13.20.</span> <span class="toc-text">分区表类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">13.21.</span> <span class="toc-text">分区的问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">13.22.</span> <span class="toc-text">查询语句执行流程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">13.23.</span> <span class="toc-text">更新语句执行过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exist%E5%92%8Cin%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">13.24.</span> <span class="toc-text">exist和in的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E4%B8%ADint-10-%E5%92%8Cchar-10-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">13.25.</span> <span class="toc-text">MySQL中int(10)和char(10)的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#truncate%E3%80%81delete%E4%B8%8Edrop%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">13.26.</span> <span class="toc-text">truncate、delete与drop区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#having%E5%92%8Cwhere%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">13.27.</span> <span class="toc-text">having和where区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMySQL%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-number">13.28.</span> <span class="toc-text">什么是MySQL主从同步？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-number">13.29.</span> <span class="toc-text">为什么要做主从同步？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">13.30.</span> <span class="toc-text">乐观锁和悲观锁是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E8%BF%87processlist%E5%90%97%EF%BC%9F"><span class="toc-number">13.31.</span> <span class="toc-text">用过processlist吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%9F%A5%E8%AF%A2-limit-1000-10-%E5%92%8Climit-10-%E9%80%9F%E5%BA%A6%E4%B8%80%E6%A0%B7%E5%BF%AB%E5%90%97%EF%BC%9F"><span class="toc-number">13.32.</span> <span class="toc-text">MySQL查询 limit 1000,10 和limit 10 速度一样快吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">13.33.</span> <span class="toc-text">深分页怎么优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%BA%A6%E4%B8%BA3%E7%9A%84B-%E6%A0%91%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">13.34.</span> <span class="toc-text">高度为3的B+树，可以存放多少数据？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E5%8D%95%E8%A1%A8%E5%A4%9A%E5%A4%A7%E8%BF%9B%E8%A1%8C%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%9F"><span class="toc-number">13.35.</span> <span class="toc-text">MySQL单表多大进行分库分表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%85%A2%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">13.36.</span> <span class="toc-text">大表查询慢怎么优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4count-1-%E3%80%81count-%E5%92%8Ccount-%E5%AD%97%E6%AE%B5%E5%90%8D-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.37.</span> <span class="toc-text">说说count(1)、count(*)和count(字段名)的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E4%B8%ADDATETIME-%E5%92%8C-TIMESTAMP%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">13.38.</span> <span class="toc-text">MySQL中DATETIME 和 TIMESTAMP有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8%E5%A4%96%E9%94%AE%EF%BC%9F"><span class="toc-number">13.39.</span> <span class="toc-text">说说为什么不建议用外键？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">13.40.</span> <span class="toc-text">使用自增主键有什么好处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%BF%9D%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="toc-number">13.41.</span> <span class="toc-text">自增主键保存在什么地方？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%80%E5%AE%9A%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">13.42.</span> <span class="toc-text">自增主键一定是连续的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E7%9A%84%E8%87%AA%E5%A2%9E%E5%80%BC%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%9B%9E%E6%94%B6%E5%88%A9%E7%94%A8%EF%BC%9F"><span class="toc-number">13.43.</span> <span class="toc-text">InnoDB的自增值为什么不能回收利用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E5%88%B0Redis%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">13.44.</span> <span class="toc-text">MySQL数据如何同步到Redis缓存？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8CJava%E6%89%8B%E5%86%8C%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">13.45.</span> <span class="toc-text">为什么阿里Java手册禁止使用存储过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-update-%E6%98%AF%E9%94%81%E8%A1%8C%E8%BF%98%E6%98%AF%E9%94%81%E8%A1%A8%EF%BC%9F"><span class="toc-number">13.46.</span> <span class="toc-text">MySQL update 是锁行还是锁表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select%E2%80%A6for-update%E4%BC%9A%E9%94%81%E8%A1%A8%E8%BF%98%E6%98%AF%E9%94%81%E8%A1%8C%EF%BC%9F"><span class="toc-number">13.47.</span> <span class="toc-text">select…for update会锁表还是锁行？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E7%9A%84binlog%E6%9C%89%E5%87%A0%E7%A7%8D%E6%A0%BC%E5%BC%8F%EF%BC%9F%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">13.48.</span> <span class="toc-text">MySQL的binlog有几种格式？分别有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BF%E9%87%8C%E6%89%8B%E5%86%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8-count-%E5%88%97%E5%90%8D-%E6%88%96-count-%E5%B8%B8%E9%87%8F-%E6%9D%A5%E6%9B%BF%E4%BB%A3-count"><span class="toc-number">13.49.</span> <span class="toc-text">阿里手册为什么禁止使用 count(列名)或 count(常量)来替代 count(*)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8MD5%E5%80%BC%E5%BA%94%E8%AF%A5%E7%94%A8VARCHAR%E8%BF%98%E6%98%AF%E7%94%A8CHAR%EF%BC%9F"><span class="toc-number">13.50.</span> <span class="toc-text">存储MD5值应该用VARCHAR还是用CHAR？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis"><span class="toc-number">14.</span> <span class="toc-text">redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">14.1.</span> <span class="toc-text">Redis是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">14.2.</span> <span class="toc-text">Redis优缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">14.3.</span> <span class="toc-text">Redis为什么这么快？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A2%E7%84%B6Redis%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E5%AE%83%E5%81%9A%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%8F%AA%E7%94%A8%E5%AE%83%E5%81%9A%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">14.4.</span> <span class="toc-text">既然Redis那么快，为什么不用它做主数据库，只用它做缓存？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2Redis%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">14.5.</span> <span class="toc-text">讲讲Redis的线程模型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">14.6.</span> <span class="toc-text">Redis应用场景有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Memcached%E5%92%8CRedis%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">14.7.</span> <span class="toc-text">Memcached和Redis的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Redis-%E8%80%8C%E4%B8%8D%E7%94%A8-map-guava-%E5%81%9A%E7%BC%93%E5%AD%98"><span class="toc-number">14.8.</span> <span class="toc-text">为什么要用 Redis 而不用 map&#x2F;guava 做缓存?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">14.9.</span> <span class="toc-text">Redis 数据类型有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SortedSet%E5%92%8CList%E5%BC%82%E5%90%8C%E7%82%B9%EF%BC%9F"><span class="toc-number">14.10.</span> <span class="toc-text">SortedSet和List异同点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%94%A8%E5%AE%8C%E4%BA%86%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-number">14.11.</span> <span class="toc-text">Redis的内存用完了会怎样？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E5%81%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">14.12.</span> <span class="toc-text">Redis如何做内存优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keys%E5%91%BD%E4%BB%A4%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">14.13.</span> <span class="toc-text">keys命令存在的问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1"><span class="toc-number">14.14.</span> <span class="toc-text">Redis事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E9%9A%94%E7%A6%BB%E6%80%A7%E5%90%97%EF%BC%9F"><span class="toc-number">14.15.</span> <span class="toc-text">Redis事务支持隔离性吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97%EF%BC%8C%E6%94%AF%E6%8C%81%E5%9B%9E%E6%BB%9A%E5%90%97%EF%BC%9F"><span class="toc-number">14.16.</span> <span class="toc-text">Redis事务保证原子性吗，支持回滚吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">14.17.</span> <span class="toc-text">持久化机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB%E5%92%8CAOF%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-number">14.18.</span> <span class="toc-text">RDB和AOF如何选择？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">14.19.</span> <span class="toc-text">Redis有哪些部署方案？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84"><span class="toc-number">14.20.</span> <span class="toc-text">主从架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5Sentinel"><span class="toc-number">14.21.</span> <span class="toc-text">哨兵Sentinel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-cluster"><span class="toc-number">14.22.</span> <span class="toc-text">Redis cluster</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-number">14.23.</span> <span class="toc-text">过期键的删除策略？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">14.24.</span> <span class="toc-text">内存淘汰策略有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E4%B8%8E-Redis-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">14.25.</span> <span class="toc-text">MySQL 与 Redis 如何保证数据一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">14.26.</span> <span class="toc-text">缓存常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">14.26.1.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">14.26.2.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">14.26.3.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">14.26.4.</span> <span class="toc-text">缓存预热</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7"><span class="toc-number">14.26.5.</span> <span class="toc-text">缓存降级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">14.27.</span> <span class="toc-text">Redis 怎么实现消息队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97"><span class="toc-number">14.28.</span> <span class="toc-text">Redis 怎么实现延时队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pipeline%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">14.29.</span> <span class="toc-text">pipeline的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LUA%E8%84%9A%E6%9C%AC"><span class="toc-number">14.30.</span> <span class="toc-text">LUA脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedLock%EF%BC%9F"><span class="toc-number">14.31.</span> <span class="toc-text">什么是RedLock？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%A4%A7key%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">14.32.</span> <span class="toc-text">Redis大key怎么处理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">14.33.</span> <span class="toc-text">Redis常见性能问题和解决方案？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E8%BF%87%E6%9C%9F%E4%BA%86%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%85%E5%AD%98%E6%B2%A1%E9%87%8A%E6%94%BE%EF%BC%9F"><span class="toc-number">14.34.</span> <span class="toc-text">说说为什么Redis过期了为什么内存没释放？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%AA%81%E7%84%B6%E5%8F%98%E6%85%A2%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-number">14.35.</span> <span class="toc-text">Redis突然变慢，有哪些原因？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Redis-%E9%9B%86%E7%BE%A4%E7%9A%84%E6%9C%80%E5%A4%A7%E6%A7%BD%E6%95%B0%E6%98%AF-16384-%E4%B8%AA%EF%BC%9F"><span class="toc-number">14.36.</span> <span class="toc-text">为什么 Redis 集群的最大槽数是 16384 个？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97"><span class="toc-number">14.37.</span> <span class="toc-text">Redis存在线程安全的问题吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%81%87%E5%88%B0%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">14.38.</span> <span class="toc-text">Redis遇到哈希冲突怎么办？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">15.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">15.1.</span> <span class="toc-text">网络分层结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">15.2.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F"><span class="toc-number">15.3.</span> <span class="toc-text">两次握手可以吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">15.4.</span> <span class="toc-text">四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%AD%89%E5%BE%852MSL%EF%BC%9F"><span class="toc-number">15.5.</span> <span class="toc-text">第四次挥手为什么要等待2MSL？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="toc-number">15.6.</span> <span class="toc-text">为什么是四次挥手？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4TCP%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%85%B6%E4%BD%9C%E7%94%A8%E5%8F%88%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">15.7.</span> <span class="toc-text">说说TCP报文首部有哪些字段，其作用又分别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">15.8.</span> <span class="toc-text">TCP有哪些特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85"><span class="toc-number">15.9.</span> <span class="toc-text">TCP的粘包和拆包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">15.10.</span> <span class="toc-text">TCP和UDP的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">15.11.</span> <span class="toc-text">TCP 和 UDP 分别对应的常见应用层协议有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4TCP%E6%98%AF%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">15.12.</span> <span class="toc-text">说说TCP是如何确保可靠性的呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8BTCP%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6"><span class="toc-number">15.13.</span> <span class="toc-text">说下TCP的滑动窗口机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AE%B2%E4%B8%80%E4%B8%8B%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-number">15.14.</span> <span class="toc-text">详细讲一下拥塞控制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">15.15.</span> <span class="toc-text">HTTP协议的特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">15.16.</span> <span class="toc-text">HTTP报文格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">15.17.</span> <span class="toc-text">HTTP状态码有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E5%8D%8F%E8%AE%AE%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">15.18.</span> <span class="toc-text">HTTP 协议包括哪些请求？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81301%E5%92%8C302%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">15.19.</span> <span class="toc-text">HTTP状态码301和302的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POST%E5%92%8CGET%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">15.20.</span> <span class="toc-text">POST和GET的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URI%E5%92%8CURL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.21.</span> <span class="toc-text">URI和URL的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3HTTP%E5%8D%8F%E8%AE%AE%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84"><span class="toc-number">15.22.</span> <span class="toc-text">如何理解HTTP协议是无状态的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">15.23.</span> <span class="toc-text">HTTP长连接和短连接？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">15.24.</span> <span class="toc-text">HTTP 如何实现长连接？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%B6%85%E6%97%B6%EF%BC%9F"><span class="toc-number">15.25.</span> <span class="toc-text">HTTP长连接在什么时候会超时？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP1-1%E5%92%8C-HTTP2-0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">15.26.</span> <span class="toc-text">HTTP1.1和 HTTP2.0的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E4%B8%8EHTTP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">15.27.</span> <span class="toc-text">HTTPS与HTTP的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%EF%BC%9F"><span class="toc-number">15.28.</span> <span class="toc-text">什么是数字证书？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E5%8E%9F%E7%90%86"><span class="toc-number">15.29.</span> <span class="toc-text">HTTPS原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS-%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">15.30.</span> <span class="toc-text">DNS 的解析过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5URL%E8%BF%94%E5%9B%9E%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">15.31.</span> <span class="toc-text">浏览器中输入URL返回页面过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">15.32.</span> <span class="toc-text">DNS 域名解析的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFcookie%E5%92%8Csession%EF%BC%9F"><span class="toc-number">15.33.</span> <span class="toc-text">什么是cookie和session？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">15.34.</span> <span class="toc-text">cookie和session的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%9F"><span class="toc-number">15.35.</span> <span class="toc-text">什么是对称加密和非对称加密？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-WebSocket%E4%B8%8Esocket%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.36.</span> <span class="toc-text">说说 WebSocket与socket的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">15.37.</span> <span class="toc-text">ARP协议的工作过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ICMP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">15.38.</span> <span class="toc-text">ICMP协议的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDoS%E3%80%81DDoS%E3%80%81DRDoS%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">15.39.</span> <span class="toc-text">什么是DoS、DDoS、DRDoS攻击？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCSRF%E6%94%BB%E5%87%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="toc-number">15.40.</span> <span class="toc-text">什么是CSRF攻击，如何避免</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFXSS%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">15.41.</span> <span class="toc-text">什么是XSS攻击？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3XSS%E6%94%BB%E5%87%BB%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">15.42.</span> <span class="toc-text">如何解决XSS攻击问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E7%9B%97%E9%93%BE"><span class="toc-number">15.43.</span> <span class="toc-text">防盗链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8Bping%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">15.44.</span> <span class="toc-text">说下ping的原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86"><span class="toc-number">16.</span> <span class="toc-text">计算机组成原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">16.1.</span> <span class="toc-text">第一章 计算机系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">16.1.1.</span> <span class="toc-text">第一节 计算机系统层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">16.1.2.</span> <span class="toc-text">第二节 计算机性能指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">16.1.3.</span> <span class="toc-text">题目总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97"><span class="toc-number">16.2.</span> <span class="toc-text">第二章 数据的表示和运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">16.3.</span> <span class="toc-text">第三章 存储系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">16.3.1.</span> <span class="toc-text">第一节 存储器概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">16.3.2.</span> <span class="toc-text">第二节 主存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">16.3.3.</span> <span class="toc-text">第三节 主存储器与CPU的连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82-%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">16.3.4.</span> <span class="toc-text">第四节 外部存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%8A%82-%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">16.3.5.</span> <span class="toc-text">第五节 高速缓冲存储器（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E8%8A%82-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">16.3.6.</span> <span class="toc-text">第六节 虚拟存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-number">16.3.7.</span> <span class="toc-text">题目总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">16.4.</span> <span class="toc-text">第四章 指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">16.4.1.</span> <span class="toc-text">第一节 指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">16.4.2.</span> <span class="toc-text">第二节 寻址方式（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B8%8E%E6%9C%BA%E5%99%A8%E7%BA%A7%E4%BB%A3%E7%A0%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AF%B9%E5%BA%94"><span class="toc-number">16.4.3.</span> <span class="toc-text">第三节 高级语言程序与机器级代码之间的对应</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">16.5.</span> <span class="toc-text">第五章 中央处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-CPU"><span class="toc-number">16.5.1.</span> <span class="toc-text">第一节 CPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">16.5.2.</span> <span class="toc-text">第二节 指令执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">16.5.3.</span> <span class="toc-text">第三节 数据通路的功能和基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">16.5.4.</span> <span class="toc-text">第四节 控制器的功能和工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">16.5.5.</span> <span class="toc-text">第五节 异常和中断机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E8%8A%82-%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">16.5.6.</span> <span class="toc-text">第六节 指令流水线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%9A-2"><span class="toc-number">16.5.7.</span> <span class="toc-text">题目总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E8%8A%82-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E9%80%89%E6%8B%A9%E9%A2%98%EF%BC%89"><span class="toc-number">16.5.8.</span> <span class="toc-text">第七节 多处理器的基本概念（选择题）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%80%BB%E7%BA%BF"><span class="toc-number">16.6.</span> <span class="toc-text">第六章 总线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%80%BB%E7%BA%BF%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">16.6.1.</span> <span class="toc-text">第一节 总线的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">16.6.2.</span> <span class="toc-text">第二节 性能指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E6%80%BB%E7%BA%BF%E5%AE%9A%E6%97%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">16.6.3.</span> <span class="toc-text">第三节 总线定时方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-I-O%E7%B3%BB%E7%BB%9F"><span class="toc-number">16.7.</span> <span class="toc-text">第七章 I&#x2F;O系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-I-O%E6%8E%A5%E5%8F%A3"><span class="toc-number">16.7.1.</span> <span class="toc-text">第一节 I&#x2F;O接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AEI-O%E8%AE%BE%E5%A4%87%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">16.7.2.</span> <span class="toc-text">第二节 主机访问I&#x2F;O设备的控制方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">17.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">17.1.</span> <span class="toc-text">操作系统的四个特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B-1"><span class="toc-number">17.2.</span> <span class="toc-text">进程线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-number">17.3.</span> <span class="toc-text">并发和并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E8%BE%83%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">17.4.</span> <span class="toc-text">多线程相较单线程的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%EF%BC%9F"><span class="toc-number">17.5.</span> <span class="toc-text">什么是协程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F"><span class="toc-number">17.6.</span> <span class="toc-text">线程和协程有什么区别呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">17.7.</span> <span class="toc-text">进程通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">17.8.</span> <span class="toc-text">什么是死锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%EF%BC%9F%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-number">17.9.</span> <span class="toc-text">死锁怎么产生？怎么避免？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">17.10.</span> <span class="toc-text">进程调度策略有哪几种？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">17.11.</span> <span class="toc-text">进程有哪些状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8C%E7%9A%84%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">17.12.</span> <span class="toc-text">操作系统里的内存碎片怎么理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">17.13.</span> <span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E9%A1%B5%EF%BC%9F"><span class="toc-number">17.14.</span> <span class="toc-text">什么是分页？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E6%AE%B5%EF%BC%9F"><span class="toc-number">17.15.</span> <span class="toc-text">什么是分段？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E6%9C%89%E4%BB%80%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">17.16.</span> <span class="toc-text">分页和分段有什区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">17.17.</span> <span class="toc-text">页面置换算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">17.18.</span> <span class="toc-text">用户态和内核态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%BF%99%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">17.18.1.</span> <span class="toc-text">为什么要有这两种状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BD%AC%E6%8D%A2"><span class="toc-number">17.18.2.</span> <span class="toc-text">什么时候转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3%EF%BC%9F"><span class="toc-number">17.19.</span> <span class="toc-text">什么是缓冲区溢出？有什么危害？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">17.20.</span> <span class="toc-text">IO多路复用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.</span> <span class="toc-text">常见架构模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8D%95%E5%BA%93%E5%8D%95%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.0.1.</span> <span class="toc-text">三、单库单应用模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.0.2.</span> <span class="toc-text">四、内容分发模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%9F%A5%E8%AF%A2%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.0.3.</span> <span class="toc-text">五、查询分离模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.0.4.</span> <span class="toc-text">六、微服务模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.0.5.</span> <span class="toc-text">七、多级缓存模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.0.6.</span> <span class="toc-text">八、分库分表模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.0.7.</span> <span class="toc-text">九、弹性伸缩模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%A4%9A%E6%9C%BA%E6%88%BF%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.0.8.</span> <span class="toc-text">十、多机房模式</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/8197/" title="漫画爬虫"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/spider.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="漫画爬虫"/></a><div class="content"><a class="title" href="/posts/8197/" title="漫画爬虫">漫画爬虫</a><time datetime="2023-08-10T04:29:08.000Z" title="发表于 2023-08-10 12:29:08">2023-08-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8009/" title="视频爬虫"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/spider.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="视频爬虫"/></a><div class="content"><a class="title" href="/posts/8009/" title="视频爬虫">视频爬虫</a><time datetime="2023-08-07T04:29:08.000Z" title="发表于 2023-08-07 12:29:08">2023-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/24274/" title="网易云音乐爬虫"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/spider.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网易云音乐爬虫"/></a><div class="content"><a class="title" href="/posts/24274/" title="网易云音乐爬虫">网易云音乐爬虫</a><time datetime="2023-08-05T04:29:08.000Z" title="发表于 2023-08-05 12:29:08">2023-08-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/40066/" title="小说爬虫"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/spider.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="小说爬虫"/></a><div class="content"><a class="title" href="/posts/40066/" title="小说爬虫">小说爬虫</a><time datetime="2023-08-01T04:29:08.000Z" title="发表于 2023-08-01 12:29:08">2023-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/63815/" title="百度图片爬虫"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/UpPictures/UpCover/spider.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="百度图片爬虫"/></a><div class="content"><a class="title" href="/posts/63815/" title="百度图片爬虫">百度图片爬虫</a><time datetime="2023-07-29T04:29:08.000Z" title="发表于 2023-07-29 12:29:08">2023-07-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 茶白</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const disqus_config = function () {
    this.page.url = 'https://chabai000.github.io/posts/17883/'
    this.page.identifier = '/posts/17883/'
    this.page.title = 'Java八股文'
  }

  const disqusReset = () => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addGlobalFn('themeChange', disqusReset, 'disqus')

  const loadDisqus = () =>{
    if (window.DISQUS) disqusReset()
    else {
      const script = document.createElement('script')
      script.src = 'https://lchabai.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=lchabai&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if ('Disqus' === 'Disqus' || !true) {
    if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    fetch('https://disqus.com/api/3.0/forums/listPosts.json?forum=lchabai&related=thread&limit=6&api_key=')
      .then(response => response.json())
      .then(data => {
        const disqusArray = data.response.map(item => {
          return {
            'avatar': item.author.avatar.cache,
            'content': changeContent(item.message),
            'nick': item.author.name,
            'url': item.url,
            'date': item.createdAt
          }
        })

        saveToLocal.set('disqus-newest-comments', JSON.stringify(disqusArray), 10/(60*24))
        generateHtml(disqusArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (false) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick}</span><time> / ${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('disqus-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="9310458102" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-lrcType="0"> </div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>